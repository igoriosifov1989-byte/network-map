{"file_contents":{"OPENTELEMETRY_INTEGRATION.md":{"content":"# OpenTelemetry Integration Summary\n\n## Overview\n\nÐ£ÑÐ¿ÐµÑˆÐ½Ð¾ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð° OpenTelemetry Ð² Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ ÑÐµÑ‚ÐµÐ²Ñ‹Ñ… Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼, Ð´Ð¾Ð¿Ð¾Ð»Ð½ÑÑ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð» Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ñ… network events.\n\n## Ð ÐµÐ°Ð»Ð¸Ð·Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹\n\n### 1. Database Schema (shared/schema.ts)\n```sql\n-- Traces table: Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¾ Ñ‚Ñ€ÐµÐ¹ÑÐ°Ñ…\nCREATE TABLE traces (\n  trace_id VARCHAR(32) UNIQUE,  -- 128-bit hex ÐºÐ°Ðº Ð² ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ðµ\n  service_name VARCHAR(255),\n  start_time, end_time, duration,\n  span_count, status, attributes JSONB\n);\n\n-- Spans table: Ð´ÐµÑ‚Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¾ ÑÐ¿Ð°Ð½Ð°Ñ…  \nCREATE TABLE spans (\n  span_id VARCHAR(16) UNIQUE,    -- 64-bit hex ÐºÐ°Ðº Ð² ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ðµ\n  trace_id VARCHAR(32),          -- ÑÑÑ‹Ð»ÐºÐ° Ð½Ð° trace\n  parent_span_id VARCHAR(16),    -- Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ñ ÑÐ¿Ð°Ð½Ð¾Ð²\n  operation_name VARCHAR(255),\n  kind INTEGER,                  -- 1=Client, 2=Server, 3=Internal, 4=Producer, 5=Consumer\n  start_time, end_time, duration,\n  status, attributes JSONB,\n  events JSONB, links JSONB\n);\n```\n\n### 2. OpenTelemetry Generator (server/opentelemetryGenerator.ts)\n- Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ Ñ€ÐµÐ°Ð»Ð¸ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ðµ Ñ‚Ñ€ÐµÐ¹ÑÑ‹ Ñ Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¼Ð¸ ÑÐ¿Ð°Ð½Ð°Ð¼Ð¸\n- ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ðµ parent-child Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸Ñ Ð¼ÐµÐ¶Ð´Ñƒ ÑÐ¿Ð°Ð½Ð°Ð¼Ð¸\n- Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ðµ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ñ‹ OpenTelemetry (service.name, http.method, span.kind)\n- Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð¸ Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ðµ OTLP\n- ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ network events Ð´Ð»Ñ ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚Ð¸\n\n### 3. API Endpoints (server/routes.ts)\n```\nPOST /api/otel/start    - Ð·Ð°Ð¿ÑƒÑÐº Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ñ‚Ñ€ÐµÐ¹ÑÐ¾Ð²\nPOST /api/otel/stop     - Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸\nGET  /api/otel/traces   - Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ñ‚Ñ€ÐµÐ¹ÑÐ¾Ð²\nGET  /api/otel/traces/:traceId/spans - ÑÐ¿Ð°Ð½Ñ‹ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ Ñ‚Ñ€ÐµÐ¹ÑÐ°\n```\n\n### 4. Data Processor (client/src/lib/opentelemetryProcessor.ts)\n- ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ OpenTelemetry Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼Ñ‹\n- ÐŸÐ¾ÑÑ‚Ñ€Ð¾ÐµÐ½Ð¸Ðµ ÑÐ²ÑÐ·ÐµÐ¹ service-to-service Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ parent-child ÑÐ¿Ð°Ð½Ð¾Ð²\n- ÐÐ³Ñ€ÐµÐ³Ð°Ñ†Ð¸Ñ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸: HTTP ÐºÐ¾Ð´Ñ‹, Ð»Ð°Ñ‚ÐµÐ½Ñ‚Ð½Ð¾ÑÑ‚ÑŒ, Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ð° Ð²Ñ‹Ð·Ð¾Ð²Ð¾Ð²\n- Ð¡Ð»Ð¸ÑÐ½Ð¸Ðµ Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¼Ð¸ Ñ„Ð°Ð¹Ð»Ð¾Ð²Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸\n\n### 5. UI Controls (client/src/components/OpenTelemetryControls.tsx)\n- ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñƒ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð°Ð¼Ð¸: OpenTelemetry vs Network Events\n- ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»Ð¾Ð² Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ (1Ñ - 30Ñ)\n- ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ñ€Ð°Ð·Ð»Ð¸Ñ‡Ð¸Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ\n- Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¼ UI\n\n## Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚Ñ‹ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n\n### OpenTelemetry Format (Ð½Ð¾Ð²Ñ‹Ð¹)\n- **Traces**: ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ðµ trace_id (128-bit), Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°\n- **Spans**: Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ñ parent-child Ð¾Ñ‚Ð½Ð¾ÑˆÐµÐ½Ð¸ÑÐ¼Ð¸\n- **Attributes**: ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ðµ Ð¿Ð¾Ð»Ñ (service.name, http.method, span.kind)\n- **Events**: Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ ÑÐ¿Ð°Ð½Ð¾Ð²\n- **Resource**: Ð¼ÐµÑ‚Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾ ÑÐµÑ€Ð²Ð¸ÑÐµ Ð¸ Ð²ÐµÑ€ÑÐ¸Ð¸\n\n### Network Events (ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¹)\n- **Events**: Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ðµ source-target ÑÐ²ÑÐ·Ð¸\n- **Compatibility**: ÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚ÑŒ Ñ CSV Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¾Ð¹\n- **Metadata**: HTTP Ð¼ÐµÑ‚Ð¾Ð´Ñ‹, ÑÑ‚Ð°Ñ‚ÑƒÑÑ‹, Ð²Ñ€ÐµÐ¼Ñ Ð¾Ñ‚ÐºÐ»Ð¸ÐºÐ°\n\n## Ð¢ÐµÐºÑƒÑ‰Ð¸Ð¹ ÑÑ‚Ð°Ñ‚ÑƒÑ\n\nâœ… **Ð Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚**: OpenTelemetry Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°ÐµÑ‚ Ñ€ÐµÐ°Ð»Ð¸ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ðµ Ñ‚Ñ€ÐµÐ¹ÑÑ‹\nâœ… **Database**: Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ traces Ð¸ spans ÑÐ¾Ð·Ð´Ð°Ð½Ñ‹ Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð¸Ñ€ÑƒÑŽÑ‚  \nâœ… **API**: endpoints Ð¾Ñ‚Ð²ÐµÑ‡Ð°ÑŽÑ‚ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸\nâœ… **Ð¢ÐµÑÑ‚Ñ‹**: ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ñ‚ÐµÑÑ‚Ð¾Ð² Ð´Ð»Ñ Ð²ÑÐµÑ… ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²\n\n### ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÑ‹\n```bash\n# Ð¡Ñ‚Ð°Ñ‚ÑƒÑ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ OpenTelemetry\nðŸ“Š Stored OpenTelemetry trace 204000001000005010000c0000000005 with 6 spans\nðŸ“Š Stored OpenTelemetry trace 005000a000000e00c0000b00d6000000 with 4 spans\n```\n\n### ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n```json\n{\n  \"traceId\": \"0f000d50004f0c0e030000d000890000\",\n  \"serviceName\": \"api-gateway\", \n  \"spanCount\": 4,\n  \"status\": \"error\",\n  \"attributes\": {\n    \"trace.span_count\": 4,\n    \"trace.service_count\": 4,\n    \"trace.root_service\": \"api-gateway\"\n  }\n}\n```\n\n## Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ ÑˆÐ°Ð³Ð¸\n\n1. **Frontend Integration**: Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ OpenTelemetryControls Ðº Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¼Ñƒ UI\n2. **Data Visualization**: Ð°Ð´Ð°Ð¿Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ 3D Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑŽ Ð´Ð»Ñ span Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ð¹\n3. **Trace Explorer**: Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ span timeline Ð¸ Ð°Ñ‚Ñ€Ð¸Ð±ÑƒÑ‚Ð¾Ð²\n4. **Real-time Updates**: Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰ÐµÐ¹ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¾Ð¹ real-time Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹\n5. **Performance**: Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð´Ð»Ñ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ñ… Ð¾Ð±ÑŠÐµÐ¼Ð¾Ð² Ñ‚Ñ€ÐµÐ¹ÑÐ¾Ð²\n\n## ÐŸÑ€ÐµÐ¸Ð¼ÑƒÑ‰ÐµÑÑ‚Ð²Ð°\n\n- **Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾ÑÑ‚ÑŒ**: Ð¿Ð¾Ð»Ð½Ð¾Ðµ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ OpenTelemetry ÑÐ¿ÐµÑ†Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸\n- **ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€ÑƒÐµÐ¼Ð¾ÑÑ‚ÑŒ**: Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° ÑÐ»Ð¾Ð¶Ð½Ñ‹Ñ… Ð¼Ð¸ÐºÑ€Ð¾ÑÐµÑ€Ð²Ð¸ÑÐ½Ñ‹Ñ… Ð°Ñ€Ñ…Ð¸Ñ‚ÐµÐºÑ‚ÑƒÑ€  \n- **Ð¡Ð¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð¾ÑÑ‚ÑŒ**: ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ð¼Ð¸ CSV Ñ„Ð°Ð¹Ð»Ð°Ð¼Ð¸\n- **Ð”ÐµÑ‚Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ**: Ð³Ð»ÑƒÐ±Ð¾ÐºÐ¸Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· performance Ñ‡ÐµÑ€ÐµÐ· span Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ð¸\n- **Ð“Ð¸Ð±ÐºÐ¾ÑÑ‚ÑŒ**: Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñƒ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð°Ð¼Ð¸ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ Ð½ÑƒÐ¶Ð´\n\nÐ˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ñ OpenTelemetry Ð·Ð½Ð°Ñ‡Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ€ÑÐµÑ‚ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° distributed tracing Ð¸ Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶Ð°ÐµÑ‚ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ðº ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð°Ð¼ enterprise monitoring ÑÐ¸ÑÑ‚ÐµÐ¼.","size_bytes":6065},"TESTING.md":{"content":"# Testing Guide\n\nÐ­Ñ‚Ð¾Ñ‚ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚ Ð¾Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÑ‚ Ð²ÑÐµ Ñ‚ÐµÑÑ‚Ñ‹ Ð² Ð¿Ñ€Ð¾ÐµÐºÑ‚Ðµ DiagramFlow Ð¸ ÐºÐ°Ðº Ð¸Ñ… Ð·Ð°Ð¿ÑƒÑÐºÐ°Ñ‚ÑŒ.\n\n## ÐžÐ±Ð·Ð¾Ñ€ Ñ‚ÐµÑÑ‚Ð¾Ð²\n\nÐŸÑ€Ð¾ÐµÐºÑ‚ Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ñ‚ÐµÑÑ‚Ð¾Ð², Ð¿Ð¾ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‰Ð¸Ð¹ Ð²ÑÐµ Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸:\n\n### Frontend Ñ‚ÐµÑÑ‚Ñ‹ (client/src/test/)\n- **utils.test.ts** - Ð¢ÐµÑÑ‚Ñ‹ Ð²ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ (className utility)\n- **diagramUtils.test.ts** - Ð¢ÐµÑÑ‚Ñ‹ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ð¾Ð² ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n- **eventProcessor.test.ts** - Ð¢ÐµÑÑ‚Ñ‹ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÐµÑ‚ÐµÐ²Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\n- **components.test.tsx** - Ð¢ÐµÑÑ‚Ñ‹ React ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð² (Statistics, TraceList)\n- **integration.test.tsx** - Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹ Ð²ÑÐµÐ³Ð¾ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\n\n### Backend Ñ‚ÐµÑÑ‚Ñ‹ (server/test/)\n- **api.test.ts** - Ð¢ÐµÑÑ‚Ñ‹ API Ð¼Ð°Ñ€ÑˆÑ€ÑƒÑ‚Ð¾Ð² Ð¸ HTTP endpoints\n\n## Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð²\n\n### Ð’ÑÐµ Ñ‚ÐµÑÑ‚Ñ‹\n```bash\nnpx vitest\n```\n\n### Ð—Ð°Ð¿ÑƒÑÐº Ñ‚ÐµÑÑ‚Ð¾Ð² Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð·\n```bash\nnpx vitest run\n```\n\n### Ð¢Ð¾Ð»ÑŒÐºÐ¾ ÐºÐ»Ð¸ÐµÐ½Ñ‚ÑÐºÐ¸Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n```bash\nnpx vitest run client/src/test\n```\n\n### Ð¢Ð¾Ð»ÑŒÐºÐ¾ ÑÐµÑ€Ð²ÐµÑ€Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n```bash\nnpx vitest run server/test\n```\n\n### Ð¢ÐµÑÑ‚Ñ‹ Ñ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹\n```bash\nnpx vitest --watch\n```\n\n### Ð¢ÐµÑÑ‚Ñ‹ Ñ Ð¿Ð¾ÐºÑ€Ñ‹Ñ‚Ð¸ÐµÐ¼ ÐºÐ¾Ð´Ð°\n```bash\nnpx vitest run --coverage\n```\n\n## Ð§Ñ‚Ð¾ Ñ‚ÐµÑÑ‚Ð¸Ñ€ÑƒÐµÑ‚ÑÑ\n\n### 1. ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ñ‹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n- Force layout (ÑÐ¸Ð»Ð¾Ð²Ð°Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ°)\n- Circular layout (ÐºÑ€ÑƒÐ³Ð¾Ð²Ð°Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ°)\n- Grid layout (ÑÐµÑ‚Ñ‡Ð°Ñ‚Ð°Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ°)\n- Hierarchical layout (Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ°)\n- Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¿ÑƒÑÑ‚Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n\n### 2. ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÐµÑ‚ÐµÐ²Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\n- ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹ Ð² Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼Ñ‹\n- ÐÐ³Ñ€ÐµÐ³Ð°Ñ†Ð¸Ñ ÑÑ‡ÐµÑ‚Ñ‡Ð¸ÐºÐ¾Ð² ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹\n- ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ HTTP ÑÑ‚Ð°Ñ‚ÑƒÑ ÐºÐ¾Ð´Ð¾Ð²\n- Ð“Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð¿Ð¾ trace ID\n- Ð’Ñ‹Ñ‡Ð¸ÑÐ»ÐµÐ½Ð¸Ðµ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸\n- ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð¸ real-time\n\n### 3. React ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹\n- **Statistics** - Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ HTTP ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ¸, Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð°Ñ†Ð¸Ñ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹\n- **TraceList** - ÑÐ¿Ð¸ÑÐ¾Ðº trace ID, Ð²Ñ‹Ð±Ð¾Ñ€/ÑÐ½ÑÑ‚Ð¸Ðµ Ð²Ñ‹Ð±Ð¾Ñ€Ð°\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¿ÑƒÑÑ‚Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- Ð’Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ\n\n### 4. Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n- Ð ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð³Ð¾ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\n- Ð’Ñ‹Ð±Ð¾Ñ€ trace Ð¸ Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÐ° ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²\n- ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ñ€ÐµÐ¶Ð¸Ð¼Ð¾Ð² Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ\n- Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n- Ð¡Ð¿Ñ€Ð°Ð²Ð¾Ñ‡Ð½Ð°Ñ Ð¿Ð°Ð½ÐµÐ»ÑŒ\n- Real-time ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»Ñ‹\n- ÐÐ´Ð°Ð¿Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð´Ð¸Ð·Ð°Ð¹Ð½\n\n### 5. API Ñ‚ÐµÑÑ‚Ñ‹\n- **Ð”Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼Ñ‹**: CRUD Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ (ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ, Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ, Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ, ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ðµ)\n- **Ð¡ÐµÑ‚ÐµÐ²Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ**: Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð² Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ðµ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸, Ð»Ð¸Ð¼Ð¸Ñ‚Ñ‹\n- **Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹**: Ð·Ð°Ð¿ÑƒÑÐº/Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° real-time Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸\n- **Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ñ„Ð°Ð¹Ð»Ð¾Ð²**: CSV/Excel Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³, Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ, Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ðµ Ñ„Ð°Ð¹Ð»Ñ‹\n- **ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾ÑˆÐ¸Ð±Ð¾Ðº**: 404, Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ JSON, Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ\n- **CORS Ð¸ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸**\n\n### 6. Ð’ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸\n- ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ CSS ÐºÐ»Ð°ÑÑÐ¾Ð² (className utility)\n- Ð£ÑÐ»Ð¾Ð²Ð½Ñ‹Ðµ ÐºÐ»Ð°ÑÑÑ‹\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° undefined/null Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹\n\n## ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¾Ð²\n\n### Vitest Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°\n- Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ jsdom environment Ð´Ð»Ñ DOM Ñ‚ÐµÑÑ‚Ð¾Ð²\n- ÐÐ°ÑÑ‚Ñ€Ð¾ÐµÐ½ alias Ð´Ð»Ñ Ð¿ÑƒÑ‚ÐµÐ¹ (@, @shared, @assets)\n- Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¾Ð²\n- ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÐ° Ð¿Ð¾ÑÐ»Ðµ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ñ‚ÐµÑÑ‚Ð°\n\n### ÐœÐ¾ÐºÐ¸\n- **Three.js** - Ð¿Ñ€ÐµÐ´Ð¾Ñ‚Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ WebGL Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð² Ñ‚ÐµÑÑ‚Ð°Ñ…\n- **Browser APIs** - matchMedia, ResizeObserver, URL.createObjectURL\n- **QueryClient** - Ð´Ð»Ñ React Query Ñ‚ÐµÑÑ‚Ð¾Ð²\n\n## Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ñ„Ð°Ð¹Ð»Ð¾Ð²\n\n```\nclient/src/test/\nâ”œâ”€â”€ setup.ts              # ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¾Ð²Ð¾Ð³Ð¾ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\nâ”œâ”€â”€ utils.test.ts          # Ð¢ÐµÑÑ‚Ñ‹ Ð²ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹\nâ”œâ”€â”€ diagramUtils.test.ts   # Ð¢ÐµÑÑ‚Ñ‹ Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ð¾Ð² Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\nâ”œâ”€â”€ eventProcessor.test.ts # Ð¢ÐµÑÑ‚Ñ‹ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\nâ”œâ”€â”€ components.test.tsx    # Ð¢ÐµÑÑ‚Ñ‹ React ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²\nâ””â”€â”€ integration.test.tsx   # Ð˜Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸Ð¾Ð½Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n\nserver/test/\nâ””â”€â”€ api.test.ts           # Ð¢ÐµÑÑ‚Ñ‹ API endpoints\n\nvitest.config.ts          # ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ Vitest\n```\n\n## ÐŸÐ¾ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ ÐºÐ¾Ð´Ð°\n\nÐ¢ÐµÑÑ‚Ñ‹ Ð¿Ð¾ÐºÑ€Ñ‹Ð²Ð°ÑŽÑ‚ Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸:\n- âœ… ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ñ‹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n- âœ… ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¸ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- âœ… React ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹ Ð¸ Ð¸Ñ… Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ\n- âœ… API endpoints Ð¸ Ð¼Ð°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹\n- âœ… ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾ÑˆÐ¸Ð±Ð¾Ðº\n- âœ… Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- âœ… Real-time Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»\n- âœ… Ð¤Ð°Ð¹Ð»Ð¾Ð²Ñ‹Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸\n\n## Ð˜Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ðµ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ\n\n1. **3D Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³** - Three.js WebGL Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð¿Ñ€Ð¾Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Node.js Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ð¸\n2. **Ð¤Ð°Ð¹Ð»Ð¾Ð²Ð°Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ°** - Ð¢ÐµÑÑ‚Ñ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑŽÑ‚ Ð¼Ð¾ÐºÐ¸ Ð´Ð»Ñ multer file upload\n3. **WebSocket** - Real-time ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€ÑƒÑŽÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ· HTTP API\n\n## Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð¾Ð²Ñ‹Ñ… Ñ‚ÐµÑÑ‚Ð¾Ð²\n\n### Ð”Ð»Ñ Ð½Ð¾Ð²Ñ‹Ñ… ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²:\n1. Ð¡Ð¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ñ„Ð°Ð¹Ð» Ð² `client/src/test/`\n2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ TestWrapper Ð´Ð»Ñ QueryClient\n3. ÐœÐ¾ÐºÐ°Ð¹Ñ‚Ðµ Ð²Ð½ÐµÑˆÐ½Ð¸Ðµ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸\n4. Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð» Ð¸ Ð³Ñ€Ð°Ð½Ð¸Ñ‡Ð½Ñ‹Ðµ ÑÐ»ÑƒÑ‡Ð°Ð¸\n\n### Ð”Ð»Ñ Ð½Ð¾Ð²Ñ‹Ñ… API:\n1. Ð”Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ñ‚ÐµÑÑ‚Ñ‹ Ð² `server/test/api.test.ts`\n2. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ supertest Ð´Ð»Ñ HTTP Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²\n3. Ð¢ÐµÑÑ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑƒÑÐ¿ÐµÑˆÐ½Ñ‹Ðµ Ð¸ Ð¾ÑˆÐ¸Ð±Ð¾Ñ‡Ð½Ñ‹Ðµ ÑÑ†ÐµÐ½Ð°Ñ€Ð¸Ð¸\n4. ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐ¹Ñ‚Ðµ Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸ÑŽ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n\n## ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ð·Ð°Ñ†Ð¸Ñ\n\nÐ¢ÐµÑÑ‚Ñ‹ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð² CI/CD:\n```bash\n# ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð²ÑÐµÑ… Ñ‚ÐµÑÑ‚Ð¾Ð²\nnpm run test:run\n\n# Ð¡ Ð¿Ð¾ÐºÑ€Ñ‹Ñ‚Ð¸ÐµÐ¼ ÐºÐ¾Ð´Ð°\nnpm run test:coverage\n```\n\nÐ’ÑÐµ Ñ‚ÐµÑÑ‚Ñ‹ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð¿Ñ€Ð¾Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€ÐµÐ´ Ð´ÐµÐ¿Ð»Ð¾ÐµÐ¼ Ð² production.","size_bytes":6908},"TEST_SUMMARY.md":{"content":"# Ð ÐµÐ·ÑŽÐ¼Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ DiagramFlow\n\n## ÐžÐ±Ð·Ð¾Ñ€\n\nÐ¡Ð¾Ð·Ð´Ð°Ð½ ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ñ‚ÐµÑÑ‚Ð¾Ð² Ð´Ð»Ñ Ð²ÑÐµÐ³Ð¾ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»Ð° Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼ ÑÐµÑ‚ÐµÐ²Ð¾Ð³Ð¾ Ñ‚Ñ€Ð°Ñ„Ð¸ÐºÐ°.\n\n## Ð¡Ð¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n\n### âœ… Ð Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‰Ð¸Ðµ Ñ‚ÐµÑÑ‚Ñ‹\n\n**client/src/test/utils.test.ts** - ÐŸÑ€Ð¾Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚\n- cn() Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ CSS ÐºÐ»Ð°ÑÑÐ¾Ð²\n- Ð£ÑÐ»Ð¾Ð²Ð½Ñ‹Ðµ ÐºÐ»Ð°ÑÑÑ‹\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° undefined/null Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹\n\n### ðŸ“‹ Ð¡Ð¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ð½Ð°Ð±Ð¾Ñ€Ñ‹\n\n**1. client/src/test/diagramUtils.test.ts**\n- ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ñ‹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸: force, circular, grid, hierarchical\n- Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- Ð“Ñ€Ð°Ð½Ð¸Ñ‡Ð½Ñ‹Ðµ ÑÐ»ÑƒÑ‡Ð°Ð¸ (Ð¿ÑƒÑÑ‚Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ, Ð¾Ð´Ð½Ð° Ð½Ð¾Ð´Ð°)\n\n**2. client/src/test/eventProcessor.test.ts**\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÑÐµÑ‚ÐµÐ²Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\n- ÐÐ³Ñ€ÐµÐ³Ð°Ñ†Ð¸Ñ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹\n- ÐžÑ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸Ðµ HTTP ÑÑ‚Ð°Ñ‚ÑƒÑ ÐºÐ¾Ð´Ð¾Ð²\n- Ð“Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ° Ð¿Ð¾ trace ID\n- ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð¾Ð² Ð¸ real-time Ð´Ð°Ð½Ð½Ñ‹Ñ…\n\n**3. client/src/test/components.test.tsx**\n- Statistics ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ (HTTP ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°, Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð°Ñ†Ð¸Ñ)\n- TraceList ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ (Ð²Ñ‹Ð±Ð¾Ñ€ trace, Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÐ°)\n- Ð˜Ð½Ñ‚ÐµÑ€Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¿ÑƒÑÑ‚Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ…\n\n**4. client/src/test/integration.test.tsx**\n- ÐŸÐ¾Ð»Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ DiagramGenerator\n- Ð’Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²\n- Ð’Ñ‹Ð±Ð¾Ñ€ trace Ð¸ Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÐ°\n- Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð¸ ÑÐ¿Ñ€Ð°Ð²ÐºÐ°\n- ÐÐ´Ð°Ð¿Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð´Ð¸Ð·Ð°Ð¹Ð½\n\n**5. server/test/api.test.ts**\n- CRUD Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ñ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼Ð°Ð¼Ð¸\n- Ð¡ÐµÑ‚ÐµÐ²Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ API\n- Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ñ„Ð°Ð¹Ð»Ð¾Ð² (CSV/Excel)\n- Ð“ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð¾ÑˆÐ¸Ð±Ð¾Ðº\n\n## Ð¢ÐµÑ…Ð½Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ\n\n### ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\n- **Vitest** ÐºÐ°Ðº Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ‚ÐµÑÑ‚ runner\n- **jsdom** Ð´Ð»Ñ DOM Ñ‚ÐµÑÑ‚Ð¾Ð²\n- **@testing-library/react** Ð´Ð»Ñ React ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ð¾Ð²\n- **supertest** Ð´Ð»Ñ API Ñ‚ÐµÑÑ‚Ð¾Ð²\n- **ÐœÐ¾ÐºÐ¸**: Three.js, browser APIs, ResizeObserver\n\n### Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð°\n```\nvitest.config.ts          # ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ Ñ‚ÐµÑÑ‚Ð¾Ð²\nclient/src/test/setup.ts   # ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\nclient/src/test/           # Frontend Ñ‚ÐµÑÑ‚Ñ‹\nserver/test/               # Backend Ñ‚ÐµÑÑ‚Ñ‹\nTESTING.md                 # ÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½Ð°Ñ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ñ\n```\n\n## ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹ Ð·Ð°Ð¿ÑƒÑÐºÐ°\n\n```bash\n# Ð’ÑÐµ Ñ‚ÐµÑÑ‚Ñ‹\nnpx vitest\n\n# ÐžÐ´Ð¸Ð½ Ñ€Ð°Ð·\nnpx vitest run\n\n# Ð¢Ð¾Ð»ÑŒÐºÐ¾ frontend\nnpx vitest run client/src/test\n\n# Ð¢Ð¾Ð»ÑŒÐºÐ¾ backend  \nnpx vitest run server/test\n\n# Ð¡ Ð¾Ñ‚ÑÐ»ÐµÐ¶Ð¸Ð²Ð°Ð½Ð¸ÐµÐ¼\nnpx vitest --watch\n```\n\n## ÐŸÐ¾ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»Ð°\n\n### âœ… ÐŸÐ¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ Ð¿Ð¾ÐºÑ€Ñ‹Ñ‚Ð¾\n- Ð£Ñ‚Ð¸Ð»Ð¸Ñ‚Ð°Ñ€Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸\n- ÐÐ»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ñ‹ ÐºÐ¾Ð¼Ð¿Ð¾Ð½Ð¾Ð²ÐºÐ¸ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n- ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð°Ð½Ð½Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ\n- HTTP ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°\n- API endpoints\n- Ð’Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ñ Ñ„Ð°Ð¹Ð»Ð¾Ð²\n\n### ðŸŽ¯ ÐžÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ ÑÑ†ÐµÐ½Ð°Ñ€Ð¸Ð¸\n- Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° CSV/Excel Ñ„Ð°Ð¹Ð»Ð¾Ð²\n- ÐÐ³Ñ€ÐµÐ³Ð°Ñ†Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð· Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… Ñ„Ð°Ð¹Ð»Ð¾Ð²  \n- Real-time Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ\n- Ð’Ñ‹Ð±Ð¾Ñ€ Ð¸ Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÐ° trace\n- ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ñ€ÐµÐ¶Ð¸Ð¼Ð¾Ð² Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸\n- Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° ÑÐ°Ð¹Ð´Ð±Ð°Ñ€Ð°\n- Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼\n\n### âš ï¸ ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ\n- 3D Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³ (WebGL) Ð¼Ð¾ÐºÐ¸ Ð² Node.js\n- Ð¤Ð°Ð¹Ð»Ð¾Ð²Ð°Ñ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐ¸Ð¼ÑƒÐ»Ð¸Ñ€ÑƒÐµÑ‚ÑÑ\n- WebSocket ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ Ñ‡ÐµÑ€ÐµÐ· HTTP API\n\n## Ð¡Ð»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ ÑˆÐ°Ð³Ð¸\n\n1. **Ð˜ÑÐ¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ñ‹** Ð² Ñ‚ÐµÑÑ‚Ð°Ñ… Ð´Ð»Ñ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾Ð¹ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹\n2. **Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ type definitions** Ð´Ð»Ñ traceId Ð² Ñ‚Ð¸Ð¿Ð°Ñ…\n3. **ÐÐ°ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ CI/CD** Ð¸Ð½Ñ‚ÐµÐ³Ñ€Ð°Ñ†Ð¸ÑŽ\n4. **Ð Ð°ÑÑˆÐ¸Ñ€Ð¸Ñ‚ÑŒ Ð¿Ð¾ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ** 3D Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹\n5. **Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ e2e Ñ‚ÐµÑÑ‚Ñ‹** Ñ Playwright\n\n## ÐŸÐ¾Ð»ÑŒÐ·Ð°\n\nÐ¢ÐµÑÑ‚Ð¾Ð²Ñ‹Ð¹ Ð½Ð°Ð±Ð¾Ñ€ Ð¾Ð±ÐµÑÐ¿ÐµÑ‡Ð¸Ð²Ð°ÐµÑ‚:\n- âœ… ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÑƒ Ñ€ÐµÐ³Ñ€ÐµÑÑÐ¸Ð¹ Ð¿Ñ€Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÑÑ…\n- âœ… Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°Ñ†Ð¸ÑŽ Ð¾Ð¶Ð¸Ð´Ð°ÐµÐ¼Ð¾Ð³Ð¾ Ð¿Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ\n- âœ… Ð£Ð²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ Ð² ÑÑ‚Ð°Ð±Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸\n- âœ… Ð‘Ñ‹ÑÑ‚Ñ€ÑƒÑŽ Ð¾Ñ‚Ð»Ð°Ð´ÐºÑƒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼\n- âœ… Ð‘ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ñ‹Ð¹ Ñ€ÐµÑ„Ð°ÐºÑ‚Ð¾Ñ€Ð¸Ð½Ð³\n\nÐ’ÑÐµ Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð¿Ð¾ÐºÑ€Ñ‹Ñ‚Ñ‹ Ñ‚ÐµÑÑ‚Ð°Ð¼Ð¸, Ñ‡Ñ‚Ð¾ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð¸ Ð½Ð°Ð´ÐµÐ¶Ð½Ð¾ÑÑ‚ÑŒ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹.","size_bytes":4734},"debug-userdata.js":{"content":"// Simple test to debug userData issue\nconsole.log('=== Testing Three.js userData behavior ===');\n\n// Test 1: Basic userData assignment\nconsole.log('\\n--- Test 1: Basic userData assignment ---');\nconst testObject = { userData: {} };\ntestObject.userData.nodeId = 'test-node-123';\ntestObject.userData.isEndpoint = true;\nconsole.log('After assignment:', {\n  nodeId: testObject.userData?.nodeId,\n  isEndpoint: testObject.userData?.isEndpoint,\n  keys: Object.keys(testObject.userData)\n});\n\n// Test 2: Map storage behavior\nconsole.log('\\n--- Test 2: Map storage behavior ---');\nconst testMap = new Map();\ntestMap.set('test-key', testObject);\nconst retrieved = testMap.get('test-key');\nconsole.log('After Map storage/retrieval:', {\n  nodeId: retrieved.userData?.nodeId,\n  isEndpoint: retrieved.userData?.isEndpoint,\n  keys: Object.keys(retrieved.userData)\n});\n\n// Test 3: Object mutation after storage\nconsole.log('\\n--- Test 3: Object mutation after storage ---');\nretrieved.userData = {};\nconsole.log('After clearing userData:', {\n  nodeId: retrieved.userData?.nodeId,\n  isEndpoint: retrieved.userData?.isEndpoint,\n  keys: Object.keys(retrieved.userData)\n});\n\n// Test 4: Re-assignment\nconsole.log('\\n--- Test 4: Re-assignment ---');\nretrieved.userData = {\n  nodeId: 'new-node-456',\n  isEndpoint: false,\n  test: 'value'\n};\nconsole.log('After re-assignment:', {\n  nodeId: retrieved.userData?.nodeId,\n  isEndpoint: retrieved.userData?.isEndpoint,\n  keys: Object.keys(retrieved.userData)\n});\n\nconsole.log('\\n=== Test completed ===');","size_bytes":1524},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","size_bytes":325},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","size_bytes":80},"replit.md":{"content":"# Diagram Generator Application\n\n## Overview\n\nThis is a full-stack web application for visualizing network diagrams from uploaded data files. Users can upload multiple CSV or Excel files containing source-target relationships, and the application will generate interactive graph visualizations with connection-strength-based line thickness, multiple layout algorithms, and customization options. The system aggregates data from multiple files to show comprehensive relationship networks with visual indicators of connection frequency.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: React 18 with TypeScript\n- **Routing**: Wouter for client-side routing\n- **State Management**: TanStack Query for server state, React hooks for local state\n- **Styling**: Tailwind CSS with shadcn/ui component library\n- **Build Tool**: Vite for development and production builds\n- **Visualization**: D3.js for graph rendering and layout algorithms\n\n### Backend Architecture\n- **Runtime**: Node.js with Express.js\n- **Language**: TypeScript with ESM modules\n- **File Processing**: Multer for file uploads, xlsx and csv-parse for data parsing\n- **Database**: PostgreSQL with Drizzle ORM (configured but using in-memory storage currently)\n- **Development**: Hot module replacement via Vite integration\n\n### Data Storage\n- **Primary**: PostgreSQL with Drizzle ORM for production\n- **Development**: In-memory storage (MemStorage class) as fallback\n- **Session**: Connect-pg-simple for PostgreSQL session storage\n- **Schema**: \n  - Diagrams table with JSONB for flexible data storage\n  - NetworkEvents table for real-time event stream storage\n- **Real-time**: Network event generator for simulating live traffic data\n\n## Key Components\n\n### Data Processing Pipeline\n**Active Components:**\n1. **Real-time Generation**: Network Events and OpenTelemetry trace generation with configurable intervals\n2. **Database Storage**: PostgreSQL persistence for traces, spans, and network events with full ACID compliance\n3. **Data Aggregation**: Real-time aggregation of service interactions and connection frequencies\n4. **Statistics Calculation**: Live computation of success rates, error percentages, and performance metrics\n\n**Inactive Components (Code Present):**\n- Multi-file CSV/Excel upload with drag-and-drop interface\n- File validation and parsing capabilities\n- Static data aggregation and visualization\n\n### Visualization Engine\n- **Layout Algorithms**: Force-directed, hierarchical, circular, and grid layouts\n- **Interactive Features**: Zoom, pan, node dragging, and real-time layout updates\n- **Connection Strength Visualization**: Line thickness scales from 1px to 5px based on connection frequency\n- **Curved Arrow System**: Multiple relationships between nodes display as symmetric curved arrows\n- **Hover Tooltips**: Display connection count when hovering over thick lines\n- **Customization**: Node colors, spacing, label visibility, arrow display\n- **Export**: SVG and PNG export capabilities\n\n### User Interface\n- **Sidebar**: File upload, layout controls, appearance settings, and statistics\n- **Canvas**: Interactive SVG-based diagram rendering\n- **Help System**: Contextual help panel with usage instructions\n- **Responsive**: Mobile-friendly design with touch support\n\n## Data Flow\n\n**Current Active Data Sources:**\n1. **Network Events Generator**: Real-time simulated network traffic â†’ PostgreSQL storage â†’ 3D visualization\n2. **OpenTelemetry Generator**: Distributed tracing data â†’ PostgreSQL storage â†’ Service interaction visualization  \n3. **File Upload (Inactive)**: CSV/Excel upload functionality exists but disabled in current UI\n\n**Active Data Flow:**\n1. **Data Generation**: User starts Network/OpenTelemetry generator â†’ Real-time data streams to PostgreSQL\n2. **Data Processing**: Backend aggregates traces/events â†’ Calculates statistics and relationships\n3. **Visualization**: Frontend queries database â†’ Renders 3D network topology with animated connections\n4. **Interaction**: User filters by trace ID â†’ Highlights related elements â†’ Adjusts time ranges\n5. **Persistence**: All generated data persists in PostgreSQL across sessions\n\n## External Dependencies\n\n### Core Libraries\n- **React Ecosystem**: react, react-dom, @tanstack/react-query\n- **UI Components**: @radix-ui/* components, shadcn/ui\n- **Visualization**: d3, @types/d3\n- **File Processing**: multer, xlsx, csv-parse\n- **Database**: drizzle-orm, @neondatabase/serverless\n- **Validation**: zod, @hookform/resolvers\n\n### Development Tools\n- **Build**: vite, esbuild, tsx\n- **Styling**: tailwindcss, autoprefixer, postcss\n- **TypeScript**: Full type coverage with strict configuration\n- **Replit Integration**: Custom plugins for development environment\n\n## Deployment Strategy\n\n### Development\n- **Command**: `npm run dev` - Runs both frontend and backend with HMR\n- **Port**: 5000 (configurable via Replit environment)\n- **Database**: In-memory storage for rapid development\n\n### Production\n- **Build**: `npm run build` - Compiles both frontend (Vite) and backend (esbuild)\n- **Start**: `npm run start` - Serves optimized bundles\n- **Database**: PostgreSQL via environment variable DATABASE_URL\n- **Deployment**: Replit autoscale with build/run configuration\n\n### Environment Configuration\n- **NODE_ENV**: Controls development vs production behavior\n- **DATABASE_URL**: PostgreSQL connection string\n- **Replit Detection**: Special handling for Replit environment features\n\n## Kubernetes Deployment\n\n### Architecture\n- **Container Platform**: Docker with multi-stage builds for optimal image size\n- **Orchestration**: Kubernetes with Kustomize for configuration management\n- **Base Configuration**: Namespace, ConfigMaps, Secrets, Deployments, Services\n- **Local Overlay**: Resource optimizations and NodePort service for development\n\n### Components\n- **Application Pod**: Node.js app with health checks and resource limits\n- **PostgreSQL Pod**: Persistent database with volume claims\n- **Service Discovery**: Internal cluster networking and external access via NodePort\n- **Configuration Management**: Environment variables via ConfigMaps and Secrets\n\n### Deployment Options\n- **Quick Deploy**: `make quick-deploy` - Complete build and deployment pipeline\n- **Manual Steps**: Build image â†’ Deploy to cluster â†’ Access via port forwarding\n- **Development**: NodePort access on localhost:30080\n- **Production Ready**: Includes health checks, resource limits, and persistence\n\n## Changelog\n\n```\nChangelog:\n- June 17, 2025. Initial setup\n- June 22, 2025. Enhanced circular dependency visualization with overlapping red arrows\n- June 22, 2025. Implemented curved arrows for multiple relationships with symmetric distribution around center axis\n- June 22, 2025. Added intersection validation and mirroring to prevent arrow overlaps\n- June 22, 2025. Fixed drag functionality to maintain curve separation during node movement\n- June 22, 2025. Standardized all arrows to black solid styling per user preference\n- June 22, 2025. Implemented multi-file upload and aggregation system with connection strength visualization\n- June 22, 2025. Added line thickness scaling (1-5px) based on connection frequency between node pairs\n- June 22, 2025. Added hover tooltips showing connection counts for thick lines\n- June 22, 2025. Implemented data persistence using localStorage for session recovery\n- June 22, 2025. Added automatic service detection with traffic type color coding (red/green/purple)\n- June 22, 2025. Enhanced node styling: green service nodes, blue endpoint nodes\n- June 22, 2025. Implemented 3D visualization using Three.js for complex network topologies with spatial clustering\n- June 22, 2025. Created segmented cylinder visualization where services appear as vertical cylinders with colored endpoint sections\n- June 22, 2025. Removed automatic service node generation to show only actual CSV data without artificial groupings\n- June 22, 2025. Implemented label-based cylinder segmentation: nodes with same service but different labels become colored segments within same cylinder\n- June 22, 2025. Added Clear All Data button to resolve data mixing issues when uploading multiple files sequentially\n- June 22, 2025. Fixed cylinder naming issue by adding service field to nodeSchema validation and arranging cylinders in single horizontal line\n- June 23, 2025. Implemented intelligent arrow directionality: two arrows only when bidirectional connections exist in source data, single arrow for unidirectional\n- June 23, 2025. Fixed 3D symmetry by implementing proper perpendicular vector calculation for true planar symmetry in 3D space\n- June 23, 2025. Enhanced arrow positioning to contact cylinder surfaces instead of centers, preventing arrows from being hidden inside cylinders\n- June 23, 2025. Increased arrow size 3x for better visibility and implemented true 3D symmetry relative to plane containing cylinder axes\n- June 23, 2025. Fixed 3D arrow symmetry by creating perpendicular offset in XZ plane for horizontal connections, ensuring proper visual separation\n- June 23, 2025. Resolved arrow merging issue by implementing vertical Y-axis offset for optimal camera visibility and clear separation of bidirectional arrows\n- June 23, 2025. Implemented correct XZ plane symmetry for X-axis aligned cylinders using Y-axis offset for true geometric symmetry\n- June 23, 2025. Added coordinate axes indicator in top-right corner with synchronized rotation for improved 3D navigation and orientation understanding\n- June 23, 2025. Reoriented 3D model: cylinders horizontal along X-axis with cylinder axes parallel to Z-axis for improved geometric clarity\n- June 23, 2025. Implemented interactive orientation cube in Autodesk Inventor style with clickable faces for standard view switching and smart cursor feedback\n- June 23, 2025. Fixed orientation cube positioning to display correctly in top-right corner with proper OpenGL/DOM coordinate conversion\n- June 23, 2025. Added coordinate axes vectors (XYZ) at origin (0,0,0) with color-coded arrows: red X-axis, green Y-axis, blue Z-axis\n- June 23, 2025. Aligned orientation cube faces with model coordinate axes: cube faces now display axis labels (+X/-X, +Y/-Y, +Z/-Z) with matching colors\n- June 23, 2025. Fixed cube synchronization: now rotates with model axes to accurately show current coordinate system orientation in real-time\n- January 01, 2025. Implemented real-time data processing foundation with PostgreSQL database integration\n- January 01, 2025. Created network event generator for simulating live traffic data similar to CSV structure\n- January 01, 2025. Added API endpoints for starting/stopping event generation and retrieving real-time data\n- January 01, 2025. Added status code statistics tooltips on arrow hover with improved cursor interaction\n- January 01, 2025. Implemented collapsible legend in 3D view with toggle button for better user experience\n- January 02, 2025. Fixed camera position preservation during real-time data updates - camera now maintains exact rotation, zoom and pan during automatic refresh cycles\n- January 02, 2025. Resolved DOM cleanup errors by eliminating duplicate renderer element removal in multiple useEffect hooks\n- January 02, 2025. Implemented frame-by-frame camera state persistence for seamless real-time visualization experience\n- January 03, 2025. Fixed arrow direction for obstacle-avoiding curves to properly align with cylinder surfaces\n- January 03, 2025. Improved arrow head orientation by blending curve approach direction with perpendicular surface direction\n- January 03, 2025. Enhanced line thickness scaling from 1-10 pixels based on relative connection frequency for better visual distinction\n- January 03, 2025. Implemented smart object caching system for real-time updates - existing arrows are reused instead of recreated\n- January 03, 2025. Added material caching to prevent WebGL shader limit issues during real-time visualization\n- January 03, 2025. Optimized incremental update performance - only new connections create new objects, existing ones are preserved\n- January 03, 2025. Fixed animation blocking issue by temporarily disabling incremental updates that interfered with render loop\n- January 03, 2025. Resolved lighting flicker problem by ensuring lights are created only once per scene instead of recreating on each update\n- January 03, 2025. Implemented automatic scene object restoration from cache when scene becomes empty during HMR updates\n- January 04, 2025. Fixed cylinder label positioning instability by implementing stable alphabetical service sorting\n- January 04, 2025. Enhanced time range debugging with detailed event span information to troubleshoot interval inconsistencies\n- January 06, 2025. Implemented interactive trace highlighting system with visual color-based feedback for network analysis\n- January 06, 2025. Added clickable trace ID list in sidebar with real-time element highlighting using color changes instead of opacity\n- January 06, 2025. Enhanced 3D visualization with intelligent trace filtering - related elements keep original colors, unrelated turn gray\n- January 06, 2025. Consolidated interface by combining legends and removing redundant controls from sidebar\n- January 06, 2025. Redesigned statistics to show HTTP status code analysis with success/error percentages\n- January 06, 2025. Added connection-specific filtering for detailed request analysis by client-server pairs\n- January 06, 2025. Streamlined sidebar to focus on core functionality: statistics, trace filtering, and essential controls\n- January 06, 2025. Made interface more compact by reducing spacing, element sizes, and text labels\n- January 06, 2025. Added resizable sidebar with drag-to-resize functionality (250px-600px range)\n- January 06, 2025. Fixed white gap between header and main content by adjusting layout height calculation\n- January 06, 2025. Extended trace highlighting to include service labels - now all elements (cylinders, arrows, labels) dim when not related to selected trace\n- January 06, 2025. Implemented OpenTelemetry standard trace format support alongside existing network events\n- January 06, 2025. Added proper traces and spans tables following OpenTelemetry specification (128-bit trace IDs, 64-bit span IDs)\n- January 06, 2025. Created realistic OpenTelemetry generator with parent-child span relationships, service calls, and standard attributes\n- January 06, 2025. Added comprehensive test suite with Vitest covering all application functionality and components\n- January 06, 2025. Unified data generation interface by consolidating RealTimeHeader and OpenTelemetryControls into single DataGeneratorControls component\n- January 06, 2025. Simplified user experience with format selection dropdown for switching between Network Events and OpenTelemetry data generation\n- January 06, 2025. Removed duplicate controls and streamlined data generation workflow with unified start/stop buttons and settings\n- January 06, 2025. Implemented complete OpenTelemetry trace ID support in sidebar with interactive trace highlighting and filtering\n- January 06, 2025. Added trace ID fields to edges in OpenTelemetry processor with support for multiple trace IDs per connection\n- January 06, 2025. Fixed API request parameter order issues and improved error handling in unified data generator\n- January 06, 2025. Added complete Kubernetes deployment configuration with Kustomize for local machine deployment\n- January 06, 2025. Created production-ready Dockerfile with multi-stage build and security optimizations\n- January 06, 2025. Implemented comprehensive Makefile with deployment automation and management commands\n- January 06, 2025. Enhanced 3D visualization with professional-grade visual effects: HDR lighting, shadow mapping, anti-aliasing, physically-based materials\n- January 06, 2025. Added animated data flow indicators with pulsing spheres moving along connection paths for real-time data visualization\n- January 06, 2025. Upgraded connection lines from basic lines to volumetric tubes with metallic materials for enterprise appearance\n- January 06, 2025. Implemented dark theme color optimization: bright cylinder colors, enhanced labels with borders, vivid status-based arrow colors\n- January 06, 2025. Enhanced lighting system with multiple directional and point lights for better visibility in dark theme environment\n- January 08, 2025. Completed dark theme implementation for sidebar, statistics cards, and trace list components\n- January 08, 2025. Analysis and documentation update: CSV upload functionality exists but disabled in current UI - application focuses on real-time data generation\n- January 08, 2025. Fixed critical auto-refresh mechanism - now stable after Hot Module Replacement (HMR) restarts during development\n- January 08, 2025. Implemented automatic refresh enablement when generators are active with proper cleanup and interval management\n- January 08, 2025. Resolved fundamental auto-refresh issue by replacing setInterval with setTimeout recursive pattern\n- January 08, 2025. Auto-refresh mechanism now works consistently every 5 seconds, surviving server restarts and HMR updates\n- January 08, 2025. Fixed interval creation problems in Replit environment - timeouts now properly scheduled and execute reliably\n- January 08, 2025. Removed endpoint type color rings as they didn't contribute to scalability goals\n- January 08, 2025. Implemented Level of Detail (LOD) system for adaptive scaling with 100+ services\n- January 08, 2025. Added LOD-based geometry optimization: low detail (8 segments), medium (16), high (32) for cylinder geometry\n- January 08, 2025. Implemented LOD-based label culling: endpoint labels hidden at low detail level to reduce visual clutter\n- January 08, 2025. Added LOD optimization for arrow geometry and flow indicators: reduced segments and disabled animations at low detail\n- January 08, 2025. LOD system automatically triggers based on service count (>50) or camera distance (>500) for optimal performance\n- January 08, 2025. Fixed lighting system falloff issue - replaced distance-limited point lights with directional lights for uniform illumination at any camera distance\n- January 08, 2025. Enhanced lighting system with extremely bright ambient light (4.0 intensity) and dynamic camera-following directional light to eliminate shadows at any zoom level\n- January 08, 2025. Fixed distant camera visibility issue - extended camera far plane to 10000, disabled fog, replaced lighting-dependent MeshStandardMaterial with MeshBasicMaterial for consistent visibility\n- January 08, 2025. Added brightness control slider (0.1x-3.0x range) with real-time tone mapping exposure adjustment\n- January 08, 2025. Created unified settings panel consolidating all controls: node spacing, brightness, show labels/arrows\n- January 08, 2025. Enhanced LOD system with more aggressive thresholds and visual feedback indicator showing current optimization level\n- January 08, 2025. Implemented relative distance calculation for LOD system - distance now calculated as ratio to diagram size instead of absolute camera position\n- January 08, 2025. Fixed LOD system to be adaptive to diagram size: small and large diagrams now have appropriate distance thresholds\n- January 08, 2025. Updated interface to display relative distance (e.g., \"2.5x\") instead of absolute pixels for better user understanding\n- January 08, 2025. Added real-time LOD updates in animation loop - now changes immediately when camera moves during zoom/pan operations\n- January 08, 2025. Optimized LOD thresholds: High (0-0.7x), Medium (0.7x-1.2x), Low (>1.2x) for smoother transitions and better user experience\n- January 08, 2025. Fixed LOD system thresholds based on actual user zoom range (0.1x-1.4x): HIGH (<50 services or <0.30x distance), MEDIUM (50-100 services or 0.30x-0.8x), LOW (>100 services or >0.8x distance)\n- January 08, 2025. âœ… TENANT/SYSTEM ARCHITECTURE COMPLETE: Implemented comprehensive tenant-based grouping system\n- January 08, 2025. Database schema migration successful - added tenant/system fields to traces, spans, networkEvents tables\n- January 08, 2025. Rewrote OpenTelemetry generator with realistic tenant structure: api-gateway, user-management, payment-system, inventory-system, notification-system\n- January 08, 2025. Updated Network Events generator to match tenant/system architecture with proper field mapping\n- January 08, 2025. Modified 3D visualization to group cylinders by tenant instead of service for improved scalability\n- January 08, 2025. Updated all event processors and type definitions to support tenant/system fields throughout frontend\n- January 08, 2025. Fixed computer icon click handlers and metrics popup to work with new tenant-based grouping structure\n- January 08, 2025. âœ… REALISTIC TRAFFIC GENERATOR COMPLETE: Created realisticOtelGenerator.ts with proper service hierarchy\n- January 08, 2025. Implemented realistic traffic flow: Gateway â†’ API Bus â†’ Business Services instead of random connections\n- January 08, 2025. Fixed database schema issues: changed spans.kind from integer to varchar for proper OpenTelemetry compliance\n- January 08, 2025. Added \"Realistic Gateway Flow\" option to UI with proper API endpoints and data generation control\n- January 08, 2025. Validated realistic data structure: api-gateway routes traffic to 8 business tenants with 20+ services total\n- January 08, 2025. âœ… TRACE HIGHLIGHTING OPTIMIZATION COMPLETE: Simplified object filtering approach using Set of valid endpoint IDs\n- January 08, 2025. Abandoned complex coordinate-based trace highlighting per user feedback in favor of direct nodeId-based matching\n- January 08, 2025. Resolved userData persistence by identifying problematic objects were system objects, not endpoint cylinders\n- January 08, 2025. Implemented efficient validation against known endpoint IDs using Set lookup, eliminating system object interference\n- January 08, 2025. Trace highlighting now processes only actual endpoints from data, improving performance and reliability\n- January 08, 2025. Fixed critical color preservation bug: cylinders without nodeId no longer get dimmed to gray when no trace is selected\n- January 08, 2025. Fixed cache restoration to preserve actual material colors instead of defaulting to white (0xFFFFFF)\n- January 10, 2025. âœ… TRACE HIGHLIGHTING FIXED: Resolved material cache interference preventing visual highlighting\n- January 10, 2025. Replaced shared cached materials with individual materials for highlighted/dimmed states to ensure proper visual changes\n- January 10, 2025. Enhanced highlighting: selected elements keep original colors with full opacity, unrelated elements become gray with 30% opacity\n- January 10, 2025. Fixed Three.js material caching bug where color changes affected all cylinders sharing the same cached material instance\n- January 10, 2025. âœ… DUAL SPACING CONTROLS IMPLEMENTED: Added separate Node Spacing and Cluster Spacing controls\n- January 10, 2025. Node Spacing (50-300): Controls distance between services within a tenant cluster\n- January 10, 2025. Cluster Spacing (200-1500): Controls distance between tenant cluster centers\n- January 10, 2025. Improved default spacing: Node Spacing default 120, Cluster Spacing default 600 for better visual separation\n- January 10, 2025. âœ… TRUNK OBSTACLE AVOIDANCE COMPLETE: Implemented pathfinding algorithm for trunk routes between tenant centers\n- January 10, 2025. Trunk system now uses real tenant cluster coordinates instead of linear positioning for accurate 3D routing\n- January 10, 2025. Added obstacle detection using tenant positions with appropriate clearance margins for trunk pathfinding\n- January 10, 2025. âœ… TENANT BOUNDARY SPHERES IMPLEMENTED: Added semi-transparent spheres around each tenant cluster\n- January 10, 2025. Spheres provide visual separation with 0.05 opacity during normal viewing for subtle tenant boundaries\n- January 10, 2025. Integrated with LOD system: at maximum zoom-out (LOD=low), spheres become opaque and hide internal details\n- January 10, 2025. Obstacle avoidance system now uses actual tenant sphere radii for more accurate trunk routing calculations\n- January 10, 2025. LOD system optimized for scalability: cylinders, labels, and arrows hidden at low detail level, showing only tenant spheres\n- January 10, 2025. âœ… TENANT SPHERE RENDERING FIXED: Resolved wireframe and opacity issues\n- January 10, 2025. Fixed sphere rendering to use solid fill instead of wireframe mode at all LOD levels\n- January 10, 2025. Corrected sphere opacity: 0.05 for normal viewing, 0.3 for LOD=low visibility\n- January 10, 2025. Added dynamic LOD-based visibility switching for all scene objects (cylinders, arrows, labels)\n- January 10, 2025. âœ… TRUNK OBSTACLE AVOIDANCE ENHANCED: Improved pathfinding algorithm with better clearance\n- January 10, 2025. Increased safety margins from 20 to 80 units for trunk routes around tenant spheres\n- January 10, 2025. Enhanced detour path calculation with 150-unit base offset and improved obstacle detection\n- January 10, 2025. Fixed sphere radius calculation for obstacle avoidance to match actual sphere sizes\n- January 10, 2025. Added comprehensive logging for trunk pathfinding debugging and validation\n- January 10, 2025. âœ… ADAPTIVE LOD SYSTEM COMPLETE: Fixed LOD thresholds to work with any diagram size and spacing settings\n- January 10, 2025. Implemented fully adaptive camera distance limits based purely on scheme diagonal (15%-120% with no absolute minimums)\n- January 10, 2025. Fixed LOD calculation to use normalized distance within practical zoom range instead of fixed thresholds\n- January 10, 2025. Updated onWheel handler to use adaptive camera limits that scale with spacing changes\n- January 10, 2025. LOD system now fully responsive: HIGH (<30% zoom), MEDIUM (30%-50%), LOW (>50%) of available zoom range\n- January 10, 2025. âœ… CAMERA DISTANCE OPTIMIZATION COMPLETE: Removed absolute limits, using only percentage-based calculations from real scheme diagonal  \n- January 10, 2025. Camera limits now fully adaptive: 15% minimum, 35% maximum of current scheme diagonal for optimal viewing at all scales\n- January 10, 2025. Maximum relative distance limited to ~0.2x for comfortable scheme overview without losing details\n- January 10, 2025. Diagonal calculation includes real-time updates based on tenant count, spacing settings, ensuring proper scale adaptation\n- January 10, 2025. âœ… TRACE OPTIMIZATION COMPLETE: Eliminated ALL hardcoded distances in obstacle avoidance functions\n- January 10, 2025. Replaced fixed cylinderRadius (25), offsetDistance (80), and separation offsets (+/-30) with adaptive calculations based on sphere radius\n- January 10, 2025. All trace routing now uses percentage-based distances: cylinderRadius=12% of smallest sphere, offsetDistance=20% (10% of diameter), separation=15%\n- January 10, 2025. Obstacle avoidance functions now scale proportionally with diagram size and spacing settings for consistent visual appearance\n- January 10, 2025. âœ… FINAL TRACE OPTIMIZATION: Reduced obstacle avoidance margins from 10% to 5% for maximum proximity to sphere surfaces\n- January 10, 2025. âœ… TRUNK ARROWS COMPLETED: Added directional arrows on magistral lines between tenants positioned at 1/3 and 2/3 of line length\n- January 10, 2025. Enhanced trunk arrows with proper flow-aligned orientation using curve tangent vectors for accurate traffic direction indication\n- January 10, 2025. âœ… MAGISTRAL ARCHITECTURE COMPLETELY FIXED: Resolved critical directional trunk routing system\n- January 10, 2025. Fixed magistral creation logic to properly handle all directed tenant pairs instead of creating only single magistral\n- January 10, 2025. Verified api-gateway now creates all 9 expected outgoing magistrals to different tenants (analytics-platform, content-management, infrastructure-ops, inventory-system, notification-system, order-processing, payment-system, security-monitoring, user-management)\n- January 10, 2025. Each magistral properly shows connection count-based thickness (5-15 connections â†’ thickness 5-10) and 2 directional arrows\n- January 10, 2025. Added comprehensive debugging logs for magistral creation process with trunk key validation and existence checking\n- January 10, 2025. âœ… ARROW DIRECTION COMPLETELY FIXED: Corrected trunk arrow orientation to show true traffic flow direction\n- January 10, 2025. Fixed trunk arrows to point from source tenant to target tenant instead of following curve tangent direction\n- January 10, 2025. Arrow direction now calculated using overall direction vector (targetCenter - sourceCenter) for accurate flow visualization\n- January 10, 2025. System now ready for 100+ service scalability with proper inter-tenant traffic visualization, obstacle avoidance routing, and correct directional indicators\n- January 10, 2025. âœ… UNIFORM HIGHWAY THICKNESS: Implemented uniform lane width (4 units) for all highways regardless of traffic volume to reduce visual confusion and improve clarity\n- January 10, 2025. âœ… CLEAN HIGHWAY ZONES: Removed branch connections from highway areas - highways now show only trunk traffic between tenants, individual service connections appear only within tenant clusters\n- January 10, 2025. âœ… SIMPLIFIED HIGHWAY DESIGN: Removed white divider lines between lanes - color separation (blue/pink) is sufficient for distinguishing traffic directions\n- January 13, 2025. âœ… MAJOR CODE REFACTORING COMPLETED: Successfully modularized massive Diagram3D.tsx file (3,642 lines â†’ 3,012 lines)\n- January 13, 2025. âœ… MODULAR ARCHITECTURE IMPLEMENTED: Split utilities into 4 modules - magistral.ts (114 lines), pathfinding.ts (159 lines), scene-utils.ts (127 lines), types.ts (32 lines)\n- January 13, 2025. âœ… CODE ORGANIZATION IMPROVED: Eliminated function duplications, enhanced maintainability, preserved full functionality with clear module separation\n- January 13, 2025. âœ… MAGISTRAL SEPARATION COMPLETE: Fixed bidirectional magistral display to show two parallel lines with perpendicular 25-unit offset\n- January 13, 2025. âœ… UNIFORM MAGISTRAL THICKNESS: Standardized all magistrals to fixed 10-unit thickness regardless of connection count for visual clarity\n- January 14, 2025. âœ… MAGISTRAL VISIBILITY OPTIMIZATION: Implemented segmented approach where magistrals are hidden only in 10% radius from tenant sphere centers\n- January 14, 2025. âœ… BRANCH CONNECTIONS FOR ALL TENANTS: Fixed branch creation system to work for all tenants, not just api-gateway - added both incoming and outgoing branch connections\n- January 14, 2025. âœ… SMART LOD SYSTEM: Enhanced Level of Detail calculation to use distance to nearest visible object instead of diagram center for better 3D navigation\n- January 14, 2025. âœ… MAGISTRAL TRACE HIGHLIGHTING: Added magistral lines and arrows to trace highlighting system - magistrals highlight only when selected trace actually crosses between their tenant pairs\n- January 14, 2025. âœ… TENANT SPHERE TRACE HIGHLIGHTING COMPLETE: Implemented comprehensive trace highlighting for tenant spheres in LOD low mode\n- January 14, 2025. Fixed scene clearing system to preserve tenant spheres during scene reconstruction and data updates\n- January 14, 2025. Enhanced tenant sphere highlighting with high contrast: highlighted spheres (0.8 opacity) vs dimmed spheres (0.1 opacity)\n- January 14, 2025. Added real-time LOD level updates for tenant sphere userData to ensure proper highlighting system integration\n- January 14, 2025. Completed trace highlighting system covering all 3D elements: cylinders, arrows, magistrals, labels, and tenant spheres\n- January 14, 2025. âœ… PERFORMANCE OPTIMIZATION: Identified cluster spacing changes causing system hangs due to full scene rebuilds under high server load\n- January 14, 2025. Temporarily disabled spacing-only rebuilds to prevent application freezing - spacing changes now skip rebuild until next data refresh\n- January 14, 2025. Added performance monitoring for API response times (250-350ms observed) indicating potential server load issues during complex 3D operations\n- January 14, 2025. âš ï¸ SPACING UPDATES DISABLED: Attempted complex position recalculation logic but caused worse performance issues\n- January 14, 2025. Current workaround: Users must stop/restart data generation to apply spacing changes\n- January 14, 2025. Root cause: Recent code additions for incremental updates created performance regression vs working version from January 13\n- January 14, 2025. âœ… SPACING CHANGES COMPLETELY FIXED: Reverted to simple full rebuild approach for spacing changes\n- January 14, 2025. Removed all complex incremental update logic that was causing performance issues and incorrect rebuilds\n- January 14, 2025. Implemented proper cache clearing and Three.js resource disposal for clean spacing updates\n- January 14, 2025. Lesson learned: Simple full rebuild often more reliable than complex incremental optimizations\n- January 14, 2025. âœ… MAGISTRAL DUPLICATION BUG FIXED: Resolved issue where reverse magistrals were created twice\n- January 14, 2025. Added processedMagistrals tracking to prevent duplicate creation of bidirectional magistrals\n- January 14, 2025. Fixed visual clutter between tenant pairs - now shows clean bidirectional highways with proper separation\n- January 14, 2025. âœ… CLUSTER SPACING Y FULLY FIXED: Added clusterSpacingY to spacing change detection logic\n- January 14, 2025. Cluster Spacing Y parameter now properly triggers cache clearing and scene rebuilding like other spacing controls\n- January 14, 2025. All three spacing controls (nodeSpacing, clusterSpacing, clusterSpacingY) now work consistently with immediate cache clearing\n- January 14, 2025. âœ… BRANCH CONNECTIONS ENDPOINT POSITIONING FIXED: Corrected magistral endpoint calculation to connect at sphere surface points\n- January 14, 2025. Branch connections now connect to points where magistrals touch tenant spheres instead of magistral centers for accurate network topology\n- January 14, 2025. Fixed cylinder lookup prefix from 'cylinder-' to 'endpoint-' enabling branch connections for all tenants with visible endpoints\n- January 14, 2025. Enhanced logging system shows sphere centers vs magistral endpoints coordinates for debugging branch connection positioning\n- January 14, 2025. âœ… OUTGOING BRANCH CONNECTIONS COMPLETELY FIXED: Resolved endpoint selection algorithm for green (outgoing) connections\n- January 14, 2025. Fixed vector mutation issue in magistral endpoint calculation by properly cloning direction vectors\n- January 14, 2025. Implemented accurate distance-based selection: outgoing connections now connect to closest magistral endpoint relative to tenant's service endpoints\n- January 14, 2025. Verified connection logic: purple (incoming) and green (outgoing) connections both use same closest-endpoint algorithm for optimal positioning\n- January 15, 2025. âœ… CONNECTION COLOR SCHEME UNIFIED: Standardized color logic across all connection types for clear traffic flow visualization\n- January 15, 2025. Updated branch connections: incoming (response) = purple (0x8B5CF6), outgoing (request) = green (0x10B981)\n- January 15, 2025. Fixed magistral color consistency: isReverse=false (request) = green, isReverse=true (response) = purple\n- January 15, 2025. Ensured arrow colors match their respective connection lines for unified visual traffic direction indication\n- January 15, 2025. âœ… BRANCH CONNECTIONS FULLY WORKING: Fixed logging system and verified branch connections create correctly from magistral endpoints to service endpoints\n- January 15, 2025. Confirmed magistral endpoints calculate at sphere surface points and branch connections route to actual endpoint cylinders inside tenant spheres\n- January 15, 2025. Enhanced debugging with comprehensive coordinate logging for magistral endpoint positions and branch connection creation process\n- January 15, 2025. Verified branch connection color coding: purple for incoming traffic (magistral â†’ endpoints), green for outgoing traffic (endpoints â†’ magistral)\n```\n\n## User Preferences\n\n```\nPreferred communication style: Simple, everyday language.\n```","size_bytes":36247},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \"var(--radius)\",\n        md: \"calc(var(--radius) - 2px)\",\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      colors: {\n        background: \"var(--background)\",\n        foreground: \"var(--foreground)\",\n        card: {\n          DEFAULT: \"var(--card)\",\n          foreground: \"var(--card-foreground)\",\n        },\n        popover: {\n          DEFAULT: \"var(--popover)\",\n          foreground: \"var(--popover-foreground)\",\n        },\n        primary: {\n          DEFAULT: \"var(--primary)\",\n          foreground: \"var(--primary-foreground)\",\n        },\n        secondary: {\n          DEFAULT: \"var(--secondary)\",\n          foreground: \"var(--secondary-foreground)\",\n        },\n        muted: {\n          DEFAULT: \"var(--muted)\",\n          foreground: \"var(--muted-foreground)\",\n        },\n        accent: {\n          DEFAULT: \"var(--accent)\",\n          foreground: \"var(--accent-foreground)\",\n        },\n        destructive: {\n          DEFAULT: \"var(--destructive)\",\n          foreground: \"var(--destructive-foreground)\",\n        },\n        border: \"var(--border)\",\n        input: \"var(--input)\",\n        ring: \"var(--ring)\",\n        chart: {\n          \"1\": \"var(--chart-1)\",\n          \"2\": \"var(--chart-2)\",\n          \"3\": \"var(--chart-3)\",\n          \"4\": \"var(--chart-4)\",\n          \"5\": \"var(--chart-5)\",\n        },\n        sidebar: {\n          DEFAULT: \"var(--sidebar-background)\",\n          foreground: \"var(--sidebar-foreground)\",\n          primary: \"var(--sidebar-primary)\",\n          \"primary-foreground\": \"var(--sidebar-primary-foreground)\",\n          accent: \"var(--sidebar-accent)\",\n          \"accent-foreground\": \"var(--sidebar-accent-foreground)\",\n          border: \"var(--sidebar-border)\",\n          ring: \"var(--sidebar-ring)\",\n        },\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: {\n            height: \"0\",\n          },\n          to: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n        },\n        \"accordion-up\": {\n          from: {\n            height: \"var(--radix-accordion-content-height)\",\n          },\n          to: {\n            height: \"0\",\n          },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","size_bytes":2627},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\"),\n    },\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  server: {\n    fs: {\n      strict: true,\n      deny: [\"**/.*\"],\n    },\n  },\n});\n","size_bytes":971},"vitest.config.ts":{"content":"import { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\nimport path from 'path';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    globals: true,\n    environment: 'jsdom',\n    setupFiles: ['./client/src/test/setup.ts'],\n  },\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, './client/src'),\n      '@shared': path.resolve(__dirname, './shared'),\n      '@assets': path.resolve(__dirname, './attached_assets'),\n    },\n  },\n});","size_bytes":484},"k8s/README.md":{"content":"# Kubernetes Deployment for Diagram Generator\n\nÐŸÐ¾Ð»Ð½Ð¾Ðµ Ñ€Ð°Ð·Ð²ÐµÑ€Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð² Kubernetes Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Kustomize.\n\n## Ð¢Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ\n\n- Kubernetes ÐºÐ»Ð°ÑÑ‚ÐµÑ€ (minikube, k3s, Ð¸Ð»Ð¸ docker-desktop)\n- kubectl\n- kustomize (Ð²Ñ…Ð¾Ð´Ð¸Ñ‚ Ð² kubectl)\n- Docker Ð´Ð»Ñ ÑÐ±Ð¾Ñ€ÐºÐ¸ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð²\n\n## Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ ÑÑ‚Ð°Ñ€Ñ‚\n\n### 1. Ð¡Ð±Ð¾Ñ€ÐºÐ° Ð¾Ð±Ñ€Ð°Ð·Ð°\n\n```bash\n# Ð¡Ð±Ð¾Ñ€ÐºÐ° Docker Ð¾Ð±Ñ€Ð°Ð·Ð°\ndocker build -t diagram-generator:latest .\n\n# Ð”Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ñ€ÐµÐµÑÑ‚Ñ€Ð° (ÐµÑÐ»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ÑÑ)\ndocker tag diagram-generator:latest localhost:5000/diagram-generator:latest\ndocker push localhost:5000/diagram-generator:latest\n```\n\n### 2. Ð Ð°Ð·Ð²ÐµÑ€Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ðµ\n\n```bash\n# ÐŸÑ€Ð¸Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸ÑŽ Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\nkubectl apply -k k8s/overlays/local\n\n# ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ ÑÑ‚Ð°Ñ‚ÑƒÑ\nkubectl get pods -n diagram-generator\n\n# ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ ÑÐµÑ€Ð²Ð¸ÑÑ‹\nkubectl get svc -n diagram-generator\n```\n\n### 3. Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑŽ\n\nÐŸÐ¾ÑÐ»Ðµ Ñ€Ð°Ð·Ð²ÐµÑ€Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð¾ Ð¿Ð¾:\n\n- **NodePort**: `http://localhost:30080` (Ð¸Ð»Ð¸ IP Ð²Ð°ÑˆÐµÐ³Ð¾ ÐºÐ»Ð°ÑÑ‚ÐµÑ€Ð°)\n- **Port Forward**: \n  ```bash\n  kubectl port-forward -n diagram-generator svc/local-diagram-generator-service 8080:80\n  ```\n  Ð—Ð°Ñ‚ÐµÐ¼: `http://localhost:8080`\n\n## Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ñ„Ð°Ð¹Ð»Ð¾Ð²\n\n```\nk8s/\nâ”œâ”€â”€ base/                          # Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ\nâ”‚   â”œâ”€â”€ namespace.yaml            # Namespace\nâ”‚   â”œâ”€â”€ configmap.yaml           # ÐŸÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ\nâ”‚   â”œâ”€â”€ secret.yaml              # Ð¡ÐµÐºÑ€ÐµÑ‚Ñ‹ (Ð¿Ð°Ñ€Ð¾Ð»Ð¸ Ð‘Ð”)\nâ”‚   â”œâ”€â”€ postgres-deployment.yaml # PostgreSQL Ð±Ð°Ð·Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…\nâ”‚   â”œâ”€â”€ app-deployment.yaml      # ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ\nâ”‚   â””â”€â”€ kustomization.yaml       # Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ kustomization\nâ””â”€â”€ overlays/\n    â””â”€â”€ local/                   # Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ðµ\n        â”œâ”€â”€ kustomization.yaml   # Ð›Ð¾ÐºÐ°Ð»ÑŒÐ½Ð°Ñ kustomization\n        â”œâ”€â”€ app-patch.yaml       # ÐŸÐ°Ñ‚Ñ‡Ð¸ Ð´Ð»Ñ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\n        â””â”€â”€ postgres-patch.yaml  # ÐŸÐ°Ñ‚Ñ‡Ð¸ Ð´Ð»Ñ PostgreSQL\n```\n\n## ÐšÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹\n\n### ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ\n- **Replicas**: 1 (Ð´Ð»Ñ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ)\n- **Resources**: 256Mi RAM, 100m CPU\n- **Port**: 5000 (Ð²Ð½ÑƒÑ‚Ñ€Ð¸ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð°)\n- **Health checks**: Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹\n\n### PostgreSQL\n- **Version**: 15-alpine\n- **Storage**: 500Mi PVC (local-path)\n- **Resources**: 128Mi RAM, 100m CPU\n- **Persistence**: Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½Ð°\n\n### Ð¡ÐµÑ‚ÑŒ\n- **Service Type**: NodePort (Ð¿Ð¾Ñ€Ñ‚ 30080)\n- **Internal Port**: 80 â†’ 5000\n\n## Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ\n\n### ÐŸÑ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ð»Ð¾Ð³Ð¾Ð²\n```bash\n# Ð›Ð¾Ð³Ð¸ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\nkubectl logs -n diagram-generator -l app=diagram-generator-app -f\n\n# Ð›Ð¾Ð³Ð¸ PostgreSQL\nkubectl logs -n diagram-generator -l app=postgres -f\n```\n\n### ÐœÐ°ÑÑˆÑ‚Ð°Ð±Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ\n```bash\n# Ð£Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ñ‚ÑŒ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€ÐµÐ¿Ð»Ð¸Ðº Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ\nkubectl scale deployment local-diagram-generator-app -n diagram-generator --replicas=2\n```\n\n### ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ\n```bash\n# ÐŸÐµÑ€ÐµÑÐ±Ð¾Ñ€ÐºÐ° Ð¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¾Ð±Ñ€Ð°Ð·Ð°\ndocker build -t diagram-generator:v1.1 .\nkubectl set image deployment/local-diagram-generator-app -n diagram-generator app=diagram-generator:v1.1\n```\n\n### ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n```bash\n# ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ðº PostgreSQL\nkubectl exec -it -n diagram-generator deployment/local-postgres-deployment -- psql -U postgres -d diagram_generator\n```\n\n## Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ\n\n```bash\n# Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ñ€ÐµÑÑƒÑ€ÑÑ‹\nkubectl delete -k k8s/overlays/local\n\n# Ð˜Ð»Ð¸ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ namespace (ÑƒÐ´Ð°Ð»Ð¸Ñ‚ Ð²ÑÐµ Ð²Ð½ÑƒÑ‚Ñ€Ð¸)\nkubectl delete namespace diagram-generator\n```\n\n## ÐžÑ‚Ð»Ð°Ð´ÐºÐ°\n\n### ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ Ð¾Ð±Ñ€Ð°Ð·Ð¾Ð¼\n- Ð£Ð±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ð¾Ð±Ñ€Ð°Ð· ÑÐ¾Ð±Ñ€Ð°Ð½ Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð² ÐºÐ»Ð°ÑÑ‚ÐµÑ€Ðµ\n- Ð”Ð»Ñ minikube: `eval $(minikube docker-env)` Ð¿ÐµÑ€ÐµÐ´ ÑÐ±Ð¾Ñ€ÐºÐ¾Ð¹\n\n### ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ PVC: `kubectl get pvc -n diagram-generator`\n- ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð»Ð¾Ð³Ð¸ PostgreSQL Ð½Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð¸Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸\n\n### ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ ÑÐµÑ‚ÑŒÑŽ\n- ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ ÑÐµÑ€Ð²Ð¸ÑÑ‹: `kubectl get svc -n diagram-generator`\n- Ð”Ð»Ñ NodePort ÑƒÐ±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ, Ñ‡Ñ‚Ð¾ Ð¿Ð¾Ñ€Ñ‚ 30080 Ð´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½\n\n## ÐšÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ñ Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð´Ð°ÐºÑˆÐµÐ½Ð°\n\nÐ”Ð»Ñ Ð¿Ñ€Ð¾Ð´Ð°ÐºÑˆÐµÐ½Ð° ÑÐ¾Ð·Ð´Ð°Ð¹Ñ‚Ðµ Ð½Ð¾Ð²Ñ‹Ð¹ overlay Ð² `k8s/overlays/production` Ñ:\n\n- Ingress ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð¾Ð¼ Ð²Ð¼ÐµÑÑ‚Ð¾ NodePort\n- Ð£Ð²ÐµÐ»Ð¸Ñ‡ÐµÐ½Ð½Ñ‹Ð¼Ð¸ Ñ€ÐµÑÑƒÑ€ÑÐ°Ð¼Ð¸\n- Ð’Ð½ÐµÑˆÐ½ÐµÐ¹ Ð±Ð°Ð·Ð¾Ð¹ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n- SSL ÑÐµÑ€Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð°Ð¼Ð¸\n- ÐœÐ¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð¾Ð¼ Ð¸ Ð»Ð¾Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼","size_bytes":4980},"server/db.ts":{"content":"import { Pool, neonConfig } from '@neondatabase/serverless';\nimport { drizzle } from 'drizzle-orm/neon-serverless';\nimport ws from \"ws\";\nimport * as schema from \"@shared/schema\";\n\nneonConfig.webSocketConstructor = ws;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle({ client: pool, schema });","size_bytes":482},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { setupVite, serveStatic, log } from \"./vite\";\nimport { startServiceMetricsGeneration } from \"./serviceMetricsGenerator\";\n\nconst app = express();\napp.use(express.json());\napp.use(express.urlencoded({ extended: false }));\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      if (logLine.length > 80) {\n        logLine = logLine.slice(0, 79) + \"â€¦\";\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  const server = await registerRoutes(app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (app.get(\"env\") === \"development\") {\n    await setupVite(app, server);\n  } else {\n    serveStatic(app);\n  }\n\n  // ALWAYS serve the app on port 5000\n  // this serves both the API and the client.\n  // It is the only port that is not firewalled.\n  const port = 5000;\n  server.listen({\n    port,\n    host: \"0.0.0.0\",\n    reusePort: true,\n  }, () => {\n    log(`serving on port ${port}`);\n    \n    // Start service metrics generation automatically on startup\n    startServiceMetricsGeneration(30000); // Generate metrics every 30 seconds\n    log(\"Service metrics generation started\");\n  });\n})();\n","size_bytes":2192},"server/networkGenerator.ts":{"content":"import { db } from \"./db\";\nimport { networkEvents } from \"@shared/schema\";\nimport { sql, gt, and, gte, lte, desc, asc } from \"drizzle-orm\";\nimport type { InsertNetworkEvent } from \"@shared/schema\";\n\n// Tenant/System configuration matching OpenTelemetry generator\nconst TENANT_SYSTEMS = {\n  'api-gateway': [\n    { name: 'gateway-main', service: 'api-gateway' },\n    { name: 'gateway-auth', service: 'api-gateway' },\n    { name: 'gateway-proxy', service: 'api-gateway' }\n  ],\n  'user-management': [\n    { name: 'user-service', service: 'user-service' },\n    { name: 'profile-service', service: 'user-service' },\n    { name: 'auth-service', service: 'user-service' }\n  ],\n  'payment-system': [\n    { name: 'payment-core', service: 'payment-service' },\n    { name: 'payment-gateway', service: 'payment-service' },\n    { name: 'billing-service', service: 'payment-service' }\n  ],\n  'inventory-system': [\n    { name: 'inventory-core', service: 'inventory-service' },\n    { name: 'stock-tracker', service: 'inventory-service' },\n    { name: 'warehouse-mgmt', service: 'inventory-service' }\n  ],\n  'notification-system': [\n    { name: 'notification-core', service: 'notification-service' },\n    { name: 'email-service', service: 'notification-service' },\n    { name: 'sms-service', service: 'notification-service' }\n  ]\n};\n\n// Flatten for easy access\nconst ALL_SERVICES = Object.entries(TENANT_SYSTEMS).flatMap(([tenant, systems]) => \n  systems.map(system => ({ ...system, tenant }))\n);\n\nconst LABELS = [\n  'police-extend',\n  'auth',\n  'contact'\n];\n\nconst HTTP_STATUSES = ['200', '201', '400', '401', '403', '404', '500', '502', '503'];\nconst HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];\n\n// Trace ID management - increments every 5 events\nlet currentTraceId = 1;\nlet eventsInCurrentTrace = 0;\n\n// Generate realistic network events\nexport function generateNetworkEvent(): InsertNetworkEvent {\n  // Increment trace ID every 5 events\n  eventsInCurrentTrace++;\n  if (eventsInCurrentTrace > 5) {\n    currentTraceId++;\n    eventsInCurrentTrace = 1;\n  }\n  \n  const traceId = `trace-${currentTraceId.toString().padStart(6, '0')}`;\n  \n  const sourceService = ALL_SERVICES[Math.floor(Math.random() * ALL_SERVICES.length)];\n  const targetService = ALL_SERVICES[Math.floor(Math.random() * ALL_SERVICES.length)];\n  \n  const sourceLabel = LABELS[Math.floor(Math.random() * LABELS.length)];\n  const targetLabel = LABELS[Math.floor(Math.random() * LABELS.length)];\n  \n  const source = `${sourceService.name}_${sourceLabel}`;\n  const target = `${targetService.name}_${targetLabel}`;\n  \n  // Weight status codes to be more realistic (more 200s than errors)\n  const statusWeights = {\n    '200': 0.7,\n    '201': 0.1,\n    '400': 0.05,\n    '401': 0.03,\n    '403': 0.02,\n    '404': 0.03,\n    '500': 0.02,\n    '502': 0.03,\n    '503': 0.02\n  };\n  \n  const rand = Math.random();\n  let cumulative = 0;\n  let status = '200';\n  \n  for (const [code, weight] of Object.entries(statusWeights)) {\n    cumulative += weight;\n    if (rand <= cumulative) {\n      status = code;\n      break;\n    }\n  }\n  \n  return {\n    source,\n    target,\n    sourceService: sourceService.service,\n    targetService: targetService.service,\n    sourceTenant: sourceService.tenant,\n    targetTenant: targetService.tenant,\n    sourceSystem: sourceService.name,\n    targetSystem: targetService.name,\n    sourceLabel,\n    targetLabel,\n    status,\n    method: HTTP_METHODS[Math.floor(Math.random() * HTTP_METHODS.length)],\n    responseTime: Math.floor(Math.random() * 1000) + 10, // 10-1010ms\n    traceId,\n    metadata: {\n      userAgent: 'service-mesh/1.0',\n      region: 'us-east-1'\n    }\n  };\n}\n\n// Store network event in database\nexport async function storeNetworkEvent(event: InsertNetworkEvent) {\n  try {\n    const result = await db.insert(networkEvents).values(event).returning();\n    if (result.length > 0) {\n      console.log(`Stored event ID ${result[0].id} at ${new Date(result[0].timestamp).toISOString()}`);\n    }\n  } catch (error) {\n    console.error('Failed to store network event:', error);\n  }\n}\n\n// Start generating events at regular intervals\nexport function startNetworkGenerator(intervalMs: number = 2000) {\n  console.log(`Starting network event generator (interval: ${intervalMs}ms)`);\n  \n  const interval = setInterval(async () => {\n    const event = generateNetworkEvent();\n    await storeNetworkEvent(event);\n    console.log(`Generated event: ${event.source} -> ${event.target} (${event.status})`);\n  }, intervalMs);\n  \n  return () => {\n    clearInterval(interval);\n    console.log('Network event generator stopped');\n  };\n}\n\n// Get recent events from database\nexport async function getRecentEvents(limitCount: number = 100) {\n  try {\n    const events = await db\n      .select()\n      .from(networkEvents)\n      .orderBy(networkEvents.timestamp)\n      .limit(limitCount);\n    \n    return events;\n  } catch (error) {\n    console.error('Failed to fetch recent events:', error);\n    return [];\n  }\n}\n\n// Get events since a specific timestamp\nexport async function getEventsSince(timestamp: Date) {\n  try {\n    const events = await db\n      .select()\n      .from(networkEvents)\n      .where(gt(networkEvents.timestamp, timestamp))\n      .orderBy(networkEvents.timestamp);\n    \n    return events;\n  } catch (error) {\n    console.error('Failed to fetch events since timestamp:', error);\n    return [];\n  }\n}\n\n// Get events within a specific time range\nexport async function getEventsInRange(from: Date, to: Date, limit: number = 1000) {\n  try {\n    const events = await db\n      .select()\n      .from(networkEvents)\n      .where(\n        and(\n          gte(networkEvents.timestamp, from),\n          lte(networkEvents.timestamp, to)\n        )\n      )\n      .orderBy(desc(networkEvents.timestamp))\n      .limit(limit);\n    \n    return events;\n  } catch (error) {\n    console.error('Failed to fetch events in range:', error);\n    return [];\n  }\n}","size_bytes":5908},"server/opentelemetryGenerator.ts":{"content":"import { db } from \"./db\";\nimport { traces, spans, networkEvents } from \"@shared/schema\";\nimport { sql, gt, and, gte, lte, desc, asc } from \"drizzle-orm\";\nimport type { InsertTrace, InsertSpan, InsertNetworkEvent } from \"@shared/schema\";\nimport { nanoid } from \"nanoid\";\n\n// Expanded tenant/system configuration with 50 services across 10 tenants\nconst TENANT_SYSTEMS = {\n  'api-gateway': [\n    { name: 'gateway-main', version: '1.2.3' },\n    { name: 'gateway-auth', version: '1.2.1' },\n    { name: 'gateway-proxy', version: '1.2.0' },\n    { name: 'gateway-cache', version: '1.1.5' },\n    { name: 'gateway-metrics', version: '1.3.0' }\n  ],\n  'user-management': [\n    { name: 'user-service', version: '2.1.0' },\n    { name: 'profile-service', version: '2.0.8' },\n    { name: 'auth-service', version: '2.1.2' },\n    { name: 'session-mgr', version: '2.0.5' },\n    { name: 'identity-provider', version: '2.2.0' }\n  ],\n  'payment-system': [\n    { name: 'payment-core', version: '1.5.2' },\n    { name: 'payment-gateway', version: '1.5.0' },\n    { name: 'billing-service', version: '1.4.9' },\n    { name: 'fraud-detection', version: '1.6.1' },\n    { name: 'tax-calculator', version: '1.3.7' }\n  ],\n  'inventory-system': [\n    { name: 'inventory-core', version: '3.0.1' },\n    { name: 'stock-tracker', version: '2.9.5' },\n    { name: 'warehouse-mgmt', version: '3.0.0' },\n    { name: 'supplier-api', version: '2.8.3' },\n    { name: 'product-catalog', version: '3.1.2' }\n  ],\n  'notification-system': [\n    { name: 'notification-core', version: '1.8.0' },\n    { name: 'email-service', version: '1.7.5' },\n    { name: 'sms-service', version: '1.8.1' },\n    { name: 'push-service', version: '1.7.8' },\n    { name: 'template-engine', version: '1.9.2' }\n  ],\n  'analytics-platform': [\n    { name: 'data-collector', version: '2.5.0' },\n    { name: 'metrics-processor', version: '2.4.8' },\n    { name: 'report-generator', version: '2.6.1' },\n    { name: 'dashboard-api', version: '2.5.5' },\n    { name: 'ml-insights', version: '2.7.0' }\n  ],\n  'content-management': [\n    { name: 'content-api', version: '1.8.5' },\n    { name: 'media-storage', version: '1.9.0' },\n    { name: 'cdn-manager', version: '1.7.8' },\n    { name: 'content-search', version: '1.8.2' },\n    { name: 'asset-optimizer', version: '1.6.9' }\n  ],\n  'order-processing': [\n    { name: 'order-service', version: '3.2.1' },\n    { name: 'fulfillment-api', version: '3.1.8' },\n    { name: 'shipping-tracker', version: '3.2.5' },\n    { name: 'return-handler', version: '3.0.9' },\n    { name: 'order-analytics', version: '3.3.0' }\n  ],\n  'security-monitoring': [\n    { name: 'threat-detector', version: '1.4.2' },\n    { name: 'audit-logger', version: '1.5.1' },\n    { name: 'compliance-checker', version: '1.3.8' },\n    { name: 'access-monitor', version: '1.4.5' },\n    { name: 'incident-responder', version: '1.5.3' }\n  ],\n  'infrastructure-ops': [\n    { name: 'health-monitor', version: '2.1.0' },\n    { name: 'backup-service', version: '2.0.7' },\n    { name: 'deployment-mgr', version: '2.2.1' },\n    { name: 'config-service', version: '2.1.5' },\n    { name: 'log-aggregator', version: '2.3.0' }\n  ]\n};\n\n// Flatten for easy access\nconst ALL_SERVICES = Object.entries(TENANT_SYSTEMS).flatMap(([tenant, systems]) => \n  systems.map(system => ({ ...system, tenant }))\n);\n\nconst OPERATIONS = {\n  'api-gateway': ['route_request', 'authenticate', 'rate_limit', 'proxy_request', 'cache_lookup', 'metrics_collect'],\n  'user-management': ['get_user', 'create_user', 'update_profile', 'validate_session', 'verify_identity', 'manage_session'],\n  'payment-system': ['process_payment', 'validate_card', 'charge_customer', 'refund_payment', 'detect_fraud', 'calculate_tax'],\n  'inventory-system': ['check_stock', 'reserve_item', 'update_inventory', 'get_product', 'sync_suppliers', 'catalog_search'],\n  'notification-system': ['send_email', 'send_sms', 'push_notification', 'format_message', 'push_mobile', 'render_template'],\n  'analytics-platform': ['collect_events', 'process_metrics', 'generate_report', 'serve_dashboard', 'run_analysis', 'aggregate_data'],\n  'content-management': ['fetch_content', 'store_media', 'purge_cache', 'search_content', 'optimize_assets', 'manage_cdn'],\n  'order-processing': ['create_order', 'fulfill_order', 'track_shipment', 'process_return', 'analyze_orders', 'manage_fulfillment'],\n  'security-monitoring': ['detect_threats', 'log_audit', 'check_compliance', 'monitor_access', 'handle_incident', 'scan_vulnerabilities'],\n  'infrastructure-ops': ['check_health', 'create_backup', 'deploy_service', 'update_config', 'aggregate_logs', 'monitor_resources']\n};\n\nconst HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];\nconst HTTP_STATUSES = ['200', '201', '400', '401', '403', '404', '500', '502', '503'];\n\nconst SPAN_KINDS = {\n  UNSPECIFIED: 0,\n  INTERNAL: 1,\n  SERVER: 2,\n  CLIENT: 3,\n  PRODUCER: 4,\n  CONSUMER: 5\n};\n\n// Generate realistic OpenTelemetry trace ID (128-bit hex)\nfunction generateTraceId(): string {\n  return nanoid(32).toLowerCase().replace(/[^a-f0-9]/g, '0').slice(0, 32);\n}\n\n// Generate realistic OpenTelemetry span ID (64-bit hex)\nfunction generateSpanId(): string {\n  return nanoid(16).toLowerCase().replace(/[^a-f0-9]/g, '0').slice(0, 16);\n}\n\n// Generate realistic duration in nanoseconds\nfunction generateDuration(min: number = 1000000, max: number = 500000000): number {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n// Generate OpenTelemetry attributes\nfunction generateAttributes(service: string, operation: string, method?: string, status?: string): Record<string, any> {\n  const attrs: Record<string, any> = {\n    'service.name': service,\n    'operation.name': operation,\n    'span.kind': 'server'\n  };\n\n  if (method) {\n    attrs['http.method'] = method;\n    attrs['http.route'] = `/${operation}`;\n  }\n\n  if (status) {\n    attrs['http.status_code'] = parseInt(status);\n    attrs['http.response.status_code'] = parseInt(status);\n  }\n\n  return attrs;\n}\n\n// Generate OpenTelemetry events\nfunction generateEvents(): Array<any> {\n  const events = [];\n  \n  if (Math.random() < 0.3) { // 30% chance of having events\n    events.push({\n      name: 'request.start',\n      timestamp: new Date(Date.now() - Math.random() * 1000).toISOString(),\n      attributes: { 'event.type': 'request' }\n    });\n  }\n\n  if (Math.random() < 0.2) { // 20% chance of error event\n    events.push({\n      name: 'error.occurred',\n      timestamp: new Date(Date.now() - Math.random() * 500).toISOString(),\n      attributes: { \n        'error.type': 'HttpError',\n        'error.message': 'Request timeout'\n      }\n    });\n  }\n\n  return events;\n}\n\n// Generate a realistic OpenTelemetry trace: Gateway â†’ API Bus â†’ Business Services\nexport function generateOpenTelemetryTrace(): { trace: InsertTrace; spans: InsertSpan[]; networkEvents: InsertNetworkEvent[] } {\n  const traceId = generateTraceId();\n  const startTime = new Date(Date.now() - Math.random() * 10000);\n  \n  const spans: InsertSpan[] = [];\n  const networkEvents: InsertNetworkEvent[] = [];\n  \n  // Create realistic service chain: Gateway â†’ API Bus â†’ Target Services\n  const serviceChain: Array<{ service: typeof ALL_SERVICES[0]; operation: string }> = [];\n  \n  // 1. Always start with gateway (entry point)\n  const gatewayServices = ALL_SERVICES.filter(s => s.tenant === 'api-gateway');\n  const gateway = gatewayServices[Math.floor(Math.random() * gatewayServices.length)];\n  serviceChain.push({ \n    service: gateway, \n    operation: OPERATIONS['api-gateway'][Math.floor(Math.random() * OPERATIONS['api-gateway'].length)]\n  });\n  \n  // 2. Add API bus/proxy (80% chance)\n  if (Math.random() > 0.2) {\n    const proxyService = ALL_SERVICES.find(s => s.name === 'gateway-proxy') || gateway;\n    if (proxyService.name !== gateway.name) {\n      serviceChain.push({ \n        service: proxyService, \n        operation: 'proxy_request' \n      });\n    }\n  }\n  \n  // 3. Add 1-3 business services from different tenants (realistic flow)\n  const businessTenants = ['user-management', 'payment-system', 'inventory-system', 'notification-system', 'analytics-platform', 'content-management', 'order-processing', 'security-monitoring', 'infrastructure-ops'];\n  const selectedTenants = businessTenants.sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);\n  \n  selectedTenants.forEach(tenant => {\n    const tenantServices = ALL_SERVICES.filter(s => s.tenant === tenant);\n    const service = tenantServices[Math.floor(Math.random() * tenantServices.length)];\n    const operation = OPERATIONS[tenant][Math.floor(Math.random() * OPERATIONS[tenant].length)];\n    serviceChain.push({ service, operation });\n  });\n  \n  // Generate spans for the realistic service chain\n  let currentTime = startTime.getTime();\n  let parentSpanId: string | null = null;\n  const method = HTTP_METHODS[Math.floor(Math.random() * HTTP_METHODS.length)];\n  const overallStatus = HTTP_STATUSES[Math.floor(Math.random() * HTTP_STATUSES.length)];\n  \n  serviceChain.forEach((chainItem, index) => {\n    const spanId = generateSpanId();\n    const spanDuration = generateDuration(10000000, 100000000); // 10ms to 100ms\n    const spanEndTime = new Date(currentTime + spanDuration / 1000000);\n    \n    const span: InsertSpan = {\n      traceId,\n      spanId,\n      parentSpanId,\n      operationName: chainItem.operation,\n      serviceName: chainItem.service.name,\n      tenant: chainItem.service.tenant,\n      system: chainItem.service.name,\n      kind: index === 0 ? SPAN_KINDS.SERVER : SPAN_KINDS.CLIENT,\n      startTime: new Date(currentTime),\n      endTime: spanEndTime,\n      duration: spanDuration,\n      status: parseInt(overallStatus) >= 400 ? 'error' : 'ok',\n      statusMessage: parseInt(overallStatus) >= 400 ? `HTTP ${overallStatus}` : undefined,\n      attributes: generateAttributes(chainItem.service.name, chainItem.operation, method, overallStatus),\n      events: generateEvents(),\n      links: [],\n      resource: {\n        'service.name': chainItem.service.name,\n        'service.version': chainItem.service.version,\n        'service.instance.id': nanoid(8)\n      }\n    };\n    \n    spans.push(span);\n    \n    // Create network event for service-to-service communication\n    if (index > 0) {\n      const prevService = serviceChain[index - 1].service;\n      const networkEvent: InsertNetworkEvent = {\n        source: prevService.name,\n        target: chainItem.service.name,\n        sourceService: prevService.name,\n        targetService: chainItem.service.name,\n        sourceTenant: prevService.tenant,\n        targetTenant: chainItem.service.tenant,\n        sourceSystem: prevService.name,\n        targetSystem: chainItem.service.name,\n        sourceLabel: `${prevService.name}:${Math.floor(Math.random() * 9000) + 1000}`,\n        targetLabel: `${chainItem.service.name}:${Math.floor(Math.random() * 9000) + 1000}`,\n        status: overallStatus,\n        method,\n        responseTime: Math.floor(spanDuration / 1000000),\n        timestamp: new Date(currentTime),\n        traceId,\n        metadata: {\n          span_id: spanId,\n          parent_span_id: parentSpanId,\n          operation: chainItem.operation\n        }\n      };\n      \n      networkEvents.push(networkEvent);\n    }\n    \n    parentSpanId = spanId;\n    currentTime += spanDuration / 1000000 + Math.random() * 5; // Small gap between spans\n  });\n  \n  // Calculate trace metadata (using unique variable names)\n  const traceRootService = serviceChain[0].service;\n  const calculatedDuration = spans.reduce((total, span) => total + span.duration, 0);\n  const calculatedEndTime = new Date(Math.max(...spans.map(s => s.endTime.getTime())));\n  const hasErrors = spans.some(s => s.status === 'error');\n  \n  for (let i = 0; i < childSpanCount; i++) {\n    const childService = ALL_SERVICES[Math.floor(Math.random() * ALL_SERVICES.length)];\n    const childOperation = OPERATIONS[childService.tenant][Math.floor(Math.random() * OPERATIONS[childService.tenant].length)];\n    const childSpanId = generateSpanId();\n    const childDuration = generateDuration(1000000, 50000000);\n    const childStatus = HTTP_STATUSES[Math.floor(Math.random() * HTTP_STATUSES.length)];\n    \n    const childStartTime = new Date(currentTime + Math.random() * 1000);\n    const childEndTime = new Date(childStartTime.getTime() + childDuration / 1000000);\n    \n    const childSpan: InsertSpan = {\n      traceId,\n      spanId: childSpanId,\n      parentSpanId: rootSpanId,\n      operationName: childOperation,\n      serviceName: childService.name,\n      tenant: childService.tenant,\n      system: childService.name,\n      kind: Math.random() < 0.5 ? SPAN_KINDS.CLIENT : SPAN_KINDS.SERVER,\n      startTime: childStartTime,\n      endTime: childEndTime,\n      duration: childDuration,\n      status: parseInt(childStatus) >= 400 ? 'error' : 'ok',\n      statusMessage: parseInt(childStatus) >= 400 ? `HTTP ${childStatus}` : undefined,\n      attributes: generateAttributes(childService.name, childOperation, method, childStatus),\n      events: generateEvents(),\n      links: [],\n      resource: {\n        'service.name': childService.name,\n        'service.version': childService.version,\n        'service.instance.id': nanoid(8)\n      }\n    };\n    \n    spans.push(childSpan);\n    \n    // Create network event for service-to-service communication\n    if (childService.name !== rootService.name) {\n      const networkEvent: InsertNetworkEvent = {\n        source: `${rootService.name}_${rootOperation}`,\n        target: `${childService.name}_${childOperation}`,\n        sourceService: rootService.name,\n        targetService: childService.name,\n        sourceTenant: rootService.tenant,\n        targetTenant: childService.tenant,\n        sourceSystem: rootService.name,\n        targetSystem: childService.name,\n        sourceLabel: rootOperation,\n        targetLabel: childOperation,\n        status: childStatus,\n        method: method,\n        responseTime: Math.floor(childDuration / 1000000),\n        traceId: traceId,\n        spanId: childSpanId,\n        metadata: {\n          parentSpanId: rootSpanId,\n          spanKind: childSpan.kind,\n          attributes: childSpan.attributes\n        }\n      };\n      \n      networkEvents.push(networkEvent);\n    }\n    \n    currentTime = childEndTime.getTime();\n  }\n  \n  // Calculate total trace duration\n  const totalDuration = Math.max(...spans.map(s => s.duration || 0));\n  const traceEndTime = new Date(startTime.getTime() + totalDuration / 1000000);\n  \n  const trace: InsertTrace = {\n    traceId,\n    serviceName: rootService.name,\n    serviceVersion: rootService.version,\n    tenant: rootService.tenant,\n    system: rootService.name,\n    startTime,\n    endTime: calculatedEndTime,\n    duration: calculatedDuration,\n    spanCount: spans.length,\n    status: spans.some(s => s.status === 'error') ? 'error' : 'ok',\n    statusMessage: spans.some(s => s.status === 'error') ? 'Trace contains errors' : undefined,\n    attributes: {\n      'trace.span_count': spans.length,\n      'trace.service_count': new Set(spans.map(s => s.serviceName)).size,\n      'trace.root_service': rootService.name\n    },\n    resource: {\n      'service.name': rootService.name,\n      'service.version': rootService.version\n    }\n  };\n  \n  return { trace, spans, networkEvents };\n}\n\n// Store OpenTelemetry trace data\nexport async function storeOpenTelemetryTrace(traceData: { trace: InsertTrace; spans: InsertSpan[]; networkEvents: InsertNetworkEvent[] }) {\n  const { trace, spans: traceSpans, networkEvents: traceNetworkEvents } = traceData;\n  \n  try {\n    // Store trace\n    await db.insert(traces).values(trace);\n    \n    // Store spans\n    if (traceSpans.length > 0) {\n      await db.insert(spans).values(traceSpans);\n    }\n    \n    // Store network events\n    if (traceNetworkEvents.length > 0) {\n      await db.insert(networkEvents).values(traceNetworkEvents);\n    }\n    \n    console.log(`ðŸ“Š Stored OpenTelemetry trace with ${traceSpans.length} spans and ${traceNetworkEvents.length} network events`);\n  } catch (error) {\n    console.error('âŒ Error storing OpenTelemetry trace:', error);\n    throw error;\n  }\n}\n\nlet generationInterval: NodeJS.Timeout | null = null;\n\n// Start generating OpenTelemetry traces\nexport function startOpenTelemetryGeneration(intervalMs: number = 5000) {\n  if (generationInterval) {\n    clearInterval(generationInterval);\n  }\n  \n  console.log(`ðŸš€ OpenTelemetry generation started with ${intervalMs}ms interval`);\n  \n  generationInterval = setInterval(async () => {\n    try {\n      const traceData = generateOpenTelemetryTrace();\n      await storeOpenTelemetryTrace(traceData);\n    } catch (error) {\n      console.error('âŒ Error generating OpenTelemetry trace:', error);\n    }\n  }, intervalMs);\n  \n  // Generate first trace immediately\n  setTimeout(async () => {\n    try {\n      const traceData = generateOpenTelemetryTrace();\n      await storeOpenTelemetryTrace(traceData);\n    } catch (error) {\n      console.error('âŒ Error generating initial OpenTelemetry trace:', error);\n    }\n  }, 100);\n}\n\n// Stop generating OpenTelemetry traces\nexport function stopOpenTelemetryGeneration() {\n  if (generationInterval) {\n    clearInterval(generationInterval);\n    generationInterval = null;\n    console.log('ðŸ”´ OpenTelemetry generation stopped');\n  }\n}\n\n// Get recent traces\nexport async function getRecentTraces(limit: number = 20) {\n  try {\n    return await db\n      .select()\n      .from(traces)\n      .orderBy(desc(traces.createdAt))\n      .limit(limit);\n  } catch (error) {\n    console.error('âŒ Error fetching recent traces:', error);\n    return [];\n  }\n}\n\n// Get spans for a specific trace\nexport async function getSpansForTrace(traceId: string) {\n  try {\n    return await db\n      .select()\n      .from(spans)\n      .where(sql`${spans.traceId} = ${traceId}`)\n      .orderBy(asc(spans.startTime));\n  } catch (error) {\n    console.error(`âŒ Error fetching spans for trace ${traceId}:`, error);\n    return [];\n  }\n}\n\n// Get traces in time range\nexport async function getTracesInRange(from: Date, to: Date, limit: number = 100) {\n  try {\n    return await db\n      .select()\n      .from(traces)\n      .where(and(\n        gte(traces.startTime, from),\n        lte(traces.startTime, to)\n      ))\n      .orderBy(desc(traces.startTime))\n      .limit(limit);\n  } catch (error) {\n    console.error('âŒ Error fetching traces in range:', error);\n    return [];\n  }\n}","size_bytes":18360},"server/realisticOtelGenerator.ts":{"content":"import { db } from \"./db\";\nimport { traces, spans, networkEvents } from \"@shared/schema\";\nimport type { InsertTrace, InsertSpan, InsertNetworkEvent } from \"@shared/schema\";\nimport { nanoid } from \"nanoid\";\n\n// Expanded tenant/system configuration with 50 services across 10 tenants\nconst TENANT_SYSTEMS = {\n  'api-gateway': [\n    { name: 'gateway-main', version: '1.2.3' },\n    { name: 'gateway-auth', version: '1.2.1' },\n    { name: 'gateway-proxy', version: '1.2.0' },\n    { name: 'gateway-cache', version: '1.1.5' },\n    { name: 'gateway-metrics', version: '1.3.0' }\n  ],\n  'user-management': [\n    { name: 'user-service', version: '2.1.0' },\n    { name: 'profile-service', version: '2.0.8' },\n    { name: 'auth-service', version: '2.1.2' },\n    { name: 'session-mgr', version: '2.0.5' },\n    { name: 'identity-provider', version: '2.2.0' }\n  ],\n  'payment-system': [\n    { name: 'payment-core', version: '1.5.2' },\n    { name: 'payment-gateway', version: '1.5.0' },\n    { name: 'billing-service', version: '1.4.9' },\n    { name: 'fraud-detection', version: '1.6.1' },\n    { name: 'tax-calculator', version: '1.3.7' }\n  ],\n  'inventory-system': [\n    { name: 'inventory-core', version: '3.0.1' },\n    { name: 'stock-tracker', version: '2.9.5' },\n    { name: 'warehouse-mgmt', version: '3.0.0' },\n    { name: 'supplier-api', version: '2.8.3' },\n    { name: 'product-catalog', version: '3.1.2' }\n  ],\n  'notification-system': [\n    { name: 'notification-core', version: '1.8.0' },\n    { name: 'email-service', version: '1.7.5' },\n    { name: 'sms-service', version: '1.8.1' },\n    { name: 'push-service', version: '1.7.8' },\n    { name: 'template-engine', version: '1.9.2' }\n  ],\n  'analytics-platform': [\n    { name: 'data-collector', version: '2.5.0' },\n    { name: 'metrics-processor', version: '2.4.8' },\n    { name: 'report-generator', version: '2.6.1' },\n    { name: 'dashboard-api', version: '2.5.5' },\n    { name: 'ml-insights', version: '2.7.0' }\n  ],\n  'content-management': [\n    { name: 'content-api', version: '1.8.5' },\n    { name: 'media-storage', version: '1.9.0' },\n    { name: 'cdn-manager', version: '1.7.8' },\n    { name: 'content-search', version: '1.8.2' },\n    { name: 'asset-optimizer', version: '1.6.9' }\n  ],\n  'order-processing': [\n    { name: 'order-service', version: '3.2.1' },\n    { name: 'fulfillment-api', version: '3.1.8' },\n    { name: 'shipping-tracker', version: '3.2.5' },\n    { name: 'return-handler', version: '3.0.9' },\n    { name: 'order-analytics', version: '3.3.0' }\n  ],\n  'security-monitoring': [\n    { name: 'threat-detector', version: '1.4.2' },\n    { name: 'audit-logger', version: '1.5.1' },\n    { name: 'compliance-checker', version: '1.3.8' },\n    { name: 'access-monitor', version: '1.4.5' },\n    { name: 'incident-responder', version: '1.5.3' }\n  ],\n  'infrastructure-ops': [\n    { name: 'health-monitor', version: '2.1.0' },\n    { name: 'backup-service', version: '2.0.7' },\n    { name: 'deployment-mgr', version: '2.2.1' },\n    { name: 'config-service', version: '2.1.5' },\n    { name: 'log-aggregator', version: '2.3.0' }\n  ]\n};\n\n// Flatten for easy access\nconst ALL_SERVICES = Object.entries(TENANT_SYSTEMS).flatMap(([tenant, systems]) => \n  systems.map(system => ({ ...system, tenant }))\n);\n\nconst OPERATIONS = {\n  'api-gateway': ['route_request', 'authenticate', 'rate_limit', 'proxy_request', 'cache_lookup', 'metrics_collect'],\n  'user-management': ['get_user', 'create_user', 'update_profile', 'validate_session', 'verify_identity', 'manage_session'],\n  'payment-system': ['process_payment', 'validate_card', 'charge_customer', 'refund_payment', 'detect_fraud', 'calculate_tax'],\n  'inventory-system': ['check_stock', 'reserve_item', 'update_inventory', 'get_product', 'sync_suppliers', 'catalog_search'],\n  'notification-system': ['send_email', 'send_sms', 'push_notification', 'format_message', 'push_mobile', 'render_template'],\n  'analytics-platform': ['collect_events', 'process_metrics', 'generate_report', 'serve_dashboard', 'run_analysis', 'aggregate_data'],\n  'content-management': ['fetch_content', 'store_media', 'purge_cache', 'search_content', 'optimize_assets', 'manage_cdn'],\n  'order-processing': ['create_order', 'fulfill_order', 'track_shipment', 'process_return', 'analyze_orders', 'manage_fulfillment'],\n  'security-monitoring': ['detect_threats', 'log_audit', 'check_compliance', 'monitor_access', 'handle_incident', 'scan_vulnerabilities'],\n  'infrastructure-ops': ['check_health', 'create_backup', 'deploy_service', 'update_config', 'aggregate_logs', 'monitor_resources']\n};\n\nconst HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];\nconst HTTP_STATUSES = ['200', '201', '400', '401', '403', '404', '500', '502', '503'];\n\nconst SPAN_KINDS = {\n  SERVER: 'server',\n  CLIENT: 'client',\n  PRODUCER: 'producer',\n  CONSUMER: 'consumer',\n  INTERNAL: 'internal'\n};\n\n// Helper functions\nfunction generateTraceId(): string {\n  return Array.from({length: 32}, () => Math.floor(Math.random() * 16).toString(16)).join('');\n}\n\nfunction generateSpanId(): string {\n  return Array.from({length: 16}, () => Math.floor(Math.random() * 16).toString(16)).join('');\n}\n\nfunction generateDuration(min: number = 1000000, max: number = 500000000): number {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n// Generate realistic OpenTelemetry trace: Gateway â†’ API Bus â†’ Business Services\nexport function generateRealisticTrace(): { trace: InsertTrace; spans: InsertSpan[]; networkEvents: InsertNetworkEvent[] } {\n  const traceId = generateTraceId();\n  const startTime = new Date(Date.now() - Math.random() * 10000);\n  \n  const spans: InsertSpan[] = [];\n  const networkEvents: InsertNetworkEvent[] = [];\n  \n  // Create realistic service chain: Gateway â†’ API Bus â†’ Target Services\n  const serviceChain: Array<{ service: typeof ALL_SERVICES[0]; operation: string }> = [];\n  \n  // 1. Always start with gateway (entry point)\n  const gatewayServices = ALL_SERVICES.filter(s => s.tenant === 'api-gateway');\n  const gateway = gatewayServices[Math.floor(Math.random() * gatewayServices.length)];\n  serviceChain.push({ \n    service: gateway, \n    operation: OPERATIONS['api-gateway'][Math.floor(Math.random() * OPERATIONS['api-gateway'].length)]\n  });\n  \n  // 2. Add API bus/proxy (80% chance)\n  if (Math.random() > 0.2) {\n    const proxyService = ALL_SERVICES.find(s => s.name === 'gateway-proxy') || gateway;\n    if (proxyService.name !== gateway.name) {\n      serviceChain.push({ \n        service: proxyService, \n        operation: 'proxy_request' \n      });\n    }\n  }\n  \n  // 3. Add 1-3 business services from different tenants (realistic flow)\n  const businessTenants = ['user-management', 'payment-system', 'inventory-system', 'notification-system', 'analytics-platform', 'content-management', 'order-processing', 'security-monitoring', 'infrastructure-ops'];\n  const selectedTenants = businessTenants.sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);\n  \n  selectedTenants.forEach(tenant => {\n    const tenantServices = ALL_SERVICES.filter(s => s.tenant === tenant);\n    const service = tenantServices[Math.floor(Math.random() * tenantServices.length)];\n    const operation = OPERATIONS[tenant][Math.floor(Math.random() * OPERATIONS[tenant].length)];\n    serviceChain.push({ service, operation });\n  });\n  \n  // Generate spans for the realistic service chain\n  let currentTime = startTime.getTime();\n  let parentSpanId: string | null = null;\n  const method = HTTP_METHODS[Math.floor(Math.random() * HTTP_METHODS.length)];\n  const overallStatus = HTTP_STATUSES[Math.floor(Math.random() * HTTP_STATUSES.length)];\n  \n  serviceChain.forEach((chainItem, index) => {\n    const spanId = generateSpanId();\n    const spanDuration = generateDuration(10000000, 100000000); // 10ms to 100ms\n    const spanEndTime = new Date(currentTime + spanDuration / 1000000);\n    \n    const span: InsertSpan = {\n      traceId,\n      spanId,\n      parentSpanId,\n      operationName: chainItem.operation,\n      serviceName: chainItem.service.name,\n      tenant: chainItem.service.tenant,\n      system: chainItem.service.name,\n      kind: index === 0 ? SPAN_KINDS.SERVER : SPAN_KINDS.CLIENT,\n      startTime: new Date(currentTime),\n      endTime: spanEndTime,\n      duration: spanDuration,\n      status: parseInt(overallStatus) >= 400 ? 'error' : 'ok',\n      statusMessage: parseInt(overallStatus) >= 400 ? `HTTP ${overallStatus}` : undefined,\n      attributes: {\n        'http.method': method,\n        'http.status_code': parseInt(overallStatus),\n        'service.name': chainItem.service.name,\n        'service.version': chainItem.service.version\n      },\n      events: [],\n      links: [],\n      resource: {\n        'service.name': chainItem.service.name,\n        'service.version': chainItem.service.version,\n        'service.instance.id': nanoid(8)\n      }\n    };\n    \n    spans.push(span);\n    \n    // Create network event for service-to-service communication\n    if (index > 0) {\n      const prevService = serviceChain[index - 1].service;\n      const networkEvent: InsertNetworkEvent = {\n        source: prevService.name,\n        target: chainItem.service.name,\n        sourceService: prevService.name,\n        targetService: chainItem.service.name,\n        sourceTenant: prevService.tenant,\n        targetTenant: chainItem.service.tenant,\n        sourceSystem: prevService.name,\n        targetSystem: chainItem.service.name,\n        sourceLabel: `${prevService.name}:${Math.floor(Math.random() * 9000) + 1000}`,\n        targetLabel: `${chainItem.service.name}:${Math.floor(Math.random() * 9000) + 1000}`,\n        status: overallStatus,\n        method,\n        responseTime: Math.floor(spanDuration / 1000000),\n        timestamp: new Date(currentTime),\n        traceId,\n        metadata: {\n          span_id: spanId,\n          parent_span_id: parentSpanId,\n          operation: chainItem.operation\n        }\n      };\n      \n      networkEvents.push(networkEvent);\n    }\n    \n    parentSpanId = spanId;\n    currentTime += spanDuration / 1000000 + Math.random() * 5; // Small gap between spans\n  });\n  \n  // Calculate trace metadata\n  const traceRootService = serviceChain[0].service;\n  const totalDuration = spans.reduce((total, span) => total + span.duration, 0);\n  const traceEndTime = new Date(Math.max(...spans.map(s => s.endTime.getTime())));\n  const hasErrors = spans.some(s => s.status === 'error');\n  \n  const trace: InsertTrace = {\n    traceId,\n    serviceName: traceRootService.name,\n    serviceVersion: traceRootService.version,\n    tenant: traceRootService.tenant,\n    system: traceRootService.name,\n    startTime,\n    endTime: traceEndTime,\n    duration: totalDuration,\n    spanCount: spans.length,\n    status: hasErrors ? 'error' : 'ok',\n    statusMessage: hasErrors ? 'Trace contains errors' : undefined,\n    attributes: {\n      'trace.span_count': spans.length,\n      'trace.service_count': new Set(spans.map(s => s.serviceName)).size,\n      'trace.root_service': traceRootService.name\n    },\n    resource: {\n      'service.name': traceRootService.name,\n      'service.version': traceRootService.version\n    }\n  };\n  \n  return { trace, spans, networkEvents };\n}\n\n// Store realistic trace data\nexport async function storeRealisticTrace(traceData: { trace: InsertTrace; spans: InsertSpan[]; networkEvents: InsertNetworkEvent[] }) {\n  const { trace, spans: traceSpans, networkEvents: traceNetworkEvents } = traceData;\n  \n  try {\n    await db.insert(traces).values(trace);\n    \n    if (traceSpans.length > 0) {\n      await db.insert(spans).values(traceSpans);\n    }\n    \n    if (traceNetworkEvents.length > 0) {\n      await db.insert(networkEvents).values(traceNetworkEvents);\n    }\n    \n    console.log(`ðŸ“Š Stored realistic OpenTelemetry trace with ${traceSpans.length} spans and ${traceNetworkEvents.length} network events`);\n  } catch (error) {\n    console.error('Failed to store realistic trace data:', error);\n  }\n}\n\nlet generationInterval: NodeJS.Timeout | null = null;\n\n// Start realistic generation\nexport function startRealisticGeneration(intervalMs: number = 3000) {\n  if (generationInterval) {\n    clearInterval(generationInterval);\n  }\n  \n  generationInterval = setInterval(async () => {\n    const traceData = generateRealisticTrace();\n    await storeRealisticTrace(traceData);\n  }, intervalMs);\n  \n  console.log(`ðŸš€ Realistic OpenTelemetry generation started with ${intervalMs}ms interval`);\n}\n\n// Stop realistic generation\nexport function stopRealisticGeneration() {\n  if (generationInterval) {\n    clearInterval(generationInterval);\n    generationInterval = null;\n    console.log('ðŸ›‘ Realistic OpenTelemetry generation stopped');\n  }\n}","size_bytes":12653},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { storage } from \"./storage\";\nimport { insertDiagramSchema, diagramDataSchema } from \"@shared/schema\";\nimport { startNetworkGenerator, getRecentEvents, getEventsSince, getEventsInRange } from \"./networkGenerator\";\nimport { startOpenTelemetryGeneration, stopOpenTelemetryGeneration, getRecentTraces, getSpansForTrace, getTracesInRange } from \"./opentelemetryGenerator\";\nimport { startRealisticGeneration, stopRealisticGeneration } from \"./realisticOtelGenerator\";\nimport { startServiceMetricsGeneration, stopServiceMetricsGeneration, getLatestServiceMetrics, getServiceMetricsHistory } from \"./serviceMetricsGenerator\";\nimport multer from \"multer\";\nimport * as XLSX from \"xlsx\";\nimport { parse } from \"csv-parse/sync\";\n\nconst upload = multer({ storage: multer.memoryStorage() });\n\nexport async function registerRoutes(app: Express): Promise<Server> {\n  \n  // Parse uploaded file and extract source-target relationships\n  app.post(\"/api/parse-file\", upload.single(\"file\"), async (req, res) => {\n    try {\n      if (!req.file) {\n        return res.status(400).json({ message: \"No file uploaded\" });\n      }\n\n      const { buffer, originalname } = req.file;\n      let data: any[] = [];\n\n      // Parse based on file extension\n      if (originalname.endsWith('.csv')) {\n        const csvText = buffer.toString('utf-8');\n        data = parse(csvText, { columns: true, skip_empty_lines: true });\n      } else if (originalname.endsWith('.xlsx') || originalname.endsWith('.xls')) {\n        const workbook = XLSX.read(buffer, { type: 'buffer' });\n        const sheetName = workbook.SheetNames[0];\n        const worksheet = workbook.Sheets[sheetName];\n        data = XLSX.utils.sheet_to_json(worksheet);\n      } else {\n        return res.status(400).json({ message: \"Unsupported file format. Please use CSV or Excel files.\" });\n      }\n\n      // Validate required columns\n      if (data.length === 0) {\n        return res.status(400).json({ message: \"File is empty or could not be parsed\" });\n      }\n\n      const firstRow = data[0];\n      const columns = Object.keys(firstRow).map(col => col.toLowerCase());\n      \n      if (!columns.includes('source') || !columns.includes('target')) {\n        return res.status(400).json({ \n          message: \"File must contain 'source' and 'target' columns. Found columns: \" + Object.keys(firstRow).join(', ')\n        });\n      }\n\n      // First pass: collect all service-label combinations\n      const serviceLabels = new Map<string, Set<string>>();\n      \n      data.forEach(row => {\n        const source = String(row.source || row.Source || '').trim();\n        const target = String(row.target || row.Target || '').trim();\n        const label = String(row.label || row.Label || '').trim();\n        \n        if (!serviceLabels.has(source)) {\n          serviceLabels.set(source, new Set());\n        }\n        if (!serviceLabels.has(target)) {\n          serviceLabels.set(target, new Set());\n        }\n        \n        if (label) {\n          serviceLabels.get(source)!.add(label);\n          serviceLabels.get(target)!.add(label);\n        }\n      });\n\n      // Create nodes: one node per service-label combination\n      const nodes: any[] = [];\n      console.log('SERVER: Service-Label mapping:', Array.from(serviceLabels.entries()));\n      \n      serviceLabels.forEach((labels, serviceName) => {\n        console.log(`SERVER: Processing service \"${serviceName}\" with labels:`, Array.from(labels));\n        if (labels.size > 0) {\n          labels.forEach(label => {\n            const node = {\n              id: `${serviceName}_${label}`,\n              label: label,\n              service: serviceName  // This should be the original CSV service name\n            };\n            console.log(`SERVER: Created node:`, node);\n            nodes.push(node);\n          });\n        } else {\n          nodes.push({\n            id: serviceName,\n            label: serviceName,\n            service: serviceName\n          });\n        }\n      });\n\n      // Create edges\n      const edges = data.map((row, index) => {\n        const source = String(row.source || row.Source || '').trim();\n        const target = String(row.target || row.Target || '').trim();\n        const label = String(row.label || row.Label || '').trim();\n        const status = String(row.status || row.Status || '').trim();\n        \n\n        \n        return {\n          id: `edge_${index}`,\n          source: label ? `${source}_${label}` : source,\n          target: label ? `${target}_${label}` : target,\n          label: label,\n          status: status || undefined\n        };\n      });\n\n      const diagramData = { nodes, edges };\n      \n      // Validate the data structure\n      const validated = diagramDataSchema.parse(diagramData);\n      \n      res.json({\n        data: validated,\n        stats: {\n          nodeCount: nodes.length,\n          edgeCount: edges.length,\n          componentCount: 1 // Simplified for now\n        }\n      });\n\n    } catch (error) {\n      console.error(\"File parsing error:\", error);\n      res.status(400).json({ \n        message: error instanceof Error ? error.message : \"Failed to parse file\"\n      });\n    }\n  });\n\n  // Save diagram\n  app.post(\"/api/diagrams\", async (req, res) => {\n    try {\n      const validated = insertDiagramSchema.parse(req.body);\n      const diagram = await storage.createDiagram(validated);\n      res.json(diagram);\n    } catch (error) {\n      res.status(400).json({ message: \"Invalid diagram data\" });\n    }\n  });\n\n  // Get diagram\n  app.get(\"/api/diagrams/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const diagram = await storage.getDiagram(id);\n      if (!diagram) {\n        return res.status(404).json({ message: \"Diagram not found\" });\n      }\n      res.json(diagram);\n    } catch (error) {\n      res.status(400).json({ message: \"Invalid diagram ID\" });\n    }\n  });\n\n  // Update diagram\n  app.patch(\"/api/diagrams/:id\", async (req, res) => {\n    try {\n      const id = parseInt(req.params.id);\n      const updates = insertDiagramSchema.partial().parse(req.body);\n      const diagram = await storage.updateDiagram(id, updates);\n      if (!diagram) {\n        return res.status(404).json({ message: \"Diagram not found\" });\n      }\n      res.json(diagram);\n    } catch (error) {\n      res.status(400).json({ message: \"Invalid update data\" });\n    }\n  });\n\n  // Get all diagrams\n  app.get(\"/api/diagrams\", async (req, res) => {\n    try {\n      const diagrams = await storage.getAllDiagrams();\n      res.json(diagrams);\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch diagrams\" });\n    }\n  });\n\n  // Real-time network events endpoints\n  \n  // Start generating network events\n  app.post(\"/api/network/start\", (req, res) => {\n    try {\n      const interval = req.body.interval || 2000; // Default 2 seconds\n      \n      // Stop existing generator if running\n      const existingStopGenerator = (app as any).networkGeneratorStop;\n      if (existingStopGenerator) {\n        existingStopGenerator();\n        delete (app as any).networkGeneratorStop;\n      }\n      \n      // Start new generator with new interval\n      const stopGenerator = startNetworkGenerator(interval);\n      \n      // Store the stop function (in a real app, you'd use a proper state manager)\n      (app as any).networkGeneratorStop = stopGenerator;\n      \n      res.json({ \n        message: \"Network event generator started\", \n        interval: interval \n      });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to start generator\" });\n    }\n  });\n\n  // Stop generating network events\n  app.post(\"/api/network/stop\", (req, res) => {\n    try {\n      const stopGenerator = (app as any).networkGeneratorStop;\n      if (stopGenerator) {\n        stopGenerator();\n        delete (app as any).networkGeneratorStop;\n      }\n      \n      res.json({ message: \"Network event generator stopped\" });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to stop generator\" });\n    }\n  });\n\n  // Get recent network events\n  app.get(\"/api/network/events\", async (req, res) => {\n    try {\n      // Disable caching for real-time data\n      res.set({\n        'Cache-Control': 'no-cache, no-store, must-revalidate',\n        'Pragma': 'no-cache',\n        'Expires': '0'\n      });\n\n      const limit = parseInt(req.query.limit as string) || 100;\n      const from = req.query.from ? new Date(req.query.from as string) : null;\n      const to = req.query.to ? new Date(req.query.to as string) : null;\n      \n      // If time range is specified, use it; otherwise get recent events\n      if (from && to) {\n        const rangeDuration = Math.round((to.getTime() - from.getTime()) / (1000 * 60));\n        console.log(`ðŸ“Š Querying events for ${rangeDuration} min range: ${from.toISOString()} to ${to.toISOString()}`);\n        const events = await getEventsInRange(from, to, limit);\n        if (events.length > 0) {\n          const oldestEvent = new Date(events[events.length - 1].timestamp);\n          const newestEvent = new Date(events[0].timestamp);\n          console.log(`ðŸ“Š Found ${events.length} events, oldest: ${oldestEvent.toISOString()}, newest: ${newestEvent.toISOString()}`);\n        } else {\n          console.log(`ðŸ“Š No events found in ${rangeDuration} min range`);\n        }\n        res.json(events);\n      } else {\n        const events = await getRecentEvents(limit);\n        res.json(events);\n      }\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch events\" });\n    }\n  });\n\n  // Get events since timestamp\n  app.get(\"/api/network/events/since/:timestamp\", async (req, res) => {\n    try {\n      const timestamp = new Date(req.params.timestamp);\n      const events = await getEventsSince(timestamp);\n      res.json(events);\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch events since timestamp\" });\n    }\n  });\n\n  // OpenTelemetry endpoints\n  \n  // Start OpenTelemetry trace generation\n  app.post(\"/api/otel/start\", (req, res) => {\n    try {\n      const interval = req.body.interval || 5000; // Default 5 seconds for traces\n      \n      // Stop existing generator if running\n      const existingStopGenerator = (app as any).otelGeneratorStop;\n      if (existingStopGenerator) {\n        existingStopGenerator();\n        delete (app as any).otelGeneratorStop;\n      }\n      \n      // Start new generator\n      startOpenTelemetryGeneration(interval);\n      \n      // Store stop function for later cleanup\n      (app as any).otelGeneratorStop = () => stopOpenTelemetryGeneration();\n      \n      res.json({ \n        message: \"OpenTelemetry trace generation started\", \n        interval,\n        format: \"OpenTelemetry with traces and spans\"\n      });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to start OpenTelemetry generation\" });\n    }\n  });\n\n  // Stop OpenTelemetry trace generation\n  app.post(\"/api/otel/stop\", (req, res) => {\n    try {\n      const stopGenerator = (app as any).otelGeneratorStop;\n      if (stopGenerator) {\n        stopGenerator();\n        delete (app as any).otelGeneratorStop;\n      }\n      \n      stopOpenTelemetryGeneration();\n      res.json({ message: \"OpenTelemetry trace generation stopped\" });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to stop OpenTelemetry generation\" });\n    }\n  });\n\n  // Get recent traces\n  app.get(\"/api/otel/traces\", async (req, res) => {\n    try {\n      const limit = parseInt(req.query.limit as string) || 20;\n      const from = req.query.from ? new Date(req.query.from as string) : null;\n      const to = req.query.to ? new Date(req.query.to as string) : null;\n      \n      if (from && to) {\n        const traces = await getTracesInRange(from, to, limit);\n        res.json(traces);\n      } else {\n        const traces = await getRecentTraces(limit);\n        res.json(traces);\n      }\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch traces\" });\n    }\n  });\n\n  // Get spans for a specific trace\n  app.get(\"/api/otel/traces/:traceId/spans\", async (req, res) => {\n    try {\n      const { traceId } = req.params;\n      const spans = await getSpansForTrace(traceId);\n      res.json(spans);\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch spans for trace\" });\n    }\n  });\n\n  // Realistic OpenTelemetry generation endpoints\n  \n  // Start realistic OpenTelemetry trace generation (Gateway â†’ API Bus â†’ Business Services)\n  app.post(\"/api/otel/realistic/start\", (req, res) => {\n    try {\n      const interval = req.body.interval || 2000; // Default 2 seconds for realistic traces\n      \n      // Stop any existing generators first\n      stopOpenTelemetryGeneration();\n      stopRealisticGeneration();\n      \n      // Start realistic generation\n      startRealisticGeneration(interval);\n      \n      res.json({ \n        message: \"Realistic OpenTelemetry trace generation started\", \n        interval,\n        format: \"Realistic Gateway â†’ API Bus â†’ Business Services flow\"\n      });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to start realistic OpenTelemetry generation\" });\n    }\n  });\n  \n  // Stop realistic OpenTelemetry trace generation\n  app.post(\"/api/otel/realistic/stop\", (req, res) => {\n    try {\n      stopRealisticGeneration();\n      res.json({ message: \"Realistic OpenTelemetry trace generation stopped\" });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to stop realistic OpenTelemetry generation\" });\n    }\n  });\n\n  // Service Metrics API endpoints\n  app.post(\"/api/metrics/start\", (req, res) => {\n    try {\n      const interval = parseInt(req.body.intervalMs) || 30000;\n      startServiceMetricsGeneration(interval);\n      res.json({ \n        message: \"Service metrics generation started\", \n        interval: interval \n      });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to start metrics generation\" });\n    }\n  });\n\n  app.post(\"/api/metrics/stop\", (req, res) => {\n    try {\n      stopServiceMetricsGeneration();\n      res.json({ message: \"Service metrics generation stopped\" });\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to stop metrics generation\" });\n    }\n  });\n\n  app.get(\"/api/metrics/latest\", async (req, res) => {\n    try {\n      res.set({\n        'Cache-Control': 'no-cache, no-store, must-revalidate',\n        'Pragma': 'no-cache',\n        'Expires': '0'\n      });\n\n      const metrics = await getLatestServiceMetrics();\n      res.json(metrics);\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch service metrics\" });\n    }\n  });\n\n  app.get(\"/api/metrics/history/:serviceName\", async (req, res) => {\n    try {\n      const serviceName = req.params.serviceName;\n      const limit = parseInt(req.query.limit as string) || 50;\n      \n      const history = await getServiceMetricsHistory(serviceName, limit);\n      res.json(history);\n    } catch (error) {\n      res.status(500).json({ message: \"Failed to fetch service metrics history\" });\n    }\n  });\n\n  const httpServer = createServer(app);\n  return httpServer;\n}\n","size_bytes":15177},"server/serviceMetricsGenerator.ts":{"content":"import { db } from \"./db\";\nimport { serviceMetrics, type InsertServiceMetrics } from \"@shared/schema\";\nimport { eq, desc } from \"drizzle-orm\";\n\n// Service configurations for realistic metrics\nconst SERVICE_CONFIGS = [\n  { name: \"api-gateway\", type: \"kubernetes\", baseLoad: 0.6 },\n  { name: \"user-service\", type: \"kubernetes\", baseLoad: 0.4 },\n  { name: \"payment-service\", type: \"kubernetes\", baseLoad: 0.7 },\n  { name: \"inventory-service\", type: \"vm\", baseLoad: 0.5 },\n  { name: \"notification-service\", type: \"kubernetes\", baseLoad: 0.3 },\n  { name: \"platform-service1\", type: \"vm\", baseLoad: 0.6 },\n  { name: \"platform-service2\", type: \"kubernetes\", baseLoad: 0.5 },\n  { name: \"platform-service3\", type: \"vm\", baseLoad: 0.4 },\n  { name: \"gateway-service1\", type: \"kubernetes\", baseLoad: 0.8 }\n];\n\nfunction generateServiceMetrics(serviceName: string, deploymentType: string, baseLoad: number): InsertServiceMetrics {\n  // Add some realistic variation (Â±30%)\n  const loadVariation = 0.7 + (Math.random() * 0.6);\n  const currentLoad = Math.min(95, baseLoad * 100 * loadVariation);\n  \n  // CPU usage correlates with base load\n  const cpuUsage = Math.min(95, currentLoad + (Math.random() * 10 - 5));\n  \n  // Memory usage is typically more stable\n  const memoryUsage = Math.min(90, 30 + (currentLoad * 0.5) + (Math.random() * 20 - 10));\n  \n  // Disk usage grows slowly\n  const diskUsage = Math.min(85, 20 + (Math.random() * 30));\n  \n  // Network activity correlates with load\n  const networkIn = Math.max(0.1, currentLoad * 0.5 + (Math.random() * 20 - 10));\n  const networkOut = Math.max(0.1, currentLoad * 0.3 + (Math.random() * 15 - 7.5));\n  \n  // Pod count for Kubernetes services\n  const podCount = deploymentType === \"kubernetes\" ? Math.max(1, Math.floor(currentLoad / 30) + 1) : null;\n  \n  // Active connections\n  const activeConnections = Math.floor(currentLoad * 5 + (Math.random() * 100));\n  \n  // Error rate (higher when overloaded)\n  const errorRate = cpuUsage > 80 ? Math.random() * 5 + 2 : Math.random() * 2;\n  \n  // Response time (increases with load)\n  const responseTime = Math.max(10, 50 + (cpuUsage * 5) + (Math.random() * 100 - 50));\n  \n  // Health status based on overall metrics\n  let healthStatus: \"healthy\" | \"warning\" | \"critical\";\n  if (cpuUsage > 85 || memoryUsage > 85 || errorRate > 5) {\n    healthStatus = \"critical\";\n  } else if (cpuUsage > 70 || memoryUsage > 70 || errorRate > 2) {\n    healthStatus = \"warning\";\n  } else {\n    healthStatus = \"healthy\";\n  }\n  \n  return {\n    serviceName,\n    deploymentType: deploymentType as \"kubernetes\" | \"vm\",\n    cpuUsage: Math.round(cpuUsage * 100) / 100,\n    memoryUsage: Math.round(memoryUsage * 100) / 100,\n    diskUsage: Math.round(diskUsage * 100) / 100,\n    networkIn: Math.round(networkIn * 100) / 100,\n    networkOut: Math.round(networkOut * 100) / 100,\n    podCount,\n    activeConnections,\n    errorRate: Math.round(errorRate * 100) / 100,\n    responseTime: Math.round(responseTime),\n    healthStatus,\n    timestamp: new Date()\n  };\n}\n\nexport async function storeServiceMetrics(metrics: InsertServiceMetrics) {\n  try {\n    const result = await db.insert(serviceMetrics).values(metrics).returning();\n    if (result.length > 0) {\n      console.log(`ðŸ“Š Stored metrics for service ${metrics.serviceName} - ${metrics.healthStatus}`);\n    }\n  } catch (error) {\n    console.error('Failed to store service metrics:', error);\n  }\n}\n\nexport async function generateAndStoreMetricsForAllServices() {\n  for (const service of SERVICE_CONFIGS) {\n    const metrics = generateServiceMetrics(service.name, service.type, service.baseLoad);\n    await storeServiceMetrics(metrics);\n  }\n}\n\nlet metricsInterval: NodeJS.Timeout | null = null;\n\nexport function startServiceMetricsGeneration(intervalMs: number = 30000) {\n  if (metricsInterval) {\n    clearInterval(metricsInterval);\n  }\n  \n  // Generate initial metrics\n  generateAndStoreMetricsForAllServices();\n  \n  metricsInterval = setInterval(() => {\n    generateAndStoreMetricsForAllServices();\n  }, intervalMs);\n  \n  console.log(`ðŸš€ Service metrics generation started with ${intervalMs}ms interval`);\n}\n\nexport function stopServiceMetricsGeneration() {\n  if (metricsInterval) {\n    clearInterval(metricsInterval);\n    metricsInterval = null;\n    console.log('â¹ï¸ Service metrics generation stopped');\n  }\n}\n\nexport async function getLatestServiceMetrics() {\n  try {\n    const latest = await db\n      .select()\n      .from(serviceMetrics)\n      .orderBy(desc(serviceMetrics.timestamp))\n      .limit(100);\n    \n    // Group by service name to get latest metrics per service\n    const latestPerService = new Map();\n    latest.forEach(metric => {\n      if (!latestPerService.has(metric.serviceName)) {\n        latestPerService.set(metric.serviceName, metric);\n      }\n    });\n    \n    return Array.from(latestPerService.values());\n  } catch (error) {\n    console.error('Error fetching service metrics:', error);\n    return [];\n  }\n}\n\nexport async function getServiceMetricsHistory(serviceName: string, limit: number = 50) {\n  try {\n    return await db\n      .select()\n      .from(serviceMetrics)\n      .where(eq(serviceMetrics.serviceName, serviceName))\n      .orderBy(desc(serviceMetrics.timestamp))\n      .limit(limit);\n  } catch (error) {\n    console.error('Error fetching service metrics history:', error);\n    return [];\n  }\n}","size_bytes":5341},"server/storage.ts":{"content":"import { diagrams, type Diagram, type InsertDiagram } from \"@shared/schema\";\n\nexport interface IStorage {\n  getDiagram(id: number): Promise<Diagram | undefined>;\n  createDiagram(diagram: InsertDiagram): Promise<Diagram>;\n  updateDiagram(id: number, diagram: Partial<InsertDiagram>): Promise<Diagram | undefined>;\n  deleteDiagram(id: number): Promise<boolean>;\n  getAllDiagrams(): Promise<Diagram[]>;\n}\n\nexport class MemStorage implements IStorage {\n  private diagrams: Map<number, Diagram>;\n  private currentId: number;\n\n  constructor() {\n    this.diagrams = new Map();\n    this.currentId = 1;\n  }\n\n  async getDiagram(id: number): Promise<Diagram | undefined> {\n    return this.diagrams.get(id);\n  }\n\n  async createDiagram(insertDiagram: InsertDiagram): Promise<Diagram> {\n    const id = this.currentId++;\n    const diagram: Diagram = { \n      ...insertDiagram, \n      id, \n      createdAt: new Date() \n    };\n    this.diagrams.set(id, diagram);\n    return diagram;\n  }\n\n  async updateDiagram(id: number, updateData: Partial<InsertDiagram>): Promise<Diagram | undefined> {\n    const existing = this.diagrams.get(id);\n    if (!existing) return undefined;\n    \n    const updated: Diagram = { ...existing, ...updateData };\n    this.diagrams.set(id, updated);\n    return updated;\n  }\n\n  async deleteDiagram(id: number): Promise<boolean> {\n    return this.diagrams.delete(id);\n  }\n\n  async getAllDiagrams(): Promise<Diagram[]> {\n    return Array.from(this.diagrams.values());\n  }\n}\n\nexport const storage = new MemStorage();\n","size_bytes":1519},"server/vite.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\nexport async function setupVite(app: Express, server: Server) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server },\n    allowedHosts: true,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(import.meta.dirname, \"public\");\n\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","size_bytes":2254},"shared/schema.ts":{"content":"import { pgTable, text, serial, integer, jsonb, timestamp, varchar, real } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const diagrams = pgTable(\"diagrams\", {\n  id: serial(\"id\").primaryKey(),\n  name: text(\"name\").notNull(),\n  data: jsonb(\"data\").notNull(), // Stores nodes and edges data\n  layout: text(\"layout\").notNull().default(\"force\"),\n  settings: jsonb(\"settings\").notNull().default('{}'), // Styling and display settings\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\n// OpenTelemetry Traces table\nexport const traces = pgTable(\"traces\", {\n  id: serial(\"id\").primaryKey(),\n  traceId: varchar(\"trace_id\", { length: 32 }).notNull().unique(), // 128-bit hex\n  serviceName: varchar(\"service_name\", { length: 255 }).notNull(),\n  serviceVersion: varchar(\"service_version\", { length: 50 }).default(\"unknown\"),\n  tenant: varchar(\"tenant\", { length: 100 }).notNull(), // Group of services (api, gateway, payment-system, etc.)\n  system: varchar(\"system\", { length: 100 }).notNull(), // Individual service within tenant\n  startTime: timestamp(\"start_time\").notNull(),\n  endTime: timestamp(\"end_time\"),\n  duration: integer(\"duration\"), // nanoseconds\n  spanCount: integer(\"span_count\").default(0),\n  status: varchar(\"status\", { length: 10 }).notNull().default(\"unset\"), // unset, ok, error\n  statusMessage: text(\"status_message\"),\n  attributes: jsonb(\"attributes\").default({}),\n  resource: jsonb(\"resource\").default({}),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\n// OpenTelemetry Spans table\nexport const spans = pgTable(\"spans\", {\n  id: serial(\"id\").primaryKey(),\n  traceId: varchar(\"trace_id\", { length: 32 }).notNull(), // 128-bit hex\n  spanId: varchar(\"span_id\", { length: 16 }).notNull().unique(), // 64-bit hex\n  parentSpanId: varchar(\"parent_span_id\", { length: 16 }),\n  operationName: varchar(\"operation_name\", { length: 255 }).notNull(),\n  serviceName: varchar(\"service_name\", { length: 255 }).notNull(),\n  tenant: varchar(\"tenant\", { length: 100 }).notNull(), // Group of services\n  system: varchar(\"system\", { length: 100 }).notNull(), // Individual service within tenant\n  kind: varchar(\"kind\", { length: 20 }).notNull().default(\"internal\"), // client, server, internal, producer, consumer\n  startTime: timestamp(\"start_time\").notNull(),\n  endTime: timestamp(\"end_time\"),\n  duration: integer(\"duration\"), // nanoseconds\n  status: varchar(\"status\", { length: 10 }).notNull().default(\"unset\"), // unset, ok, error\n  statusMessage: text(\"status_message\"),\n  attributes: jsonb(\"attributes\").default({}),\n  events: jsonb(\"events\").default([]), // Array of timestamped events\n  links: jsonb(\"links\").default([]), // Array of linked spans\n  resource: jsonb(\"resource\").default({}),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n});\n\n// Compatibility table for old network events format\nexport const networkEvents = pgTable(\"network_events\", {\n  id: serial(\"id\").primaryKey(),\n  source: varchar(\"source\", { length: 255 }).notNull(),\n  target: varchar(\"target\", { length: 255 }).notNull(),\n  sourceService: varchar(\"source_service\", { length: 255 }),\n  targetService: varchar(\"target_service\", { length: 255 }),\n  sourceTenant: varchar(\"source_tenant\", { length: 100 }).notNull(),\n  targetTenant: varchar(\"target_tenant\", { length: 100 }).notNull(),\n  sourceSystem: varchar(\"source_system\", { length: 100 }).notNull(),\n  targetSystem: varchar(\"target_system\", { length: 100 }).notNull(),\n  sourceLabel: varchar(\"source_label\", { length: 255 }),\n  targetLabel: varchar(\"target_label\", { length: 255 }),\n  status: varchar(\"status\", { length: 10 }),\n  method: varchar(\"method\", { length: 10 }),\n  responseTime: integer(\"response_time\"),\n  traceId: varchar(\"trace_id\", { length: 32 }), // Updated to match traces table\n  spanId: varchar(\"span_id\", { length: 16 }), // New field for span correlation\n  timestamp: timestamp(\"timestamp\").defaultNow().notNull(),\n  metadata: jsonb(\"metadata\"),\n});\n\n// Insert schemas for all tables\nexport const insertDiagramSchema = createInsertSchema(diagrams).omit({\n  id: true,\n  createdAt: true,\n});\n\nexport const insertTraceSchema = createInsertSchema(traces).omit({\n  id: true,\n  createdAt: true,\n});\n\nexport const insertSpanSchema = createInsertSchema(spans).omit({\n  id: true,\n  createdAt: true,\n});\n\nexport const insertNetworkEventSchema = createInsertSchema(networkEvents).omit({\n  id: true,\n  timestamp: true,\n});\n\n// Service metrics table for monitoring computational resources\nexport const serviceMetrics = pgTable(\"service_metrics\", {\n  id: serial(\"id\").primaryKey(),\n  serviceName: varchar(\"service_name\", { length: 255 }).notNull(),\n  deploymentType: varchar(\"deployment_type\", { length: 20 }).notNull(), // 'kubernetes' | 'vm'\n  cpuUsage: real(\"cpu_usage\").notNull(), // percentage 0-100\n  memoryUsage: real(\"memory_usage\").notNull(), // percentage 0-100\n  diskUsage: real(\"disk_usage\").notNull(), // percentage 0-100\n  networkIn: real(\"network_in\").notNull(), // MB/s\n  networkOut: real(\"network_out\").notNull(), // MB/s\n  podCount: integer(\"pod_count\"), // for kubernetes\n  activeConnections: integer(\"active_connections\").notNull(),\n  errorRate: real(\"error_rate\").notNull(), // percentage 0-100\n  responseTime: real(\"response_time\").notNull(), // average ms\n  healthStatus: varchar(\"health_status\", { length: 20 }).notNull(), // 'healthy' | 'warning' | 'critical'\n  timestamp: timestamp(\"timestamp\").defaultNow().notNull(),\n  createdAt: timestamp(\"created_at\").defaultNow().notNull()\n});\n\nexport const insertServiceMetricsSchema = createInsertSchema(serviceMetrics).omit({\n  id: true,\n  createdAt: true,\n});\n\n// Type definitions\nexport type InsertDiagram = z.infer<typeof insertDiagramSchema>;\nexport type Diagram = typeof diagrams.$inferSelect;\nexport type InsertTrace = z.infer<typeof insertTraceSchema>;\nexport type Trace = typeof traces.$inferSelect;\nexport type InsertSpan = z.infer<typeof insertSpanSchema>;\nexport type Span = typeof spans.$inferSelect;\nexport type InsertNetworkEvent = z.infer<typeof insertNetworkEventSchema>;\nexport type NetworkEvent = typeof networkEvents.$inferSelect;\nexport type InsertServiceMetrics = z.infer<typeof insertServiceMetricsSchema>;\nexport type ServiceMetrics = typeof serviceMetrics.$inferSelect;\n\n// Data structures for diagram elements\nexport const nodeSchema = z.object({\n  id: z.string(),\n  label: z.string(),\n  x: z.number().optional(),\n  y: z.number().optional(),\n  service: z.string().optional(),\n  tenant: z.string().optional(),\n  system: z.string().optional(),\n  nodeType: z.enum(['service', 'endpoint']).optional(),\n});\n\nexport const edgeSchema = z.object({\n  id: z.string(),\n  source: z.string(),\n  target: z.string(),\n  label: z.string().optional(),\n  status: z.string().optional(),\n  traceId: z.string().optional(),\n});\n\nexport const diagramDataSchema = z.object({\n  nodes: z.array(nodeSchema),\n  edges: z.array(edgeSchema),\n});\n\nexport const diagramSettingsSchema = z.object({\n  showLabels: z.boolean().default(true),\n  showArrows: z.boolean().default(true),\n  nodeColor: z.string().default(\"primary\"),\n  nodeSpacing: z.number().default(120),\n  clusterSpacing: z.number().default(600),\n  brightness: z.number().min(0.1).max(3.0).default(1.0),\n});\n\nexport type Node = z.infer<typeof nodeSchema>;\nexport type Edge = z.infer<typeof edgeSchema>;\nexport type DiagramData = z.infer<typeof diagramDataSchema>;\nexport type DiagramSettings = z.infer<typeof diagramSettingsSchema>;\n","size_bytes":7499},"client/src/App.tsx":{"content":"import { Switch, Route } from \"wouter\";\nimport { queryClient } from \"./lib/queryClient\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport DiagramGenerator from \"@/pages/DiagramGenerator\";\nimport NotFound from \"@/pages/not-found\";\n\nfunction Router() {\n  return (\n    <Switch>\n      <Route path=\"/\" component={DiagramGenerator} />\n      <Route component={NotFound} />\n    </Switch>\n  );\n}\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TooltipProvider>\n        <Toaster />\n        <Router />\n      </TooltipProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","size_bytes":735},"client/src/index.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n:root {\n  --background: hsl(0, 0%, 100%);\n  --foreground: hsl(20, 14.3%, 4.1%);\n  --muted: hsl(60, 4.8%, 95.9%);\n  --muted-foreground: hsl(25, 5.3%, 44.7%);\n  --popover: hsl(0, 0%, 100%);\n  --popover-foreground: hsl(20, 14.3%, 4.1%);\n  --card: hsl(0, 0%, 100%);\n  --card-foreground: hsl(20, 14.3%, 4.1%);\n  --border: hsl(20, 5.9%, 90%);\n  --input: hsl(20, 5.9%, 90%);\n  --primary: hsl(207, 90%, 54%);\n  --primary-foreground: hsl(211, 100%, 99%);\n  --secondary: hsl(60, 4.8%, 95.9%);\n  --secondary-foreground: hsl(24, 9.8%, 10%);\n  --accent: hsl(60, 4.8%, 95.9%);\n  --accent-foreground: hsl(24, 9.8%, 10%);\n  --destructive: hsl(0, 84.2%, 60.2%);\n  --destructive-foreground: hsl(60, 9.1%, 97.8%);\n  --ring: hsl(20, 14.3%, 4.1%);\n  --radius: 0.5rem;\n}\n\n.dark {\n  --background: hsl(240, 10%, 3.9%);\n  --foreground: hsl(0, 0%, 98%);\n  --muted: hsl(240, 3.7%, 15.9%);\n  --muted-foreground: hsl(240, 5%, 64.9%);\n  --popover: hsl(240, 10%, 3.9%);\n  --popover-foreground: hsl(0, 0%, 98%);\n  --card: hsl(240, 10%, 3.9%);\n  --card-foreground: hsl(0, 0%, 98%);\n  --border: hsl(240, 3.7%, 15.9%);\n  --input: hsl(240, 3.7%, 15.9%);\n  --primary: hsl(207, 90%, 54%);\n  --primary-foreground: hsl(211, 100%, 99%);\n  --secondary: hsl(240, 3.7%, 15.9%);\n  --secondary-foreground: hsl(0, 0%, 98%);\n  --accent: hsl(240, 3.7%, 15.9%);\n  --accent-foreground: hsl(0, 0%, 98%);\n  --destructive: hsl(0, 62.8%, 30.6%);\n  --destructive-foreground: hsl(0, 0%, 98%);\n  --ring: hsl(240, 4.9%, 83.9%);\n  --radius: 0.5rem;\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n  }\n}\n\n/* Custom styles for diagram interactions */\n.node circle {\n  cursor: move;\n  transition: all 0.2s ease;\n}\n\n.node:hover circle {\n  stroke-width: 4;\n  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));\n}\n\n.node.active circle {\n  stroke-width: 5;\n  filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.15));\n}\n\n/* Edge styles for better visibility */\n.normal-edge {\n  transition: stroke-width 0.2s ease;\n}\n\n.normal-edge:hover {\n  stroke-width: 3;\n}\n\n.circular-edge {\n  stroke-dasharray: 5,5;\n  animation: dash 1s linear infinite;\n  transition: all 0.2s ease;\n}\n\n.circular-edge:hover {\n  stroke-width: 4;\n  stroke-dasharray: 8,8;\n}\n\n@keyframes dash {\n  to {\n    stroke-dashoffset: 20;\n  }\n}\n\n/* Upload zone styles */\n.upload-zone {\n  transition: all 0.2s ease;\n}\n\n.upload-zone:hover {\n  background-color: hsl(207, 90%, 54%, 0.02);\n}\n\n/* Slider customization */\n.slider {\n  -webkit-appearance: none;\n  appearance: none;\n  background: transparent;\n  cursor: pointer;\n}\n\n.slider::-webkit-slider-track {\n  background: hsl(20, 5.9%, 90%);\n  height: 6px;\n  border-radius: 3px;\n}\n\n.slider::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  background: hsl(207, 90%, 54%);\n  height: 18px;\n  width: 18px;\n  border-radius: 50%;\n  cursor: pointer;\n}\n\n.slider::-moz-range-track {\n  background: hsl(20, 5.9%, 90%);\n  height: 6px;\n  border-radius: 3px;\n  border: none;\n}\n\n.slider::-moz-range-thumb {\n  background: hsl(207, 90%, 54%);\n  height: 18px;\n  width: 18px;\n  border-radius: 50%;\n  cursor: pointer;\n  border: none;\n}\n","size_bytes":3300},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","size_bytes":157},"k8s/base/app-deployment.yaml":{"content":"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: diagram-generator-app\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: app\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: diagram-generator-app\n  template:\n    metadata:\n      labels:\n        app: diagram-generator-app\n    spec:\n      containers:\n      - name: app\n        image: diagram-generator:latest\n        ports:\n        - containerPort: 5000\n        envFrom:\n        - configMapRef:\n            name: diagram-generator-config\n        - secretRef:\n            name: diagram-generator-secret\n        livenessProbe:\n          httpGet:\n            path: /api/health\n            port: 5000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /api/health\n            port: 5000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: diagram-generator-service\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: app\nspec:\n  type: ClusterIP\n  ports:\n  - port: 80\n    targetPort: 5000\n    protocol: TCP\n  selector:\n    app: diagram-generator-app\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: diagram-generator-ingress\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: ingress\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  ingressClassName: nginx\n  rules:\n  - host: diagram-generator.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: diagram-generator-service\n            port:\n              number: 80","size_bytes":1987},"k8s/base/configmap.yaml":{"content":"apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: diagram-generator-config\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: config\ndata:\n  NODE_ENV: \"production\"\n  PGHOST: \"postgres-service\"\n  PGPORT: \"5432\"\n  PGDATABASE: \"diagram_generator\"\n  PGUSER: \"postgres\"","size_bytes":332},"k8s/base/kustomization.yaml":{"content":"apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nmetadata:\n  name: diagram-generator-base\n\nresources:\n- namespace.yaml\n- configmap.yaml\n- secret.yaml\n- postgres-deployment.yaml\n- app-deployment.yaml\n\ncommonLabels:\n  app.kubernetes.io/name: diagram-generator\n  app.kubernetes.io/instance: default\n\nnamespace: diagram-generator\n\nimages:\n- name: diagram-generator\n  newTag: latest","size_bytes":393},"k8s/base/namespace.yaml":{"content":"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: namespace","size_bytes":165},"k8s/base/postgres-deployment.yaml":{"content":"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: postgres-deployment\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: postgres\n    app.kubernetes.io/component: database\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: postgres\n  template:\n    metadata:\n      labels:\n        app: postgres\n    spec:\n      containers:\n      - name: postgres\n        image: postgres:15-alpine\n        ports:\n        - containerPort: 5432\n        env:\n        - name: POSTGRES_DB\n          valueFrom:\n            configMapKeyRef:\n              name: diagram-generator-config\n              key: PGDATABASE\n        - name: POSTGRES_USER\n          valueFrom:\n            configMapKeyRef:\n              name: diagram-generator-config\n              key: PGUSER\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: diagram-generator-secret\n              key: PGPASSWORD\n        volumeMounts:\n        - name: postgres-storage\n          mountPath: /var/lib/postgresql/data\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n      volumes:\n      - name: postgres-storage\n        persistentVolumeClaim:\n          claimName: postgres-pvc\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: postgres-service\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: postgres\n    app.kubernetes.io/component: database\nspec:\n  ports:\n  - port: 5432\n    targetPort: 5432\n  selector:\n    app: postgres\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: postgres-pvc\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: postgres\n    app.kubernetes.io/component: database\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi","size_bytes":1855},"k8s/base/secret.yaml":{"content":"apiVersion: v1\nkind: Secret\nmetadata:\n  name: diagram-generator-secret\n  namespace: diagram-generator\n  labels:\n    app.kubernetes.io/name: diagram-generator\n    app.kubernetes.io/component: secret\ntype: Opaque\ndata:\n  # postgres (base64 encoded)\n  PGPASSWORD: cG9zdGdyZXM=\n  # postgresql://postgres:postgres@postgres-service:5432/diagram_generator (base64 encoded)\n  DATABASE_URL: cG9zdGdyZXNxbDovL3Bvc3RncmVzOnBvc3RncmVzQHBvc3RncmVzLXNlcnZpY2U6NTQzMi9kaWFncmFtX2dlbmVyYXRvcg==","size_bytes":478},"server/test/api.test.ts":{"content":"import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport request from 'supertest';\nimport express from 'express';\nimport { registerRoutes } from '../routes';\nimport { storage } from '../storage';\nimport * as networkGenerator from '../networkGenerator';\n\ndescribe('API Routes', () => {\n  let app: express.Express;\n  let server: any;\n\n  beforeEach(async () => {\n    app = express();\n    app.use(express.json());\n    server = await registerRoutes(app);\n  });\n\n  afterEach((done) => {\n    if (server) {\n      server.close(done);\n    } else {\n      done();\n    }\n  });\n\n  describe('Diagram Routes', () => {\n    describe('GET /api/diagrams', () => {\n      it('should return empty array initially', async () => {\n        const response = await request(app).get('/api/diagrams');\n        \n        expect(response.status).toBe(200);\n        expect(response.body).toEqual([]);\n      });\n    });\n\n    describe('POST /api/diagrams', () => {\n      it('should create a new diagram', async () => {\n        const diagramData = {\n          name: 'Test Diagram',\n          description: 'A test diagram',\n          data: {\n            nodes: [\n              { id: 'node1', label: 'Node 1', service: 'service1' }\n            ],\n            edges: []\n          },\n          settings: {\n            showLabels: true,\n            showArrows: true,\n            nodeColor: 'blue',\n            nodeSpacing: 100\n          }\n        };\n\n        const response = await request(app)\n          .post('/api/diagrams')\n          .send(diagramData);\n\n        expect(response.status).toBe(201);\n        expect(response.body).toMatchObject({\n          name: 'Test Diagram',\n          description: 'A test diagram'\n        });\n        expect(response.body.id).toBeDefined();\n        expect(response.body.createdAt).toBeDefined();\n      });\n\n      it('should validate required fields', async () => {\n        const invalidData = {\n          description: 'Missing name field'\n        };\n\n        const response = await request(app)\n          .post('/api/diagrams')\n          .send(invalidData);\n\n        expect(response.status).toBe(400);\n      });\n    });\n\n    describe('GET /api/diagrams/:id', () => {\n      it('should return specific diagram by ID', async () => {\n        // First create a diagram\n        const diagramData = {\n          name: 'Test Diagram',\n          description: 'A test diagram',\n          data: { nodes: [], edges: [] },\n          settings: { showLabels: true, showArrows: true, nodeColor: 'blue', nodeSpacing: 100 }\n        };\n\n        const createResponse = await request(app)\n          .post('/api/diagrams')\n          .send(diagramData);\n\n        const diagramId = createResponse.body.id;\n\n        // Then fetch it by ID\n        const response = await request(app).get(`/api/diagrams/${diagramId}`);\n        \n        expect(response.status).toBe(200);\n        expect(response.body.id).toBe(diagramId);\n        expect(response.body.name).toBe('Test Diagram');\n      });\n\n      it('should return 404 for non-existent diagram', async () => {\n        const response = await request(app).get('/api/diagrams/999');\n        \n        expect(response.status).toBe(404);\n      });\n    });\n  });\n\n  describe('Network Event Routes', () => {\n    describe('GET /api/network/events', () => {\n      it('should return network events within time range', async () => {\n        const response = await request(app).get('/api/network/events');\n        \n        expect(response.status).toBe(200);\n        expect(Array.isArray(response.body)).toBe(true);\n      });\n\n      it('should handle time range parameters', async () => {\n        const fromTime = new Date('2025-01-06T12:00:00Z').toISOString();\n        const toTime = new Date('2025-01-06T13:00:00Z').toISOString();\n\n        const response = await request(app)\n          .get('/api/network/events')\n          .query({ from: fromTime, to: toTime });\n        \n        expect(response.status).toBe(200);\n        expect(Array.isArray(response.body)).toBe(true);\n      });\n\n      it('should handle limit parameter', async () => {\n        const response = await request(app)\n          .get('/api/network/events')\n          .query({ limit: 10 });\n        \n        expect(response.status).toBe(200);\n        expect(Array.isArray(response.body)).toBe(true);\n      });\n    });\n\n    describe('POST /api/network/generate/start', () => {\n      it('should start network event generation', async () => {\n        const response = await request(app)\n          .post('/api/network/generate/start')\n          .send({ intervalMs: 1000 });\n        \n        expect(response.status).toBe(200);\n        expect(response.body.message).toContain('started');\n      });\n    });\n\n    describe('POST /api/network/generate/stop', () => {\n      it('should stop network event generation', async () => {\n        const response = await request(app).post('/api/network/generate/stop');\n        \n        expect(response.status).toBe(200);\n        expect(response.body.message).toContain('stopped');\n      });\n    });\n  });\n\n  describe('File Upload Routes', () => {\n    describe('POST /api/parse-file', () => {\n      it('should handle CSV file upload', async () => {\n        const csvContent = 'source,target\\nnode1,node2\\nnode2,node3';\n        \n        const response = await request(app)\n          .post('/api/parse-file')\n          .attach('file', Buffer.from(csvContent), {\n            filename: 'test.csv',\n            contentType: 'text/csv'\n          });\n        \n        expect(response.status).toBe(200);\n        expect(response.body.data).toBeDefined();\n        expect(response.body.data.nodes).toBeDefined();\n        expect(response.body.data.edges).toBeDefined();\n        expect(response.body.stats).toBeDefined();\n      });\n\n      it('should reject files without required columns', async () => {\n        const invalidCsv = 'col1,col2\\nvalue1,value2';\n        \n        const response = await request(app)\n          .post('/api/parse-file')\n          .attach('file', Buffer.from(invalidCsv), {\n            filename: 'invalid.csv',\n            contentType: 'text/csv'\n          });\n        \n        expect(response.status).toBe(400);\n        expect(response.body.error).toContain('required columns');\n      });\n\n      it('should handle multiple file upload', async () => {\n        const csvContent1 = 'source,target\\nnode1,node2';\n        const csvContent2 = 'source,target\\nnode2,node3';\n        \n        const response = await request(app)\n          .post('/api/parse-file')\n          .attach('files', Buffer.from(csvContent1), {\n            filename: 'test1.csv',\n            contentType: 'text/csv'\n          })\n          .attach('files', Buffer.from(csvContent2), {\n            filename: 'test2.csv',\n            contentType: 'text/csv'\n          });\n        \n        expect(response.status).toBe(200);\n        expect(response.body.data).toBeDefined();\n        expect(response.body.filenames).toHaveLength(2);\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle 404 for unknown routes', async () => {\n      const response = await request(app).get('/api/unknown-route');\n      \n      expect(response.status).toBe(404);\n    });\n\n    it('should handle malformed JSON', async () => {\n      const response = await request(app)\n        .post('/api/diagrams')\n        .set('Content-Type', 'application/json')\n        .send('{ invalid json }');\n      \n      expect(response.status).toBe(400);\n    });\n  });\n});","size_bytes":7451},"client/src/components/AppearanceControls.tsx":{"content":"import { Switch } from \"@/components/ui/switch\";\nimport { Button } from \"@/components/ui/button\";\nimport { Slider } from \"@/components/ui/slider\";\nimport type { DiagramSettings } from \"@/types/diagram\";\n\ninterface AppearanceControlsProps {\n  settings: DiagramSettings;\n  onSettingsChange: (settings: DiagramSettings) => void;\n  disabled?: boolean;\n}\n\nconst colorOptions = [\n  { value: \"primary\", color: \"bg-primary\", label: \"Blue\" },\n  { value: \"red\", color: \"bg-red-500\", label: \"Red\" },\n  { value: \"green\", color: \"bg-green-500\", label: \"Green\" },\n  { value: \"purple\", color: \"bg-purple-500\", label: \"Purple\" },\n];\n\nexport default function AppearanceControls({\n  settings,\n  onSettingsChange,\n  disabled = false\n}: AppearanceControlsProps) {\n  const handleToggle = (key: keyof DiagramSettings, value: boolean) => {\n    onSettingsChange({ ...settings, [key]: value });\n  };\n\n  const handleColorChange = (color: string) => {\n    onSettingsChange({ ...settings, nodeColor: color });\n  };\n\n  const handleBrightnessChange = (value: number[]) => {\n    onSettingsChange({ ...settings, brightness: value[0] });\n  };\n\n  const handleNodeSpacingChange = (value: number[]) => {\n    onSettingsChange({ ...settings, nodeSpacing: value[0] });\n  };\n\n  const handleClusterSpacingChange = (value: number[]) => {\n    onSettingsChange({ ...settings, clusterSpacing: value[0] });\n  };\n\n  return (\n    <div className=\"p-6 border-b border-gray-200\">\n      <h3 className=\"text-sm font-semibold text-foreground mb-3\">Appearance</h3>\n      <div className=\"space-y-3\">\n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-xs font-medium text-muted-foreground\">Show Labels</span>\n          <Switch\n            checked={settings.showLabels}\n            onCheckedChange={(checked) => handleToggle(\"showLabels\", checked)}\n            disabled={disabled}\n          />\n        </div>\n        \n        <div className=\"flex items-center justify-between\">\n          <span className=\"text-xs font-medium text-muted-foreground\">Show Arrows</span>\n          <Switch\n            checked={settings.showArrows}\n            onCheckedChange={(checked) => handleToggle(\"showArrows\", checked)}\n            disabled={disabled}\n          />\n        </div>\n        \n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-2\">\n            Node Spacing: {(settings.nodeSpacing || 120)}\n          </label>\n          <Slider\n            value={[settings.nodeSpacing || 120]}\n            onValueChange={handleNodeSpacingChange}\n            min={50}\n            max={300}\n            step={10}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-2\">\n            Cluster Spacing: {(settings.clusterSpacing || 600)}\n          </label>\n          <Slider\n            value={[settings.clusterSpacing || 600]}\n            onValueChange={handleClusterSpacingChange}\n            min={200}\n            max={1500}\n            step={50}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-2\">\n            Brightness: {(settings.brightness || 1.0).toFixed(1)}x\n          </label>\n          <Slider\n            value={[settings.brightness || 1.0]}\n            onValueChange={handleBrightnessChange}\n            min={0.1}\n            max={3.0}\n            step={0.1}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-1\">Node Color</label>\n          <div className=\"flex space-x-2\">\n            {colorOptions.map((option) => (\n              <Button\n                key={option.value}\n                variant=\"outline\"\n                size=\"sm\"\n                className={`w-6 h-6 p-0 rounded-full border-2 ${option.color} ${\n                  settings.nodeColor === option.value \n                    ? 'ring-2 ring-primary ring-offset-2' \n                    : 'hover:ring-1 hover:ring-gray-300'\n                }`}\n                onClick={() => handleColorChange(option.value)}\n                disabled={disabled}\n                title={option.label}\n              />\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":4482},"client/src/components/DataGeneratorControls.tsx":{"content":"import { useState, useEffect, useRef } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Label } from \"@/components/ui/label\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Input } from \"@/components/ui/input\";\nimport { Play, Pause, Square, RefreshCw, Settings, Database, Activity } from \"lucide-react\";\nimport { \n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport TimeRangeControls from \"./TimeRangeControls\";\nimport { apiRequest } from '@/lib/queryClient';\n\ninterface DataGeneratorControlsProps {\n  onDataUpdate?: (data: any) => void;\n  onBeforeUpdate?: () => void;\n  isActive: boolean;\n  onActiveChange: (active: boolean) => void;\n}\n\nexport default function DataGeneratorControls({ \n  onDataUpdate, \n  onBeforeUpdate,\n  isActive, \n  onActiveChange \n}: DataGeneratorControlsProps) {\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [interval, setInterval] = useState(2000);\n  const [generatorInterval, setGeneratorInterval] = useState('5000');\n  const [format, setFormat] = useState<'network' | 'opentelemetry' | 'realistic-otel'>('realistic-otel');\n  const [isLoading, setIsLoading] = useState(false);\n  const [eventCount, setEventCount] = useState(0);\n  const autoUpdateIntervalRef = useRef<number | null>(null);\n  const isGeneratingRef = useRef(false);\n  \n  // Time range controls state\n  const [timeRange, setTimeRange] = useState<{ from: Date; to: Date }>({\n    from: new Date(Date.now() - 15 * 60 * 1000), // Last 15 minutes\n    to: new Date()\n  });\n  const [refreshInterval, setRefreshInterval] = useState(5000); // 5 seconds\n  const [isAutoRefreshing, setIsAutoRefreshing] = useState(true);\n\n  // Time range control handlers\n  const handleTimeRangeChange = (range: { from: Date; to: Date }) => {\n    setTimeRange(range);\n    setTimeout(() => fetchRecentEvents(), 0);\n  };\n\n  const handleIntervalChange = (intervalMs: number) => {\n    setRefreshInterval(intervalMs);\n  };\n\n  const handleRefreshToggle = (enabled: boolean) => {\n    setIsAutoRefreshing(enabled);\n  };\n\n  const startGeneratorUpdates = () => {\n    if (autoUpdateIntervalRef.current) {\n      console.log('ðŸ”„ Clearing existing interval:', autoUpdateIntervalRef.current);\n      clearTimeout(autoUpdateIntervalRef.current);\n    }\n    \n    console.log('ðŸ”„ Starting auto-refresh every', refreshInterval, 'ms', 'isAutoRefreshing:', isAutoRefreshing);\n    \n    const runUpdate = () => {\n      console.log('ðŸ”„ Auto-refreshing data... format:', format, new Date().toISOString());\n      fetchRecentEvents(undefined, true);\n      \n      // Schedule next update\n      autoUpdateIntervalRef.current = setTimeout(runUpdate, refreshInterval) as unknown as number;\n      console.log('ðŸ”„ Next update scheduled in', refreshInterval, 'ms, timeoutId:', autoUpdateIntervalRef.current);\n    };\n    \n    // Start first update immediately  \n    runUpdate();\n  };\n\n  const stopGeneratorUpdates = () => {\n    if (autoUpdateIntervalRef.current) {\n      console.log('ðŸ”„ Stopping auto-refresh interval:', autoUpdateIntervalRef.current);\n      clearInterval(autoUpdateIntervalRef.current);\n      autoUpdateIntervalRef.current = null;\n    }\n  };\n\n  const fetchRecentEvents = async (rangeToUse?: { from: Date; to: Date }, silent = false) => {\n    if (!silent) setIsLoading(true);\n    \n    try {\n      // Always use current time for \"to\" in auto-refresh mode\n      const range = rangeToUse || {\n        from: new Date(Date.now() - 15 * 60 * 1000), // Last 15 minutes from now\n        to: new Date() // Current time\n      };\n      console.log('ðŸ“Š Querying events for 15 min range:', range.from.toISOString(), 'to', range.to.toISOString());\n      \n      let eventCount = 0;\n      if (format === 'opentelemetry' || format === 'realistic-otel') {\n        const tracesResponse = await apiRequest(\"GET\", `/api/otel/traces?limit=20`);\n        const traces = await tracesResponse.json() as any[];\n        \n        // Fetch spans for all traces\n        const allSpans: any[] = [];\n        for (const trace of traces) {\n          try {\n            const spansResponse = await apiRequest(\"GET\", `/api/otel/traces/${trace.traceId}/spans`);\n            const spans = await spansResponse.json() as any[];\n            allSpans.push(...spans);\n          } catch (error) {\n            console.warn(`Failed to fetch spans for trace ${trace.traceId}:`, error);\n          }\n        }\n        \n        onDataUpdate?.({ traces, spans: allSpans });\n        eventCount = traces.length + allSpans.length;\n      } else {\n        const eventsResponse = await apiRequest(\"GET\", '/api/network/events?limit=100');\n        const events = await eventsResponse.json() as any[];\n        console.log('ðŸ“Š Found', events.length, 'events, oldest:', events[0]?.timestamp, ', newest:', events[events.length-1]?.timestamp);\n        onDataUpdate?.(events);\n        eventCount = events.length;\n      }\n      \n      if (!silent) {\n        setEventCount(eventCount);\n      }\n    } catch (error) {\n      console.error('Failed to fetch events:', error);\n    } finally {\n      if (!silent) setIsLoading(false);\n    }\n  };\n\n  const handleStartGeneration = async () => {\n    try {\n      setIsGenerating(true);\n      onBeforeUpdate?.();\n      \n      let endpoint;\n      if (format === 'opentelemetry') {\n        endpoint = '/api/otel/start';\n      } else if (format === 'realistic-otel') {\n        endpoint = '/api/otel/realistic/start';\n      } else {\n        endpoint = '/api/network/start';\n      }\n      \n      await apiRequest(\"POST\", endpoint, { interval: parseInt(generatorInterval) });\n      \n      onActiveChange(true);\n      isGeneratingRef.current = true;\n      \n      // Initial fetch\n      fetchRecentEvents();\n    } catch (error) {\n      console.error('Failed to start generation:', error);\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const handleStopGeneration = async () => {\n    try {\n      let endpoint;\n      if (format === 'opentelemetry') {\n        endpoint = '/api/otel/stop';\n      } else if (format === 'realistic-otel') {\n        endpoint = '/api/otel/realistic/stop';\n      } else {\n        endpoint = '/api/network/stop';\n      }\n      \n      await apiRequest(\"POST\", endpoint);\n      \n      onActiveChange(false);\n      isGeneratingRef.current = false;\n      stopGeneratorUpdates();\n    } catch (error) {\n      console.error('Failed to stop generation:', error);\n    }\n  };\n\n  const handleToggleGenerator = () => {\n    if (isActive) {\n      handleStopGeneration();\n    } else {\n      handleStartGeneration();\n    }\n  };\n\n  const handleManualRefresh = () => {\n    onBeforeUpdate?.();\n    fetchRecentEvents();\n  };\n\n  // Auto-refresh effect\n  useEffect(() => {\n    console.log('ðŸ”„ useEffect triggered: isAutoRefreshing=', isAutoRefreshing, 'refreshInterval=', refreshInterval, 'isActive=', isActive, 'current interval:', autoUpdateIntervalRef.current);\n    if (isAutoRefreshing && isActive) {\n      startGeneratorUpdates();\n    } else {\n      stopGeneratorUpdates();\n    }\n\n    return () => {\n      console.log('ðŸ”„ useEffect cleanup called');\n      stopGeneratorUpdates();\n    };\n  }, [isAutoRefreshing, refreshInterval, isActive]);\n\n  // Initialize auto-refresh on mount\n  useEffect(() => {\n    // Auto-enable refresh after component mount\n    const initTimer = setTimeout(() => {\n      console.log('ðŸ”„ Auto-enabling refresh on mount, isActive:', isActive);\n      // Force enable auto-refresh regardless of isActive\n      console.log('ðŸ”„ Forcing auto-refresh to true');\n      setIsAutoRefreshing(true);\n    }, 1000);\n    \n    return () => clearTimeout(initTimer);\n  }, []);\n\n  // Force auto-refresh when generator becomes active\n  useEffect(() => {\n    if (isActive && !isAutoRefreshing) {\n      console.log('ðŸ”„ Generator is active, enabling auto-refresh');\n      setIsAutoRefreshing(true);\n    }\n  }, [isActive, isAutoRefreshing]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopGeneratorUpdates();\n    };\n  }, []);\n\n  return (\n    <div className=\"border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60\">\n      <div className=\"container flex h-14 items-center gap-4\">\n        <div className=\"flex items-center gap-2\">\n          <Button\n            variant={isActive ? \"destructive\" : \"default\"}\n            size=\"sm\"\n            onClick={handleToggleGenerator}\n            disabled={isGenerating}\n            className=\"flex items-center gap-2\"\n          >\n            {isActive ? (\n              <>\n                <Square className=\"h-4 w-4\" />\n                ÐžÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ\n              </>\n            ) : (\n              <>\n                <Play className=\"h-4 w-4\" />\n                Ð—Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ\n              </>\n            )}\n          </Button>\n\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            onClick={handleManualRefresh}\n            disabled={isLoading}\n            className=\"flex items-center gap-2\"\n          >\n            <RefreshCw className={`h-4 w-4 ${isLoading ? 'animate-spin' : ''}`} />\n            ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ\n          </Button>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <Label htmlFor=\"format-select\" className=\"text-sm font-medium\">\n            Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚:\n          </Label>\n          <Select value={format} onValueChange={(value: 'network' | 'opentelemetry' | 'realistic-otel') => setFormat(value)}>\n            <SelectTrigger className=\"w-40\" id=\"format-select\">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"network\">\n                <div className=\"flex items-center gap-2\">\n                  <Database className=\"h-4 w-4\" />\n                  Network Events\n                </div>\n              </SelectItem>\n              <SelectItem value=\"opentelemetry\">\n                <div className=\"flex items-center gap-2\">\n                  <Activity className=\"h-4 w-4\" />\n                  OpenTelemetry\n                </div>\n              </SelectItem>\n              <SelectItem value=\"realistic-otel\">\n                <div className=\"flex items-center gap-2\">\n                  <Activity className=\"h-4 w-4\" />\n                  Realistic Gateway Flow\n                </div>\n              </SelectItem>\n            </SelectContent>\n          </Select>\n        </div>\n\n        <Popover>\n          <PopoverTrigger asChild>\n            <Button variant=\"outline\" size=\"sm\">\n              <Settings className=\"h-4 w-4\" />\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-80\" align=\"start\">\n            <div className=\"grid gap-4\">\n              <div className=\"space-y-2\">\n                <h4 className=\"font-medium leading-none\">ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°</h4>\n                <p className=\"text-sm text-muted-foreground\">\n                  ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹Ñ‚Ðµ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…\n                </p>\n              </div>\n              <div className=\"grid gap-2\">\n                <Label htmlFor=\"generator-interval\">Ð˜Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ (Ð¼Ñ)</Label>\n                <Select value={generatorInterval} onValueChange={setGeneratorInterval}>\n                  <SelectTrigger id=\"generator-interval\">\n                    <SelectValue />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"1000\">1 ÑÐµÐºÑƒÐ½Ð´Ð°</SelectItem>\n                    <SelectItem value=\"2000\">2 ÑÐµÐºÑƒÐ½Ð´Ñ‹</SelectItem>\n                    <SelectItem value=\"5000\">5 ÑÐµÐºÑƒÐ½Ð´</SelectItem>\n                    <SelectItem value=\"10000\">10 ÑÐµÐºÑƒÐ½Ð´</SelectItem>\n                  </SelectContent>\n                </Select>\n              </div>\n            </div>\n          </PopoverContent>\n        </Popover>\n\n        <div className=\"flex items-center gap-2\">\n          {isActive && (\n            <Badge variant=\"outline\" className=\"flex items-center gap-1\">\n              <div className=\"h-2 w-2 bg-green-500 rounded-full animate-pulse\" />\n              ÐÐºÑ‚Ð¸Ð²ÐµÐ½\n            </Badge>\n          )}\n          \n          {eventCount > 0 && (\n            <Badge variant=\"secondary\">\n              {eventCount} ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ð¹\n            </Badge>\n          )}\n        </div>\n\n        <div className=\"ml-auto\">\n          <TimeRangeControls\n            onTimeRangeChange={handleTimeRangeChange}\n            onIntervalChange={handleIntervalChange}\n            onRefreshToggle={handleRefreshToggle}\n            isRefreshing={isAutoRefreshing}\n            currentInterval={refreshInterval}\n          />\n        </div>\n      </div>\n    </div>\n  );\n}","size_bytes":12923},"client/src/components/Diagram3D.tsx":{"content":"import { useEffect, useRef, useState, useCallback } from \"react\";\nimport * as THREE from \"three\";\nimport { Computer } from \"lucide-react\";\nimport ServiceMetricsPopup from \"./ServiceMetricsPopup\";\nimport type { DiagramData, DiagramSettings } from \"@/types/diagram\";\nimport type { ServiceMetrics } from \"@shared/schema\";\n\n// Import refactored modules\nimport { \n  aggregateInterTenantConnections, \n  createMagistralPath, \n  calculateMagistralOffset, \n  getMagistralColor,\n  calculateMagistralThickness,\n  createDirectionalArrow,\n  calculateMagistralEndpoints\n} from \"./diagram3d/magistral\";\nimport { \n  calculateObstavoidingPath, \n  calculateDetourPath, \n  calculatePathLength,\n  getLineIntersection2D,\n  getHighwayPriority,\n  detectHighwayIntersections\n} from \"./diagram3d/pathfinding\";\nimport { \n  updateSceneIncrementally, \n  createOrientationCube,\n  getCachedMaterial,\n  createArrowSystem\n} from \"./diagram3d/scene-utils\";\nimport type { MagistralConnection, CameraState, Obstacle } from \"./diagram3d/types\";\n\n// Ð’ÑÐµ ÑƒÑ‚Ð¸Ð»Ð¸Ñ‚Ð°Ñ€Ð½Ñ‹Ðµ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð¿ÐµÑ€ÐµÐ½ÐµÑÐµÐ½Ñ‹ Ð² Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Ð´Ð»Ñ Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ð¾Ñ€Ð³Ð°Ð½Ð¸Ð·Ð°Ñ†Ð¸Ð¸ ÐºÐ¾Ð´Ð°\n\ninterface Diagram3DProps {\n  data: DiagramData | null;\n  settings: DiagramSettings;\n  onApplyLayout?: () => void;\n  selectedTraceId?: string | null;\n  onLODUpdate?: (lodLevel: 'high' | 'medium' | 'low', relativeDistance: number, serviceCount: number) => void;\n}\n\nexport default function Diagram3D({ data, settings, selectedTraceId, onLODUpdate }: Diagram3DProps) {\n  const mountRef = useRef<HTMLDivElement>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const frameRef = useRef<number | null>(null);\n  \n  // Store camera state to preserve position during updates\n  const cameraStateRef = useRef<{\n    rotationX: number;\n    rotationY: number;\n    distance: number;\n    panX: number;\n    panY: number;\n  } | null>(null);\n  \n  // State for hover tooltip\n  const [tooltip, setTooltip] = useState<{\n    visible: boolean;\n    x: number;\n    y: number;\n    statusCounts: Record<string, number>;\n    sourceLabel: string;\n    targetLabel: string;\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    statusCounts: {},\n    sourceLabel: '',\n    targetLabel: ''\n  });\n\n  // State for legend visibility\n  const [showLegend, setShowLegend] = useState(false);\n\n  // State for service metrics popup\n  const [metricsPopup, setMetricsPopup] = useState<{\n    visible: boolean;\n    serviceName: string;\n    metrics: ServiceMetrics | null;\n    position: { x: number; y: number };\n  }>({\n    visible: false,\n    serviceName: '',\n    metrics: null,\n    position: { x: 0, y: 0 }\n  });\n\n  // Store last spacing values to detect changes\n  const lastSpacingRef = useRef<{\n    nodeSpacing: number;\n    clusterSpacing: number;\n  } | null>(null);\n\n  // Store service metrics\n  const [serviceMetrics, setServiceMetrics] = useState<Map<string, ServiceMetrics>>(new Map());\n\n  // Fetch service metrics\n  const fetchServiceMetrics = useCallback(async () => {\n    try {\n      const response = await fetch('/api/metrics/latest');\n      if (response.ok) {\n        const metrics: ServiceMetrics[] = await response.json();\n        const metricsMap = new Map();\n        metrics.forEach(metric => {\n          metricsMap.set(metric.serviceName, metric);\n        });\n        setServiceMetrics(metricsMap);\n      }\n    } catch (error) {\n      console.error('Failed to fetch service metrics:', error);\n    }\n  }, []);\n\n  // Load metrics on mount and periodically refresh\n  useEffect(() => {\n    fetchServiceMetrics();\n    const interval = setInterval(fetchServiceMetrics, 10000); // Refresh every 10 seconds\n    return () => clearInterval(interval);\n  }, [fetchServiceMetrics]);\n\n  // Initialize scene and camera only once\n  useEffect(() => {\n    if (!mountRef.current) return;\n\n    // Scene setup with professional background\n    const scene = new THREE.Scene();\n    // Modern gradient background (dark professional theme)\n    scene.background = new THREE.Color(0x0a0a15);\n    sceneRef.current = scene;\n    \n    // Disable fog to prevent objects disappearing at distance\n    scene.fog = null;\n\n    // Camera setup with extended far plane for extreme zoom\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      mountRef.current.clientWidth / mountRef.current.clientHeight,\n      0.1,\n      10000 // Extended far plane to prevent clipping at distance\n    );\n    \n    // Only set default position if no saved state\n    if (!cameraStateRef.current) {\n      camera.position.set(0, 0, 500);\n    }\n    \n    cameraRef.current = camera;\n\n    // Professional renderer setup\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true,\n      alpha: true,\n      powerPreference: \"high-performance\"\n    });\n    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.shadowMap.enabled = false; // Disable shadows to prevent darkening\n    renderer.outputColorSpace = THREE.SRGBColorSpace;\n    renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    renderer.toneMappingExposure = 2.5 * (settings.brightness || 1.0); // Adjustable brightness exposure\n    renderer.autoClear = false;\n    rendererRef.current = renderer;\n    mountRef.current.appendChild(renderer.domElement);\n\n    // Handle resize\n    const handleResize = () => {\n      if (mountRef.current && camera && renderer) {\n        camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      \n      if (mountRef.current && renderer && mountRef.current.contains(renderer.domElement)) {\n        mountRef.current.removeChild(renderer.domElement);\n      }\n      \n      renderer?.dispose();\n    };\n  }, []); // Only run once on mount\n\n  // Store previous data for incremental updates\n  const prevDataRef = useRef<DiagramData | null>(null);\n  const sceneObjectsRef = useRef<Map<string, THREE.Object3D>>(new Map());\n  const lastLODLevelRef = useRef<'high' | 'medium' | 'low' | null>(null);\n  \n  // Material cache to prevent WebGL shader issues\n  const materialCacheRef = useRef<Map<string, THREE.Material>>(new Map());\n  \n  // Function to get cached material\n  const getCachedMaterial = (color: number, type: 'basic' | 'line' = 'basic') => {\n    const key = `${type}-${color}`;\n    let material = materialCacheRef.current.get(key);\n    \n    if (!material) {\n      if (type === 'line') {\n        material = new THREE.LineBasicMaterial({ color });\n      } else {\n        material = new THREE.MeshBasicMaterial({ color });\n      }\n      materialCacheRef.current.set(key, material);\n    }\n    \n    return material;\n  };\n\n  // Function to perform incremental scene updates\n  const updateSceneIncrementally = (\n    scene: THREE.Scene, \n    prevData: DiagramData, \n    newData: DiagramData, \n    sceneObjects: Map<string, THREE.Object3D>\n  ) => {\n    // Create sets for comparison\n    const prevNodeIds = new Set(prevData.nodes.map(n => n.id));\n    const newNodeIds = new Set(newData.nodes.map(n => n.id));\n    const prevEdgeIds = new Set(prevData.edges.map(e => e.id));\n    const newEdgeIds = new Set(newData.edges.map(e => e.id));\n\n    // Remove disappeared nodes and edges\n    prevNodeIds.forEach(nodeId => {\n      if (!newNodeIds.has(nodeId)) {\n        const cylinderKey = `cylinder-${nodeId}`;\n        const segmentKey = `segment-${nodeId}`;\n        \n        [cylinderKey, segmentKey].forEach(key => {\n          const object = sceneObjects.get(key);\n          if (object) {\n            scene.remove(object);\n            sceneObjects.delete(key);\n            // Dispose geometry and materials\n            if (object instanceof THREE.Mesh) {\n              object.geometry.dispose();\n              if (object.material instanceof THREE.Material) {\n                object.material.dispose();\n              }\n            }\n          }\n        });\n      }\n    });\n\n    prevEdgeIds.forEach(edgeId => {\n      if (!newEdgeIds.has(edgeId)) {\n        const arrowKey = `arrow-${edgeId}`;\n        const object = sceneObjects.get(arrowKey);\n        if (object) {\n          scene.remove(object);\n          sceneObjects.delete(arrowKey);\n          // Dispose geometry and materials\n          object.traverse((child) => {\n            if (child instanceof THREE.Mesh) {\n              child.geometry.dispose();\n              if (child.material instanceof THREE.Material) {\n                child.material.dispose();\n              }\n            }\n          });\n        }\n      }\n    });\n\n    // For new nodes and edges, we'll let the main rendering code handle them\n    // by only processing new items in the creation loops\n    console.log(`Incremental update: Removed ${prevNodeIds.size - newNodeIds.size} nodes, ${prevEdgeIds.size - newEdgeIds.size} edges`);\n  };\n\n  // Update scene data when data changes  \n  useEffect(() => {\n    console.log('ðŸ”„ useEffect triggered with data:', data ? `${data.edges.length} edges` : 'null', 'Data object ID:', data ? Math.random().toString(36).substr(2, 9) : 'null');\n    console.log('ðŸ”„ SPACING SETTINGS USEEFFECT TRIGGERED - this should show when sliders change');\n    console.log('ðŸ” USEEFFECT DEBUG:', {\n      settingsValues: {\n        nodeSpacing: settings.nodeSpacing,\n        clusterSpacing: settings.clusterSpacing,\n        clusterSpacingY: settings.clusterSpacingY,\n        brightness: settings.brightness\n      },\n      hasSettings: !!settings,\n      settingsObject: settings\n    });\n    if (!sceneRef.current || !rendererRef.current || !cameraRef.current) return;\n    \n    console.log('ðŸ”„ Scene update starting:', {\n      sceneChildren: sceneRef.current.children.length,\n      cacheSize: sceneObjectsRef.current.size,\n      nodeCount: data ? data.nodes.length : 0,\n      edgeCount: data ? data.edges.length : 0,\n      firstFewCacheKeys: Array.from(sceneObjectsRef.current.keys()).slice(0, 5)\n    });\n    \n    // Don't automatically clear cache - let spacing-aware logic handle it\n    \n    // Only clear cache when data is truly null, never on data changes\n    if (!data) {\n      console.log('ðŸ§¹ Clearing cache for null data only', {\n        cacheSizeBefore: sceneObjectsRef.current.size,\n        hasData: !!data\n      });\n      sceneObjectsRef.current.clear();\n    }\n    \n    // Handle empty data by clearing the scene\n    if (!data) {\n      console.log('ðŸ’¥ Clearing scene for empty data');\n      const scene = sceneRef.current;\n      \n      // Force remove all objects from scene, but keep lights and essential objects\n      const toRemove = scene.children.filter(child => \n        !child.userData.isLight && \n        !child.userData.isAxis && \n        !child.userData.isOrientationCube &&\n        !child.userData.isTenantSphere\n      );\n      \n      toRemove.forEach(child => {\n        scene.remove(child);\n        // Dispose of geometries and materials to free memory\n        if (child.type === 'Mesh' || child.type === 'Group') {\n          child.traverse((object: any) => {\n            if (object.geometry) object.geometry.dispose();\n            if (object.material) {\n              if (Array.isArray(object.material)) {\n                object.material.forEach((mat: any) => mat.dispose());\n              } else {\n                object.material.dispose();\n              }\n            }\n          });\n        }\n      });\n      \n      sceneObjectsRef.current.clear();\n      prevDataRef.current = null;\n      \n      // Stop animation loop\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n        frameRef.current = null;\n      }\n      \n      console.log('ðŸ’¥ Scene fully cleared, children count:', scene.children.length);\n      \n      // Force immediate render to show empty scene\n      const renderer = rendererRef.current;\n      const camera = cameraRef.current;\n      renderer.render(scene, camera);\n      return;\n    }\n\n    const scene = sceneRef.current;\n    const renderer = rendererRef.current;\n    const camera = cameraRef.current;\n    const prevData = prevDataRef.current;\n    const sceneObjects = sceneObjectsRef.current;\n    \n    // Calculate LOD level based on service count and relative camera distance\n    const serviceCount = data.nodes.filter(node => node.service).length;\n    const currentCameraDistance = camera.position.length();\n    \n    // Track spacing changes separately from data changes\n    const currentSpacing = {\n      nodeSpacing: settings.nodeSpacing || 120,\n      clusterSpacing: settings.clusterSpacing || 600,\n      clusterSpacingY: settings.clusterSpacingY || 300\n    };\n    \n    console.log('ðŸ” SPACING DEBUG:', {\n      currentSpacing,\n      lastSpacing: lastSpacingRef.current,\n      hasLastSpacing: !!lastSpacingRef.current\n    });\n    \n    const spacingChanged = !lastSpacingRef.current || \n        lastSpacingRef.current.nodeSpacing !== currentSpacing.nodeSpacing ||\n        lastSpacingRef.current.clusterSpacing !== currentSpacing.clusterSpacing ||\n        lastSpacingRef.current.clusterSpacingY !== currentSpacing.clusterSpacingY;\n        \n    console.log('ðŸ” SPACING CHANGE DETECTION:', {\n      spacingChanged,\n      nodeSpacingChanged: lastSpacingRef.current ? lastSpacingRef.current.nodeSpacing !== currentSpacing.nodeSpacing : 'no prev',\n      clusterSpacingChanged: lastSpacingRef.current ? lastSpacingRef.current.clusterSpacing !== currentSpacing.clusterSpacing : 'no prev',\n      clusterSpacingYChanged: lastSpacingRef.current ? lastSpacingRef.current.clusterSpacingY !== currentSpacing.clusterSpacingY : 'no prev'\n    });\n    \n    if (spacingChanged) {\n      console.log('ðŸ“ SPACING CHANGED DETECTED - FORCING FULL CACHE CLEAR:', {\n        previous: lastSpacingRef.current,\n        current: currentSpacing,\n        sceneObjectsSize: sceneObjectsRef.current.size,\n        sceneChildrenCount: scene.children.length\n      });\n      console.log('ðŸ“ This will trigger comprehensive magistral clearing...');\n      \n      // IMMEDIATE CACHE CLEAR FOR SPACING CHANGES\n      console.log('ðŸ§¹ EMERGENCY: Clearing cache for spacing change');\n      \n      // CLEAR ALL OBJECTS INCLUDING MAGISTRALS AND BRANCHES - same as cylinder/sphere logic\n      console.log('ðŸ§¹ [SPACING] Cache size before clear:', sceneObjectsRef.current.size);\n      const branchObjectsToRemove = Array.from(sceneObjectsRef.current.keys()).filter(k => k.includes('branch'));\n      console.log('ðŸ§¹ [SPACING] Branch objects to clear:', branchObjectsToRemove);\n      \n      // EXPLICITLY REMOVE BRANCH OBJECTS FROM SCENE BEFORE CACHE CLEAR\n      branchObjectsToRemove.forEach(branchKey => {\n        const branchObject = sceneObjectsRef.current.get(branchKey);\n        if (branchObject) {\n          console.log('ðŸ§¹ [SPACING] Explicitly removing branch from scene:', branchKey);\n          scene.remove(branchObject);\n        }\n      });\n      \n      sceneObjectsRef.current.clear();\n      console.log('ðŸ§¹ [SPACING] Cache size after clear:', sceneObjectsRef.current.size);\n      \n      // FORCE RESET PREVIOUS DATA to ensure full rebuild\n      prevDataRef.current = null;\n      console.log('ðŸ§¹ [SPACING FIX] Reset prevDataRef to null to force complete rebuild - ALL objects will be recreated');\n      \n      // Clear scene completely\n      scene.traverse((child) => {\n        if (child instanceof THREE.Mesh) {\n          child.geometry?.dispose();\n          if (Array.isArray(child.material)) {\n            child.material.forEach(mat => mat.dispose());\n          } else {\n            child.material?.dispose();\n          }\n        }\n      });\n      \n      // Keep only lights, axes, and orientation cube\n      const toRemove = scene.children.filter(child => \n        !child.userData.isLight && \n        !child.userData.isAxis && \n        !child.userData.isOrientationCube\n      );\n      toRemove.forEach(child => scene.remove(child));\n      \n      console.log('âœ… Emergency cache clearing complete');\n      lastSpacingRef.current = currentSpacing;\n    }\n    \n    console.log('ðŸ” LOD Debug Info:', {\n      clusterSpacing: currentSpacing.clusterSpacing,\n      nodeSpacing: currentSpacing.nodeSpacing,\n      serviceCount,\n      currentCameraDistance: Math.round(currentCameraDistance)\n    });\n    \n    // Calculate scheme bounds to determine relative distance\n    const schemeBounds = {\n      minX: Math.min(...data.nodes.map(n => (n as any).x3d || 0)),\n      maxX: Math.max(...data.nodes.map(n => (n as any).x3d || 0)),\n      minY: Math.min(...data.nodes.map(n => (n as any).y3d || 0)),\n      maxY: Math.max(...data.nodes.map(n => (n as any).y3d || 0)),\n      minZ: Math.min(...data.nodes.map(n => (n as any).z3d || 0)),\n      maxZ: Math.max(...data.nodes.map(n => (n as any).z3d || 0))\n    };\n    \n    const schemeWidth = Math.max(schemeBounds.maxX - schemeBounds.minX, 200);\n    const schemeHeight = Math.max(schemeBounds.maxY - schemeBounds.minY, 200);\n    const schemeDepth = Math.max(schemeBounds.maxZ - schemeBounds.minZ, 200);\n    const schemeDiagonal = Math.sqrt(schemeWidth * schemeWidth + schemeHeight * schemeHeight + schemeDepth * schemeDepth);\n    \n    // Calculate relative distance as ratio to scheme size\n    const relativeDistance = currentCameraDistance / schemeDiagonal;\n    \n    // Dynamic LOD thresholds based on user's actual zoom range\n    // Calculate typical zoom range: minimum distance (closest zoom) and maximum practical distance\n    const minDistanceRatio = 0.05; // Closest reasonable zoom (5% of diagram size)\n    const maxDistanceRatio = 1.5;  // Furthest practical zoom (150% of diagram size)\n    const zoomRangeRatio = maxDistanceRatio - minDistanceRatio;\n    \n    // Calculate dynamic thresholds that divide the user's actual zoom range into 3 equal parts\n    const mediumThreshold = minDistanceRatio + zoomRangeRatio * 0.33; // First 33% = 0.53x\n    const lowThreshold = minDistanceRatio + zoomRangeRatio * 0.67;    // First 67% = 1.02x\n    \n    // Apply dynamic LOD thresholds - distance takes priority over service count\n    let lodLevel: 'high' | 'medium' | 'low' = 'high';\n    \n    // Distance based LOD (primary factor)\n    console.log('ðŸ” LOD Logic Debug:', {\n      relativeDistance: relativeDistance.toFixed(3),\n      mediumThreshold: mediumThreshold.toFixed(3),\n      lowThreshold: lowThreshold.toFixed(3),\n      'relativeDistance > lowThreshold': relativeDistance > lowThreshold,\n      'relativeDistance > mediumThreshold': relativeDistance > mediumThreshold,\n      serviceCount\n    });\n    \n    if (relativeDistance > lowThreshold) {\n      lodLevel = 'low';\n      console.log('ðŸ” LOD Decision: LOW (distance > lowThreshold)');\n    } else if (relativeDistance > mediumThreshold) {\n      lodLevel = 'medium';  \n      console.log('ðŸ” LOD Decision: MEDIUM (distance > mediumThreshold)');\n    } else {\n      lodLevel = 'high'; // Close distance = high detail regardless of service count\n      console.log('ðŸ” LOD Decision: HIGH (close distance)');\n    }\n    \n    // Service count override only for extreme cases\n    if (serviceCount > 100) {\n      lodLevel = 'low'; // Force low for very large service counts\n      console.log('ðŸ” LOD Override: LOW (serviceCount > 100)');\n    }\n    \n    // LOD calculation completed - debug output in animation loop only\n\n    // Update parent component with LOD data\n    if (onLODUpdate) {\n      onLODUpdate(lodLevel, relativeDistance, serviceCount);\n    }\n\n    // FORCE CLEAR ALL BRANCH CONNECTIONS BEFORE ANY RENDERING (universal cleanup like cylinders/spheres)\n    console.log('ðŸ§¹ UNIVERSAL BRANCH CLEANUP: Clearing all existing branch connections at start of every render');\n    const universalBranchKeys = Array.from(sceneObjectsRef.current.keys()).filter(key => \n      key.includes('branch-in-') || key.includes('branch-out-')\n    );\n    console.log('ðŸ§¹ Found branch objects for universal cleanup:', universalBranchKeys);\n    \n    universalBranchKeys.forEach(branchKey => {\n      const branchObject = sceneObjectsRef.current.get(branchKey);\n      if (branchObject) {\n        scene.remove(branchObject);\n        sceneObjectsRef.current.delete(branchKey);\n      }\n    });\n    console.log('ðŸ§¹ Universal branch cleanup complete - all branch connections cleared before render');\n\n    // First render - clear everything\n    console.log('ðŸŽ¬ RENDER CYCLE START:', { \n      hasPrevData: !!prevData, \n      prevDataEdges: prevData?.edges?.length || 0,\n      newDataEdges: data.edges.length,\n      sceneObjectsCount: sceneObjects.size,\n      lodLevel: lodLevel,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Log data structure for debugging\n    if (data.edges.length > 0) {\n      console.log('ðŸ” SAMPLE EDGES:', data.edges.slice(0, 3).map(e => ({\n        source: typeof e.source === 'string' ? e.source : e.source.id,\n        target: typeof e.target === 'string' ? e.target : e.target.id,\n        hasSourceNode: !!data.nodes.find(n => n.id === (typeof e.source === 'string' ? e.source : e.source.id)),\n        hasTargetNode: !!data.nodes.find(n => n.id === (typeof e.target === 'string' ? e.target : e.target.id))\n      })));\n    }\n    \n    console.log('prevDataRef.current before logic:', prevDataRef.current ? `${prevDataRef.current.edges.length} edges` : 'null');\n    \n    // Skip incremental updates to reduce complexity\n    // if (prevData && sceneObjects.size > 0) {\n    //   console.log('ðŸ”„ Using incremental update');\n    //   updateSceneIncrementally(scene, prevData, data, sceneObjects);\n    //   prevDataRef.current = data;\n    // }\n    \n    // Simple approach: never clear the cache, just reuse existing objects\n    console.log('Smart caching: scene objects count:', sceneObjects.size);\n    console.log('Scene children count:', scene.children.length);\n    console.log('Scene children types:', scene.children.map(c => c.type));\n    \n    // Check if data has actually changed (exclude spacing-only changes)\n    // Don't consider !prevData as data change if we have cached objects (HMR restart case)\n    const actualDataChanged = prevData && (\n                          prevData.nodes.length !== data.nodes.length || \n                          prevData.edges.length !== data.edges.length ||\n                          // Deep compare node and edge IDs to detect actual changes\n                          JSON.stringify(prevData.nodes.map(n => n.id).sort()) !== JSON.stringify(data.nodes.map(n => n.id).sort()) ||\n                          JSON.stringify(prevData.edges.map(e => e.id).sort()) !== JSON.stringify(data.edges.map(e => e.id).sort())\n                        );\n    \n    // Only consider it data change if we have no cache OR actual data differs\n    const dataHasChanged = (sceneObjectsRef.current.size === 0 && !prevData) || !!actualDataChanged;\n    \n    // If only spacing changed but data is the same, don't rebuild everything\n    const onlySpacingChanged = spacingChanged && !dataHasChanged;\n    \n    console.log('ðŸ” Data change analysis:', {\n      hasPrevData: !!prevData,\n      nodeCountChanged: prevData ? prevData.nodes.length !== data.nodes.length : 'no prev data',\n      edgeCountChanged: prevData ? prevData.edges.length !== data.edges.length : 'no prev data',\n      dataHasChanged,\n      spacingChanged,\n      onlySpacingChanged,\n      sceneObjectsSize: sceneObjectsRef.current.size,\n      sceneChildrenCount: scene.children.length\n    });\n    \n    // For spacing changes, clear cache and force full rebuild\n    if (onlySpacingChanged && sceneObjects.size > 0) {\n      console.log('ðŸ”„ Spacing change detected - forcing full rebuild');\n      \n      // Clear all cached objects\n      sceneObjects.clear();\n      sceneObjectsRef.current.clear();\n      \n      // Clear scene completely\n      scene.traverse((child) => {\n        if (child instanceof THREE.Mesh) {\n          child.geometry?.dispose();\n          if (Array.isArray(child.material)) {\n            child.material.forEach(mat => mat.dispose());\n          } else {\n            child.material?.dispose();\n          }\n        }\n      });\n      \n      // Keep only lights, axes, and orientation cube\n      const toRemove = scene.children.filter(child => \n        !child.userData.isLight && \n        !child.userData.isAxis && \n        !child.userData.isOrientationCube\n      );\n      toRemove.forEach(child => scene.remove(child));\n      \n      console.log('âœ… Cache cleared, forcing full rebuild with new spacing');\n      // Don't return - continue to full rebuild\n    }\n    \n    // If scene is empty but cache has objects, only restore if data hasn't changed\n    if (scene.children.length === 0 && sceneObjects.size > 0 && !dataHasChanged) {\n      console.log('ðŸ”§ Re-adding cached objects to empty scene (data unchanged)');\n      sceneObjects.forEach((obj, key) => {\n        // Restore protected userData for cylinders\n        if (key.startsWith('endpoint-') && obj.userData && Object.keys(obj.userData).length === 0) {\n          const endpointId = key.replace('endpoint-', '');\n          const matchingNode = data.nodes.find(node => node.id === endpointId);\n          \n          if (matchingNode && obj instanceof THREE.Mesh) {\n            // Get the actual current color from the material\n            const material = obj.material as THREE.MeshBasicMaterial;\n            const currentColor = material.color.getHex();\n            \n            const protectedUserData = {\n              nodeId: matchingNode.id,\n              isNode: true,\n              isEndpoint: true,\n              serviceName: matchingNode.service,\n              tenant: matchingNode.tenant,\n              originalColor: currentColor // Use actual material color\n            };\n            \n            Object.defineProperty(obj, 'userData', {\n              get: () => protectedUserData,\n              set: (newValue) => {\n                console.error('ðŸš¨ userData overwrite attempt during restoration!', {\n                  endpointId: matchingNode.id,\n                  newData: JSON.stringify(newValue)\n                });\n                Object.assign(protectedUserData, newValue);\n              },\n              configurable: false,\n              enumerable: true\n            });\n            \n            console.log('ðŸ”§ Restored protected userData for:', endpointId);\n          }\n        }\n        scene.add(obj);\n      });\n      prevDataRef.current = data;\n      return;\n    }\n    \n    // Skip incremental updates - they cause performance issues\n    if (dataHasChanged) {\n      console.log('âš ï¸ Data change detected - skipping incremental update');\n      console.log('ðŸ’¡ Will use full scene rebuild for better stability');\n    }\n    \n    // If scene has too many objects (duplication), clear and rebuild from cache\n    if (scene.children.length > sceneObjects.size * 2) {\n      console.log('ðŸ§¹ Clearing duplicated scene, rebuilding from cache');\n      \n      // Dispose old materials and geometries to prevent WebGL issues\n      scene.traverse((child) => {\n        if (child instanceof THREE.Mesh) {\n          child.geometry?.dispose();\n          if (Array.isArray(child.material)) {\n            child.material.forEach(mat => mat.dispose());\n          } else {\n            child.material?.dispose();\n          }\n        }\n      });\n      \n      // Selective clear - keep tenant spheres, lights, axes during duplication cleanup\n      const toRemove = scene.children.filter(child => \n        !child.userData.isLight && \n        !child.userData.isAxis && \n        !child.userData.isOrientationCube &&\n        !child.userData.isTenantSphere\n      );\n      toRemove.forEach(child => scene.remove(child));\n      \n      sceneObjects.forEach((obj, key) => {\n        // Restore protected userData for cylinders during duplication cleanup\n        if (key.startsWith('endpoint-') && obj.userData && Object.keys(obj.userData).length === 0) {\n          const endpointId = key.replace('endpoint-', '');\n          const matchingNode = data.nodes.find(node => node.id === endpointId);\n          \n          if (matchingNode) {\n            const protectedUserData = {\n              nodeId: matchingNode.id,\n              isNode: true,\n              isEndpoint: true,\n              serviceName: matchingNode.service,\n              tenant: matchingNode.tenant,\n              originalColor: 0xFFFFFF\n            };\n            \n            Object.defineProperty(obj, 'userData', {\n              get: () => protectedUserData,\n              set: (newValue) => {\n                console.error('ðŸš¨ userData overwrite during deduplication!', {\n                  endpointId: matchingNode.id,\n                  newData: JSON.stringify(newValue)\n                });\n                Object.assign(protectedUserData, newValue);\n              },\n              configurable: false,\n              enumerable: true\n            });\n            \n            console.log('ðŸ”§ Restored protected userData during cleanup for:', endpointId);\n          }\n        }\n        scene.add(obj);\n      });\n      prevDataRef.current = data;\n      return;\n    }\n\n    // Raycaster for hover detection with wider detection area\n    const raycaster = new THREE.Raycaster();\n    raycaster.params.Line.threshold = 10; // Increase line detection threshold\n    const mouseVector = new THREE.Vector2();\n    \n    // Function to update mouse coordinates and check for arrow hover\n    const updateMouseAndCheckHover = (event: MouseEvent) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      mouseVector.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      mouseVector.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      \n      raycaster.setFromCamera(mouseVector, camera);\n      const intersects = raycaster.intersectObjects(scene.children, true);\n      \n      let hoveredArrow = null;\n      for (const intersect of intersects) {\n        if (intersect.object.userData?.isArrow) {\n          hoveredArrow = intersect.object;\n          break;\n        }\n      }\n      \n      if (hoveredArrow && hoveredArrow.userData.edgeData) {\n        const edgeData = hoveredArrow.userData.edgeData;\n        const rect = renderer.domElement.getBoundingClientRect();\n        setTooltip({\n          visible: true,\n          x: event.clientX - rect.left,\n          y: event.clientY - rect.top,\n          statusCounts: edgeData.statusCounts || {},\n          sourceLabel: hoveredArrow.userData.sourceLabel || '',\n          targetLabel: hoveredArrow.userData.targetLabel || ''\n        });\n        // Change cursor to pointer when hovering over arrows\n        renderer.domElement.style.cursor = 'pointer';\n      } else {\n        setTooltip(prev => ({ ...prev, visible: false }));\n        // Reset cursor to grab when not hovering over arrows\n        renderer.domElement.style.cursor = 'grab';\n      }\n    };\n\n    // Create orientation cube in separate scene\n    const cubeScene = new THREE.Scene();\n    const cubeCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);\n    // Position camera to match model's coordinate system\n    // Model shows: X forward (to viewer), Y up, Z left\n    // So camera should be at positive Z looking at origin\n    cubeCamera.position.set(0, 0, 3);\n    cubeCamera.lookAt(0, 0, 0);\n    cubeCamera.up.set(0, 1, 0); // Y is up\n\n    // Create orientation cube at origin first\n    const orientationCube = createOrientationCube();\n    \n    // Position cube group to show in corner while keeping axes aligned with model\n    orientationCube.group.position.set(0, 0, 0); // Keep at center initially for axis alignment\n    \n    cubeScene.add(orientationCube.group);\n    \n    // Add lighting for the cube\n    const cubeLight = new THREE.DirectionalLight(0xffffff, 1);\n    cubeLight.position.set(1, 1, 1);\n    cubeScene.add(cubeLight);\n    const cubeAmbientLight = new THREE.AmbientLight(0x404040, 0.5);\n    cubeScene.add(cubeAmbientLight);\n\n    // Add coordinate axes vectors at origin (0,0,0)\n    const axesGroup = new THREE.Group();\n    \n    // X-axis (red)\n    const xAxisGeometry = new THREE.CylinderGeometry(2, 2, 60, 8);\n    const xAxisMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n    const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);\n    xAxis.rotation.z = -Math.PI / 2;\n    xAxis.position.x = 30;\n    axesGroup.add(xAxis);\n    \n    // X-axis arrow\n    const xArrowGeometry = new THREE.ConeGeometry(6, 20, 8);\n    const xArrow = new THREE.Mesh(xArrowGeometry, xAxisMaterial);\n    xArrow.rotation.z = -Math.PI / 2;\n    xArrow.position.x = 70;\n    axesGroup.add(xArrow);\n    \n    // Y-axis (green) \n    const yAxisGeometry = new THREE.CylinderGeometry(2, 2, 60, 8);\n    const yAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n    const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);\n    yAxis.position.y = 30;\n    axesGroup.add(yAxis);\n    \n    // Y-axis arrow\n    const yArrowGeometry = new THREE.ConeGeometry(6, 20, 8);\n    const yArrow = new THREE.Mesh(yArrowGeometry, yAxisMaterial);\n    yArrow.position.y = 70;\n    axesGroup.add(yArrow);\n    \n    // Z-axis (blue)\n    const zAxisGeometry = new THREE.CylinderGeometry(2, 2, 60, 8);\n    const zAxisMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });\n    const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);\n    zAxis.rotation.x = Math.PI / 2;\n    zAxis.position.z = 30;\n    axesGroup.add(zAxis);\n    \n    // Z-axis arrow\n    const zArrowGeometry = new THREE.ConeGeometry(6, 20, 8);\n    const zArrow = new THREE.Mesh(zArrowGeometry, zAxisMaterial);\n    zArrow.rotation.x = Math.PI / 2;\n    zArrow.position.z = 70;\n    axesGroup.add(zArrow);\n    \n    // Add axis labels\n    const axisLabels = ['X', 'Y', 'Z'];\n    const axisColors = ['#ff0000', '#00ff00', '#0000ff'];\n    const axisPositions = [\n      new THREE.Vector3(85, 0, 0),\n      new THREE.Vector3(0, 85, 0),\n      new THREE.Vector3(0, 0, 85)\n    ];\n\n    axisLabels.forEach((label, index) => {\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d')!;\n      canvas.width = 64;\n      canvas.height = 64;\n      \n      context.fillStyle = axisColors[index];\n      context.font = 'bold 32px Arial';\n      context.textAlign = 'center';\n      context.textBaseline = 'middle';\n      context.fillText(label, 32, 32);\n      \n      const texture = new THREE.CanvasTexture(canvas);\n      const material = new THREE.SpriteMaterial({ map: texture });\n      const sprite = new THREE.Sprite(material);\n      sprite.position.copy(axisPositions[index]);\n      sprite.scale.set(15, 15, 1);\n      axesGroup.add(sprite);\n    });\n    \n    // Only add axes and lighting if not already present\n    if (!scene.getObjectByName('mainAxes')) {\n      axesGroup.name = 'mainAxes';\n      scene.add(axesGroup);\n    }\n    \n    // Add professional lighting setup only once\n    if (!scene.getObjectByName('mainLighting')) {\n      const lightingGroup = new THREE.Group();\n      lightingGroup.name = 'mainLighting';\n      \n      // Extremely bright ambient light for guaranteed visibility at any distance\n      const ambientLight = new THREE.AmbientLight(0xffffff, 4.0);\n      lightingGroup.add(ambientLight);\n      \n      // Key light - main directional without shadows for maximum brightness\n      const keyLight = new THREE.DirectionalLight(0xffffff, 3.0);\n      keyLight.position.set(100, 150, 80);\n      keyLight.castShadow = false; // Disable shadows to prevent darkening\n      lightingGroup.add(keyLight);\n      \n      // Fill light - much brighter, opposite direction\n      const fillLight = new THREE.DirectionalLight(0x7fb3d4, 1.8);\n      fillLight.position.set(-80, 120, -60);\n      lightingGroup.add(fillLight);\n      \n      // Rim light - dramatic edge lighting\n      const rimLight = new THREE.DirectionalLight(0x4a90e2, 1.2);\n      rimLight.position.set(20, 50, -120);\n      lightingGroup.add(rimLight);\n      \n      // Additional side lights for better coverage\n      const leftLight = new THREE.DirectionalLight(0xaaaaff, 1.5);\n      leftLight.position.set(-150, 80, 0);\n      lightingGroup.add(leftLight);\n      \n      const rightLight = new THREE.DirectionalLight(0xffaaaa, 1.5);\n      rightLight.position.set(150, 80, 0);\n      lightingGroup.add(rightLight);\n      \n      // Top-down light for uniform illumination\n      const topLight = new THREE.DirectionalLight(0xffffff, 1.3);\n      topLight.position.set(0, 200, 0);\n      lightingGroup.add(topLight);\n      \n      // Additional directional lights for uniform illumination at any distance\n      const bottomLight = new THREE.DirectionalLight(0xffffff, 1.0);\n      bottomLight.position.set(0, -200, 0);\n      lightingGroup.add(bottomLight);\n      \n      const frontLight = new THREE.DirectionalLight(0xffffff, 1.2);\n      frontLight.position.set(0, 0, 200);\n      lightingGroup.add(frontLight);\n      \n      const backLight = new THREE.DirectionalLight(0xffffff, 1.2);\n      backLight.position.set(0, 0, -200);\n      lightingGroup.add(backLight);\n      \n      // Corner lights for complete coverage\n      const cornerLight1 = new THREE.DirectionalLight(0xffffff, 0.8);\n      cornerLight1.position.set(100, 100, 100);\n      lightingGroup.add(cornerLight1);\n      \n      const cornerLight2 = new THREE.DirectionalLight(0xffffff, 0.8);\n      cornerLight2.position.set(-100, 100, -100);\n      lightingGroup.add(cornerLight2);\n      \n      const cornerLight3 = new THREE.DirectionalLight(0xffffff, 0.8);\n      cornerLight3.position.set(100, -100, -100);\n      lightingGroup.add(cornerLight3);\n      \n      const cornerLight4 = new THREE.DirectionalLight(0xffffff, 0.8);\n      cornerLight4.position.set(-100, -100, 100);\n      lightingGroup.add(cornerLight4);\n      \n      scene.add(lightingGroup);\n    }\n\n    // Group nodes by tenant and then by service for clustering\n    const tenantGroups = new Map<string, Map<string, DiagramNode[]>>();\n    data.nodes.forEach(node => {\n      const tenantName = node.tenant || 'Unknown';\n      const serviceName = node.service || 'Unknown Service';\n      \n      if (!tenantGroups.has(tenantName)) {\n        tenantGroups.set(tenantName, new Map());\n      }\n      if (!tenantGroups.get(tenantName)!.has(serviceName)) {\n        tenantGroups.get(tenantName)!.set(serviceName, []);\n      }\n      tenantGroups.get(tenantName)!.get(serviceName)!.push(node);\n    });\n\n    // Calculate positions for tenant clusters using settings\n    const serviceSpacing = settings.nodeSpacing || 120; // Distance between services within a cluster\n    const tenantSpacing = settings.clusterSpacing || 600; // Distance between tenant cluster centers\n    const spacing = serviceSpacing; // For backward compatibility\n\n    // Position tenant clusters horizontally, with services arranged symmetrically within each cluster\n    \n    // Color palette for endpoint segments (bright colors for dark theme)\n    const endpointColors = [\n      0x60A5FA, // Bright Blue\n      0xF87171, // Bright Red\n      0x34D399, // Bright Green\n      0xFBBF24, // Bright Orange\n      0xA78BFA, // Bright Purple\n      0xF472B6, // Bright Pink\n      0x22D3EE, // Bright Cyan\n      0xA3E635, // Bright Lime\n      0xFB923C, // Bright Orange-red\n      0x818CF8, // Bright Indigo\n    ];\n\n    // Calculate inter-tenant connections for proximity-based clustering\n    const tenantConnectionCounts = new Map<string, number>();\n    const interTenantConnections = new Map<string, Map<string, number>>();\n    \n    // Count both total connections and inter-tenant connections\n    data.edges.forEach(edge => {\n      const sourceNode = data.nodes.find(n => n.id === edge.source);\n      const targetNode = data.nodes.find(n => n.id === edge.target);\n      \n      if (sourceNode && targetNode) {\n        const sourceTenant = sourceNode.tenant || 'Unknown';\n        const targetTenant = targetNode.tenant || 'Unknown';\n        \n        // Count total connections per tenant\n        tenantConnectionCounts.set(sourceTenant, (tenantConnectionCounts.get(sourceTenant) || 0) + 1);\n        tenantConnectionCounts.set(targetTenant, (tenantConnectionCounts.get(targetTenant) || 0) + 1);\n        \n        // Count inter-tenant connections for clustering\n        if (sourceTenant !== targetTenant) {\n          if (!interTenantConnections.has(sourceTenant)) {\n            interTenantConnections.set(sourceTenant, new Map());\n          }\n          if (!interTenantConnections.has(targetTenant)) {\n            interTenantConnections.set(targetTenant, new Map());\n          }\n          \n          const sourceMap = interTenantConnections.get(sourceTenant)!;\n          const targetMap = interTenantConnections.get(targetTenant)!;\n          \n          sourceMap.set(targetTenant, (sourceMap.get(targetTenant) || 0) + 1);\n          targetMap.set(sourceTenant, (targetMap.get(sourceTenant) || 0) + 1);\n        }\n      }\n    });\n    \n    // Build clusters using proximity algorithm\n    const tenantClusters = new Map<number, string[]>();\n    const assignedTenants = new Set<string>();\n    const allTenants = Array.from(tenantGroups.keys());\n    \n    // Find most connected tenant as cluster 0 center\n    const centralTenant = allTenants.reduce((best, tenant) => {\n      const connections = tenantConnectionCounts.get(tenant) || 0;\n      const bestConnections = tenantConnectionCounts.get(best) || 0;\n      return connections > bestConnections ? tenant : best;\n    });\n    \n    tenantClusters.set(0, [centralTenant]);\n    assignedTenants.add(centralTenant);\n    \n    // Build clusters by finding strongly connected tenants\n    let clusterIndex = 1;\n    \n    while (assignedTenants.size < allTenants.length) {\n      let bestTenant = '';\n      let bestClusterIndex = -1;\n      let maxConnectionStrength = 0;\n      \n      // Find unassigned tenant with strongest connection to existing clusters\n      for (const tenant of allTenants) {\n        if (assignedTenants.has(tenant)) continue;\n        \n        for (const [existingClusterIndex, clusterTenants] of tenantClusters) {\n          let connectionStrength = 0;\n          \n          for (const clusterTenant of clusterTenants) {\n            const connections = interTenantConnections.get(tenant)?.get(clusterTenant) || 0;\n            connectionStrength += connections;\n          }\n          \n          if (connectionStrength > maxConnectionStrength) {\n            maxConnectionStrength = connectionStrength;\n            bestTenant = tenant;\n            bestClusterIndex = existingClusterIndex;\n          }\n        }\n      }\n      \n      if (bestTenant && maxConnectionStrength > 0) {\n        // Add to existing cluster\n        tenantClusters.get(bestClusterIndex)!.push(bestTenant);\n        assignedTenants.add(bestTenant);\n      } else {\n        // Create new cluster for isolated tenant\n        const remainingTenants = allTenants.filter(t => !assignedTenants.has(t));\n        if (remainingTenants.length > 0) {\n          tenantClusters.set(clusterIndex, [remainingTenants[0]]);\n          assignedTenants.add(remainingTenants[0]);\n          clusterIndex++;\n        }\n      }\n    }\n    \n    console.log('ðŸ˜ï¸ Tenant clusters based on inter-connections:', \n      Array.from(tenantClusters.entries()).map(([clusterIdx, tenants]) => ({\n        cluster: clusterIdx,\n        tenants: tenants,\n        connections: tenants.map(t => tenantConnectionCounts.get(t) || 0)\n      }))\n    );\n    \n    console.log('ðŸŽ¯ Central tenant selected:', centralTenant, 'with', tenantConnectionCounts.get(centralTenant), 'connections');\n    \n    // Create ordered list based on cluster membership\n    const sortedTenantNames: string[] = [];\n    for (const [clusterIdx, tenants] of tenantClusters) {\n      // Sort tenants within cluster by connection count\n      const sortedClusterTenants = tenants.sort((a, b) => {\n        const countA = tenantConnectionCounts.get(a) || 0;\n        const countB = tenantConnectionCounts.get(b) || 0;\n        return countB - countA;\n      });\n      sortedTenantNames.push(...sortedClusterTenants);\n    }\n    \n    console.log('ðŸ—ï¸ Tenant+Service cluster architecture - tenants:', sortedTenantNames);\n    \n    // Store real tenant center positions for trunk routing\n    const tenantCenterPositions = new Map<string, THREE.Vector3>();\n    console.log('ðŸ“ RECALCULATING tenant center positions with settings:', {\n      clusterSpacing: settings.clusterSpacing,\n      clusterSpacingY: settings.clusterSpacingY,\n      nodeSpacing: settings.nodeSpacing\n    });\n    \n    sortedTenantNames.forEach((tenantName, tenantIndex) => {\n      const servicesMap = tenantGroups.get(tenantName)!;\n      const services = Array.from(servicesMap.keys()).sort();\n      \n      // Calculate tenant cluster center position using proximity-based clustering\n      let tenantCenterX, tenantCenterY, tenantCenterZ;\n      \n      // Find which cluster this tenant belongs to\n      let tenantClusterIndex = 0;\n      let tenantPositionInCluster = 0;\n      \n      for (const [clusterIdx, clusterTenants] of tenantClusters) {\n        const positionInCluster = clusterTenants.indexOf(tenantName);\n        if (positionInCluster >= 0) {\n          tenantClusterIndex = clusterIdx;\n          tenantPositionInCluster = positionInCluster;\n          break;\n        }\n      }\n      \n      // VERTICAL ARCHITECTURE: Place each tenant at different Y level (like building floors)\n      const baseRadius = tenantSpacing * 0.8; // Horizontal distance from center\n      \n      // Use clusterSpacingY from settings for Y-level spacing\n      const levelHeight = settings.clusterSpacingY || 300;\n      \n      if (tenantName === centralTenant) {\n        // Central tenant at origin level (center of Y-axis)\n        tenantCenterX = 0;\n        tenantCenterY = 0;\n        tenantCenterZ = 0;\n      } else {\n        // Other tenants arranged in spiral pattern above and below center\n        const otherTenants = sortedTenantNames.filter(t => t !== centralTenant);\n        const tenantIndexInSpiral = otherTenants.indexOf(tenantName);\n        \n        if (tenantIndexInSpiral >= 0) {\n          // Spiral pattern: both angle and height increase\n          const spiralTurns = 2.5; // Number of full rotations in the spiral\n          const totalTenants = otherTenants.length;\n          const spiralProgress = tenantIndexInSpiral / Math.max(1, totalTenants - 1);\n          \n          // Angle increases with spiral progress\n          const angle = spiralProgress * spiralTurns * 2 * Math.PI;\n          // Radius varies to create more interesting layout\n          const radiusVariation = 0.7 + 0.3 * Math.sin(spiralProgress * Math.PI * 4);\n          const currentRadius = baseRadius * radiusVariation;\n          \n          tenantCenterX = Math.cos(angle) * currentRadius;\n          \n          // Y-positioning: center tenants around Y=0 (symmetrical above/below)\n          const levelsFromCenter = Math.floor((tenantIndexInSpiral + 1) / 2); // Pairs: 1,2->1  3,4->2  5,6->3\n          const isEven = (tenantIndexInSpiral % 2) === 1; // 0,2,4... = odd positions (below), 1,3,5... = even positions (above)\n          tenantCenterY = isEven ? levelsFromCenter * levelHeight : -levelsFromCenter * levelHeight;\n          \n          tenantCenterZ = Math.sin(angle) * currentRadius;\n        } else {\n          // Fallback for edge cases\n          tenantCenterX = 0;\n          tenantCenterY = (tenantIndex - Math.floor(sortedTenantNames.length / 2)) * levelHeight;\n          tenantCenterZ = baseRadius;\n        }\n      }\n      \n      // Store real tenant center position\n      tenantCenterPositions.set(tenantName, new THREE.Vector3(tenantCenterX, tenantCenterY, tenantCenterZ));\n      \n      console.log(`ðŸ›ï¸ Creating cluster for tenant: ${tenantName} with ${services.length} services`, {\n        connections: tenantConnectionCounts.get(tenantName) || 0,\n        position: { x: tenantCenterX, y: tenantCenterY, z: tenantCenterZ },\n        cluster: tenantClusterIndex,\n        positionInCluster: tenantPositionInCluster,\n        clusterSize: tenantClusters.get(tenantClusterIndex)?.length || 0,\n        isCentralTenant: tenantName === centralTenant,\n        centralTenant: centralTenant\n      });\n      \n      // Create tenant boundary sphere\n      const tenantSphereKey = `tenant-sphere-${tenantName}`;\n      if (!sceneObjectsRef.current.has(tenantSphereKey)) {\n        // Calculate sphere radius based on service count and spacing\n        const sphereRadius = Math.max(serviceSpacing * 1.2, serviceSpacing * 0.8 + (services.length * 15));\n        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 12);\n        \n        // Sphere material with opacity based on LOD level\n        const sphereOpacity = lodLevel === 'low' ? 1.0 : 0.01;\n        const sphereMaterial = new THREE.MeshBasicMaterial({\n          color: tenantName === centralTenant ? 0x4A90E2 : 0x888888,\n          transparent: true,\n          opacity: sphereOpacity,\n          wireframe: false // Never use wireframe\n        });\n        \n        const tenantSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n        tenantSphere.position.set(tenantCenterX, tenantCenterY, tenantCenterZ);\n        tenantSphere.userData = { \n          isTenantSphere: true, \n          tenantName,\n          sphereRadius,\n          lodLevel \n        };\n        \n        scene.add(tenantSphere);\n        sceneObjectsRef.current.set(tenantSphereKey, tenantSphere);\n        \n        // Add large tenant label next to sphere\n        const tenantLabelKey = `tenant-label-${tenantName}`;\n        if (!sceneObjectsRef.current.has(tenantLabelKey)) {\n          const canvas = document.createElement('canvas');\n          const context = canvas.getContext('2d')!;\n          canvas.width = 900;\n          canvas.height = 180;\n          \n          // Extra large tenant label styling with black background\n          context.fillStyle = 'rgba(0, 0, 0, 0.95)';\n          context.fillRect(0, 0, canvas.width, canvas.height);\n          context.strokeStyle = 'rgba(100, 150, 255, 1.0)';\n          context.lineWidth = 4;\n          context.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);\n          \n          // Extra large white text\n          context.fillStyle = '#FFFFFF';\n          context.font = 'bold 64px Arial';\n          context.textAlign = 'center';\n          context.fillText(tenantName.toUpperCase(), canvas.width / 2, canvas.height / 2 + 20);\n\n          const texture = new THREE.CanvasTexture(canvas);\n          const labelMaterial = new THREE.SpriteMaterial({ map: texture });\n          const tenantLabel = new THREE.Sprite(labelMaterial);\n          tenantLabel.position.set(tenantCenterX, tenantCenterY + sphereRadius + 120, tenantCenterZ);\n          tenantLabel.scale.set(200, 40, 1); // Smaller tenant labels\n          tenantLabel.userData = { \n            isTenantLabel: true, \n            tenantName \n          };\n          \n          scene.add(tenantLabel);\n          sceneObjectsRef.current.set(tenantLabelKey, tenantLabel);\n        }\n      } else {\n        // Update existing sphere for LOD changes\n        const existingSphere = sceneObjectsRef.current.get(tenantSphereKey) as THREE.Mesh;\n        if (existingSphere) {\n          const sphereMaterial = existingSphere.material as THREE.MeshBasicMaterial;\n          sphereMaterial.opacity = lodLevel === 'low' ? 1.0 : 0.05;\n          sphereMaterial.wireframe = false; // Never use wireframe\n          sphereMaterial.needsUpdate = true;\n        }\n      }\n      \n      // Arrange services symmetrically within the cluster\n      services.forEach((serviceName, serviceIndex) => {\n        const endpoints = servicesMap.get(serviceName)!;\n        \n        // Calculate service position within cluster (symmetric arrangement)\n        let serviceX, serviceY, serviceZ;\n        \n        if (services.length === 1) {\n          // Single service at cluster center\n          serviceX = tenantCenterX;\n          serviceY = tenantCenterY;\n          serviceZ = tenantCenterZ;\n        } else if (services.length <= 4) {\n          // Small cluster: arrange in 2x2 grid pattern in XZ plane\n          const cols = Math.min(2, services.length);\n          const rows = Math.ceil(services.length / cols);\n          const col = serviceIndex % cols;\n          const row = Math.floor(serviceIndex / cols);\n          \n          serviceX = tenantCenterX + (col - (cols - 1) / 2) * serviceSpacing;\n          serviceY = tenantCenterY; // All at same Y height\n          serviceZ = tenantCenterZ + (row - (rows - 1) / 2) * serviceSpacing;\n        } else {\n          // Larger cluster: arrange in circle in XZ plane\n          const angle = (serviceIndex / services.length) * 2 * Math.PI;\n          const radius = serviceSpacing * 0.8;\n          \n          serviceX = tenantCenterX + Math.cos(angle) * radius;\n          serviceY = tenantCenterY; // All at same Y height\n          serviceZ = tenantCenterZ + Math.sin(angle) * radius;\n        }\n\n        \n        // Create segmented cylinder for this service (each endpoint = one segment)\n        const segmentHeight = 60;\n        const cylinderRadius = 25;\n        const segments = lodLevel === 'low' ? 8 : lodLevel === 'medium' ? 16 : 32;\n        const totalHeight = segmentHeight * endpoints.length;\n        \n        endpoints.forEach((endpoint, endpointIndex) => {\n          const endpointKey = `endpoint-${endpoint.id}`;\n          let existingCylinder = sceneObjectsRef.current.get(endpointKey);\n          \n          // Track specific endpoint for detailed debugging\n          const isTrackedEndpoint = endpoint.id === 'gateway-metrics_route_request';\n          \n          if (isTrackedEndpoint) {\n            console.log('ðŸŽ¯ TRACKED ENDPOINT - Cache lookup:', {\n              endpointId: endpoint.id,\n              endpointKey,\n              existingCylinder: !!existingCylinder,\n              existingUserData: existingCylinder?.userData ? JSON.stringify(existingCylinder.userData) : null\n            });\n          }\n          \n          if (!existingCylinder && lodLevel !== 'low') {\n            const geometry = new THREE.CylinderGeometry(cylinderRadius, cylinderRadius, segmentHeight, segments);\n            const colorIndex = endpointIndex % endpointColors.length;\n            const material = getCachedMaterial(endpointColors[colorIndex]);\n            \n            const segmentY = serviceY + (endpointIndex - (endpoints.length - 1) / 2) * segmentHeight;\n            \n            const mesh = new THREE.Mesh(geometry, material);\n            mesh.position.set(serviceX, segmentY, serviceZ);\n            // No rotation - keep cylinders vertical (Y-axis aligned)\n            mesh.castShadow = false;\n            \n            // Log creation of ALL cylinders for debugging\n            console.log('ðŸ­ Creating new cylinder:', {\n              endpointId: endpoint.id,\n              position: { x: serviceX, y: segmentY, z: serviceZ },\n              geometryType: geometry.type,\n              uuid: mesh.uuid\n            });\n            // Create protected userData that catches overwrites\n            const protectedUserData = {\n              nodeId: endpoint.id, \n              isNode: true, \n              isEndpoint: true,\n              serviceName: serviceName,\n              tenant: tenantName,\n              originalColor: endpointColors[colorIndex]\n            };\n            \n            // Make userData non-configurable to catch overwrites (ALL endpoints)\n            Object.defineProperty(mesh, 'userData', {\n              get: () => protectedUserData,\n              set: (newValue) => {\n                console.error('ðŸš¨ userData overwrite attempt!', {\n                  endpointId: endpoint.id,\n                  oldData: JSON.stringify(protectedUserData),\n                  newData: JSON.stringify(newValue),\n                  stackTrace: new Error().stack?.split('\\n').slice(0, 5).join('\\n')\n                });\n                // Allow the overwrite but log it\n                Object.assign(protectedUserData, newValue);\n              },\n              configurable: false,\n              enumerable: true\n            });\n            \n            if (isTrackedEndpoint) {\n              console.log('ðŸŽ¯ TRACKED ENDPOINT - NEW userData created:', {\n                endpointId: endpoint.id,\n                nodeId: mesh.userData.nodeId,\n                fullUserData: JSON.stringify(mesh.userData),\n                position: { x: serviceX, y: segmentY, z: serviceZ }\n              });\n            }\n            \n            // Log creation for first few endpoints to debug\n            if (endpointIndex < 3) {\n              console.log('ðŸ”§ Creating cylinder with userData:', {\n                endpointId: endpoint.id,\n                nodeId: mesh.userData.nodeId,\n                hasProtection: !mesh.hasOwnProperty('userData'),\n                position: { x: serviceX, y: segmentY, z: serviceZ }\n              });\n            }\n            \n            scene.add(mesh);\n            sceneObjectsRef.current.set(endpointKey, mesh);\n          } else if (existingCylinder) {\n            // Check if userData is already protected\n            const currentUserData = existingCylinder.userData;\n            \n            if (isTrackedEndpoint) {\n              console.log('ðŸŽ¯ TRACKED ENDPOINT - Existing cylinder found:', {\n                endpointId: endpoint.id,\n                hasUserData: !!currentUserData,\n                nodeId: currentUserData?.nodeId,\n                userDataKeys: currentUserData ? Object.keys(currentUserData) : [],\n                isProtected: !existingCylinder.hasOwnProperty('userData')\n              });\n            }\n            \n            // If userData is missing or empty, recreate protection\n            if (!currentUserData || Object.keys(currentUserData).length === 0 || !currentUserData.nodeId) {\n              const protectedUserData = {\n                nodeId: endpoint.id,\n                isNode: true,\n                isEndpoint: true,\n                serviceName: serviceName,\n                tenant: tenantName,\n                originalColor: endpointColors[endpointIndex % endpointColors.length]\n              };\n              \n              // Recreate protected userData\n              Object.defineProperty(existingCylinder, 'userData', {\n                get: () => protectedUserData,\n                set: (newValue) => {\n                  if (isTrackedEndpoint) {\n                    console.error('ðŸš¨ TRACKED ENDPOINT - userData overwrite attempt on existing!', {\n                      endpointId: endpoint.id,\n                      oldData: JSON.stringify(protectedUserData),\n                      newData: JSON.stringify(newValue),\n                      stackTrace: new Error().stack\n                    });\n                  }\n                  Object.assign(protectedUserData, newValue);\n                },\n                configurable: false,\n                enumerable: true\n              });\n              \n              if (isTrackedEndpoint) {\n                console.log('ðŸŽ¯ TRACKED ENDPOINT - userData PROTECTION RESTORED:', {\n                  endpointId: endpoint.id,\n                  nodeId: protectedUserData.nodeId,\n                  fullUserData: JSON.stringify(protectedUserData)\n                });\n              }\n            }\n          }\n\n          // Store 3D position for edge connections\n          const endpointY = serviceY + (endpointIndex - (endpoints.length - 1) / 2) * segmentHeight;\n          (endpoint as any).x3d = serviceX;\n          (endpoint as any).y3d = endpointY;\n          (endpoint as any).z3d = serviceZ;\n          \n          // Add endpoint label if LOD allows\n          if (lodLevel !== 'low') {\n            const endpointLabelKey = `endpoint-label-${endpoint.id}`;\n            if (!sceneObjectsRef.current.has(endpointLabelKey)) {\n              const canvas = document.createElement('canvas');\n              const context = canvas.getContext('2d')!;\n              canvas.width = 300;\n              canvas.height = 60;\n              \n              // Endpoint label styling (smaller than service labels)\n              context.fillStyle = 'rgba(40, 40, 60, 0.8)';\n              context.fillRect(0, 0, canvas.width, canvas.height);\n              context.strokeStyle = 'rgba(100, 150, 255, 0.4)';\n              context.lineWidth = 1;\n              context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n              \n              // White text\n              context.fillStyle = '#E0E8FF';\n              context.font = '24px Arial';\n              context.textAlign = 'center';\n              context.fillText(endpoint.label || endpoint.id, canvas.width / 2, canvas.height / 2 + 8);\n\n              const texture = new THREE.CanvasTexture(canvas);\n              const labelMaterial = new THREE.SpriteMaterial({ map: texture });\n              const endpointLabel = new THREE.Sprite(labelMaterial);\n              endpointLabel.position.set(serviceX + 60, endpointY, serviceZ); // Offset to the right\n              endpointLabel.scale.set(75, 15, 1); // Smaller than service labels\n              endpointLabel.userData = { \n                isLabel: true, \n                isEndpointLabel: true, \n                endpointId: endpoint.id,\n                originalColor: 0xFFFFFF\n              };\n              \n              scene.add(endpointLabel);\n              sceneObjectsRef.current.set(endpointLabelKey, endpointLabel);\n            }\n          }\n        });\n        \n        // Add service label above the segmented cylinder\n        const serviceLabelKey = `service-label-${serviceName}`;\n        if (!sceneObjectsRef.current.has(serviceLabelKey)) {\n          const canvas = document.createElement('canvas');\n          const context = canvas.getContext('2d')!;\n          canvas.width = 400;\n          canvas.height = 80;\n          \n          // Dark background with border\n          context.fillStyle = 'rgba(20, 20, 35, 0.9)';\n          context.fillRect(0, 0, canvas.width, canvas.height);\n          context.strokeStyle = 'rgba(150, 180, 255, 0.6)';\n          context.lineWidth = 1;\n          context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n          \n          // White text\n          context.fillStyle = '#F0F4FF';\n          context.font = '32px Arial';\n          context.textAlign = 'center';\n          context.fillText(serviceName, canvas.width / 2, canvas.height / 2 + 10);\n\n          const texture = new THREE.CanvasTexture(canvas);\n          const labelMaterial = new THREE.SpriteMaterial({ map: texture });\n          const label = new THREE.Sprite(labelMaterial);\n          label.position.set(serviceX, serviceY + totalHeight/2 + 30, serviceZ);\n          label.scale.set(100, 25, 1);\n          label.userData = { \n            isLabel: true, \n            isServiceLabel: true, \n            serviceName: serviceName,\n            originalColor: 0xFFFFFF\n          };\n          \n          scene.add(label);\n          sceneObjectsRef.current.set(serviceLabelKey, label);\n        }\n      });\n      \n      // Add tenant cluster label\n      const tenantLabelKey = `tenant-label-${tenantName}`;\n      if (!sceneObjectsRef.current.has(tenantLabelKey)) {\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d')!;\n        canvas.width = 512;\n        canvas.height = 100;\n        \n        // Tenant label styling\n        context.fillStyle = 'rgba(0, 0, 0, 0.8)';\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.strokeStyle = '#60A5FA';\n        context.lineWidth = 2;\n        context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);\n        context.fillStyle = '#FFFFFF';\n        context.font = 'bold 36px Arial';\n        context.textAlign = 'center';\n        context.fillText(tenantName, canvas.width / 2, canvas.height / 2 + 12);\n\n        const texture = new THREE.CanvasTexture(canvas);\n        const material = new THREE.SpriteMaterial({ map: texture });\n        const label = new THREE.Sprite(material);\n        label.position.set(tenantCenterX, tenantCenterY + 80, tenantCenterZ);\n        label.scale.set(80, 20, 1);\n        label.userData = { \n          isLabel: true, \n          isTenantLabel: true, \n          tenantName: tenantName,\n          originalColor: 0xFFFFFF\n        };\n        \n        scene.add(label);\n        sceneObjectsRef.current.set(tenantLabelKey, label);\n      }\n    });\n\n\n\n\n\n    // Function to get color based on HTTP status code\n    const getStatusColor = (status?: string): number => {\n      if (!status) return 0xCCCCCC; // Light gray for no status (default)\n      \n      const statusCode = parseInt(status);\n      if (isNaN(statusCode)) return 0xCCCCCC; // Light gray for invalid status\n      \n      if (statusCode >= 200 && statusCode < 300) return 0x00FF66; // Bright green for 2xx\n      if (statusCode >= 300 && statusCode < 400) return 0xFFCC00; // Bright orange for 3xx\n      if (statusCode >= 400 && statusCode < 500) return 0xFF4444; // Bright red for 4xx  \n      if (statusCode >= 500) return 0xFF1111; // Very bright red for 5xx\n      if (statusCode >= 100 && statusCode < 200) return 0x44AAFF; // Bright blue for 1xx\n      \n      return 0xCCCCCC; // Light gray fallback\n    };\n\n    // Calculate maximum connection count for line thickness scaling\n    const maxConnectionCount = Math.max(1, ...data.edges.map(edge => edge.connectionCount || 1));\n    \n    // Function to calculate line thickness (1-10 pixels based on connection frequency)\n    const calculateLineThickness = (connectionCount: number): number => {\n      if (maxConnectionCount === 1) return 1; // All connections are single\n      const normalized = (connectionCount - 1) / (maxConnectionCount - 1); // 0 to 1\n      return Math.round(1 + normalized * 9); // 1 to 10\n    };\n\n    // Collect obstacle information for path planning\n    const obstacles: { position: THREE.Vector3; radius: number }[] = [];\n    const cylinderRadius = 25;\n    \n    // Add all tenant positions as obstacles (using real tenant center positions)\n    tenantCenterPositions.forEach((center, tenantName) => {\n      const services = Array.from(tenantGroups.get(tenantName)?.keys() || []);\n      const sphereRadius = Math.max(serviceSpacing * 1.2, serviceSpacing * 0.8 + (services.length * 15));\n      \n      obstacles.push({\n        position: center.clone(),\n        radius: sphereRadius\n      });\n    });\n\n    // MAGISTRAL SYSTEM: Create inter-tenant highways first\n    console.log('ðŸ›£ï¸ MAGISTRAL SYSTEM: Creating inter-tenant highways');\n    console.log(`ðŸ›£ï¸ Processing ${data.edges.length} edges for magistral creation`);\n    \n    // Force magistral recreation for debugging\n    console.log('ðŸ›£ï¸ [DEBUG] FORCING COMPREHENSIVE MAGISTRAL CACHE CLEAR FOR DEBUGGING');\n    const magistralKeys = Array.from(sceneObjectsRef.current.keys()).filter(key => \n      key.startsWith('magistral-') || key.includes('magistral') || key.includes('branch')\n    );\n    console.log(`ðŸ›£ï¸ [DEBUG] Found ${magistralKeys.length} existing magistrals/branches to clear:`, magistralKeys.slice(0, 10));\n    magistralKeys.forEach(key => {\n      const obj = sceneObjectsRef.current.get(key);\n      if (obj && scene) {\n        console.log(`ðŸ›£ï¸ [DEBUG] Removing from scene: ${key}`);\n        scene.remove(obj);\n        sceneObjectsRef.current.delete(key);\n        // Dispose of geometry and materials\n        if (obj instanceof THREE.Mesh) {\n          obj.geometry?.dispose();\n          if (Array.isArray(obj.material)) {\n            obj.material.forEach(mat => mat.dispose());\n          } else {\n            obj.material?.dispose();\n          }\n        }\n      }\n    });\n    \n    // Aggregate inter-tenant connections into magistrals\n    const magistrals = aggregateInterTenantConnections(data);\n    console.log(`ðŸ›£ï¸ MAGISTRAL CREATION RESULT: ${magistrals.size} magistrals created`);\n    \n    if (magistrals.size === 0) {\n      console.warn('ðŸš¨ NO MAGISTRALS CREATED! This indicates no inter-tenant connections found');\n    } else {\n      console.log('ðŸ›£ï¸ MAGISTRAL LIST:');\n      magistrals.forEach((magistral, key) => {\n        console.log(`   ${key}: ${magistral.connectionCount} connections`);\n      });\n    }\n    \n    const maxMagistralCount = Math.max(1, ...Array.from(magistrals.values()).map(m => m.connectionCount));\n    \n\n    \n    // Track existing magistrals to avoid overlap\n    const existingMagistrals = new Map<string, { source: THREE.Vector3; target: THREE.Vector3 }>();\n    \n    // Function to create magistral with direction-based coloring\n    const createMagistral = (\n      magistral: MagistralConnection, \n      magistralKey: string, \n      isReverse: boolean\n    ) => {\n      const magistralObjKey = `magistral-${magistralKey}`;\n      console.log(`ðŸ›£ï¸ [DEBUG ALL] Creating magistral: ${magistralKey}, isReverse: ${isReverse}`);\n      \n      // Skip if magistral already exists (for incremental updates)\n      if (sceneObjectsRef.current.has(magistralObjKey)) {\n        console.log(`ðŸ›£ï¸ [DEBUG ALL] Skipping existing magistral: ${magistralObjKey}`);\n        return;\n      }\n      \n      const sourceCenter = tenantCenterPositions.get(magistral.sourceTenant);\n      const targetCenter = tenantCenterPositions.get(magistral.targetTenant);\n      \n      if (!sourceCenter || !targetCenter) {\n        console.warn(`Missing tenant center for magistral: ${magistralKey}`);\n        return;\n      }\n      \n      // Calculate offset to avoid overlap with existing magistrals\n      const offsetVector = calculateMagistralOffset(sourceCenter, targetCenter, existingMagistrals);\n      if (offsetVector) {\n        console.log(`Applied offset to magistral ${magistralKey}:`, offsetVector);\n      }\n      \n      // Calculate sphere radius for the tenant (using services count)\n      const sourceServices = Array.from(tenantGroups.get(magistral.sourceTenant)?.keys() || []);\n      const targetServices = Array.from(tenantGroups.get(magistral.targetTenant)?.keys() || []);\n      const sourceSphereRadius = Math.max(50, sourceServices.length) * 15 + 30;\n      const targetSphereRadius = Math.max(50, targetServices.length) * 15 + 30;\n      \n      // Use unified function to calculate magistral endpoints (sphere surface touch points)\n      const { sourceEndpoint, targetEndpoint } = calculateMagistralEndpoints(\n        sourceCenter, targetCenter, sourceSphereRadius, targetSphereRadius\n      );\n      const magistralStart = sourceEndpoint.clone();\n      const magistralEnd = targetEndpoint.clone();\n      \n      console.log(`ðŸ›£ï¸ MAGISTRAL ${magistralKey} ENDPOINT CALCULATION:`);\n      console.log(`   Source center: (${sourceCenter.x.toFixed(1)}, ${sourceCenter.y.toFixed(1)}, ${sourceCenter.z.toFixed(1)})`);\n      console.log(`   Target center: (${targetCenter.x.toFixed(1)}, ${targetCenter.y.toFixed(1)}, ${targetCenter.z.toFixed(1)})`);\n      console.log(`   Source sphere radius: ${sourceSphereRadius.toFixed(1)}`);\n      console.log(`   Target sphere radius: ${targetSphereRadius.toFixed(1)}`);\n      console.log(`   Calculated source endpoint: (${sourceEndpoint.x.toFixed(1)}, ${sourceEndpoint.y.toFixed(1)}, ${sourceEndpoint.z.toFixed(1)})`);\n      console.log(`   Calculated target endpoint: (${targetEndpoint.x.toFixed(1)}, ${targetEndpoint.y.toFixed(1)}, ${targetEndpoint.z.toFixed(1)})`);\n      console.log(`   Distance from source center to source endpoint: ${sourceCenter.distanceTo(sourceEndpoint).toFixed(1)}`);\n      console.log(`   Distance from target center to target endpoint: ${targetCenter.distanceTo(targetEndpoint).toFixed(1)}`);\n      console.log(`   Expected distances should match sphere radii: ${sourceSphereRadius.toFixed(1)} and ${targetSphereRadius.toFixed(1)}`);\n      \n      // Create magistral path with obstacle avoidance and offset\n      const magistralPath = createMagistralPath(\n        magistralStart, // Start at source sphere boundary\n        magistralEnd,   // End at target sphere boundary  \n        obstacles, \n        offsetVector,\n        magistral.sourceTenant,\n        magistral.targetTenant\n      );\n      \n      if (magistralPath.length < 2) {\n        console.warn(`Invalid magistral path for: ${magistralKey}`);\n        return;\n      }\n      \n      // Create magistral curve\n      const curve = new THREE.CatmullRomCurve3(magistralPath);\n      const points = curve.getPoints(100); // More points for better segmentation\n      \n      // Split tube into segments: invisible inside spheres, visible outside\n      const segments = [];\n      for (let i = 0; i < points.length - 1; i++) {\n        const point = points[i];\n        const nextPoint = points[i + 1];\n        \n        // Check if this segment is inside either sphere (more conservative approach)\n        const distanceToSource = point.distanceTo(sourceCenter);\n        const distanceToTarget = point.distanceTo(targetCenter);\n        const nextDistanceToSource = nextPoint.distanceTo(sourceCenter);\n        const nextDistanceToTarget = nextPoint.distanceTo(targetCenter);\n        \n        // Only hide if BOTH points of segment are inside sphere (very conservative - 10% radius)\n        const isInsideSourceSphere = distanceToSource < (sourceSphereRadius * 0.1) && nextDistanceToSource < (sourceSphereRadius * 0.1);\n        const isInsideTargetSphere = distanceToTarget < (targetSphereRadius * 0.1) && nextDistanceToTarget < (targetSphereRadius * 0.1);\n        const isInvisible = isInsideSourceSphere || isInsideTargetSphere;\n        \n        segments.push({\n          start: point,\n          end: nextPoint,\n          isInvisible: isInvisible\n        });\n      }\n      \n      // Group consecutive segments with same visibility\n      const groupedSegments = [];\n      let currentGroup = { points: [segments[0].start], isInvisible: segments[0].isInvisible };\n      \n      for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (segment.isInvisible === currentGroup.isInvisible) {\n          currentGroup.points.push(segment.end);\n        } else {\n          // Start new group\n          groupedSegments.push(currentGroup);\n          currentGroup = { points: [segment.start, segment.end], isInvisible: segment.isInvisible };\n        }\n      }\n      groupedSegments.push(currentGroup);\n      \n      // Create tube meshes for each group\n      groupedSegments.forEach((group, groupIndex) => {\n        if (group.points.length < 2) return;\n        \n        const groupCurve = new THREE.CatmullRomCurve3(group.points);\n        const groupGeometry = new THREE.TubeGeometry(groupCurve, Math.max(10, group.points.length), 5, 8, false);\n        \n        const groupMaterial = new THREE.MeshBasicMaterial({\n          color: getMagistralColor(magistral, isReverse),\n          transparent: true,\n          opacity: group.isInvisible ? 0.0 : 0.8 // Invisible inside spheres\n        });\n        \n        const groupMesh = new THREE.Mesh(groupGeometry, groupMaterial);\n        groupMesh.userData = {\n          isMagistral: true,\n          magistralKey: `${magistralKey}-segment-${groupIndex}`,\n          sourceTenant: magistral.sourceTenant,\n          targetTenant: magistral.targetTenant,\n          connectionCount: magistral.connectionCount,\n          isInvisible: group.isInvisible\n        };\n        \n        scene.add(groupMesh);\n        sceneObjectsRef.current.set(`${magistralObjKey}-segment-${groupIndex}`, groupMesh);\n      });\n      \n      // Track this magistral to avoid future overlaps\n      existingMagistrals.set(magistralKey, {\n        source: sourceCenter.clone(),\n        target: targetCenter.clone()\n      });\n      \n      // Add arrows on magistral at 1/3 and 2/3 positions (only on visible segments)\n      const arrow1Pos = curve.getPointAt(0.33);\n      const arrow2Pos = curve.getPointAt(0.67);\n      const arrowDirection = new THREE.Vector3().subVectors(targetCenter, sourceCenter).normalize();\n      \n      [arrow1Pos, arrow2Pos].forEach((arrowPos, index) => {\n        // Check if arrow position is outside spheres (visible) - very conservative\n        const distanceToSource = arrowPos.distanceTo(sourceCenter);\n        const distanceToTarget = arrowPos.distanceTo(targetCenter);\n        const isOutsideSpheres = distanceToSource > (sourceSphereRadius * 0.1) && distanceToTarget > (targetSphereRadius * 0.1);\n        \n        if (isOutsideSpheres) {\n          const arrowKey = `magistral-arrow-${magistralKey}-${index}`;\n          \n          if (!sceneObjectsRef.current.has(arrowKey)) {\n            const arrowGeometry = new THREE.ConeGeometry(16, 40, 6);\n            const arrowMaterial = new THREE.MeshBasicMaterial({ color: getMagistralColor(magistral, isReverse) });\n            const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);\n            \n            arrowMesh.position.copy(arrowPos);\n            arrowMesh.lookAt(arrowPos.clone().add(arrowDirection));\n            arrowMesh.rotateX(Math.PI / 2); // Point forward\n            \n            arrowMesh.userData = {\n              isMagistralArrow: true,\n              magistralKey: magistralKey\n            };\n            \n            scene.add(arrowMesh);\n            sceneObjectsRef.current.set(arrowKey, arrowMesh);\n          }\n        }\n      });\n      \n      console.log(`Created magistral: ${magistralKey} with ${magistral.connectionCount} connections`);\n    };\n\n    // Track processed magistrals to avoid duplicates\n    const processedMagistrals = new Set<string>();\n    \n    // Create magistrals for all directions with proper separation\n    console.log(`ðŸ›£ï¸ STARTING MAGISTRAL CREATION: Processing ${magistrals.size} magistrals in LOD=${lodLevel}`);\n    magistrals.forEach((magistral, magistralKey) => {\n      // Skip if already processed as reverse\n      if (processedMagistrals.has(magistralKey)) return;\n      \n      console.log(`ðŸ›£ï¸ Processing magistral: ${magistralKey}`);\n      \n      // Check if reverse direction exists\n      const reverseKey = `${magistral.targetTenant}->${magistral.sourceTenant}`;\n      const reverseExists = magistrals.has(reverseKey);\n      \n      // Always process forward direction (green) - no offset for single direction\n      console.log(`ðŸ›£ï¸ [FORCE DEBUG] Calling createMagistral for FORWARD: ${magistralKey}, isReverse: false`);\n      createMagistral(magistral, magistralKey, false);\n      processedMagistrals.add(magistralKey);\n      \n      // Process reverse direction (purple) if it exists - with offset for separation\n      if (reverseExists && !existingMagistrals.has(reverseKey)) {\n        const reverseMagistral = magistrals.get(reverseKey)!;\n        \n        // Mark reverse as processed to avoid duplicate creation\n        processedMagistrals.add(reverseKey);\n        \n        // Apply additional offset for reverse magistral to separate from forward\n        const sourceCenter = tenantCenterPositions.get(reverseMagistral.sourceTenant);\n        const targetCenter = tenantCenterPositions.get(reverseMagistral.targetTenant);\n        \n        if (sourceCenter && targetCenter) {\n          // Calculate sphere radius for the tenant (using services count)\n          const sourceServices = Array.from(tenantGroups.get(reverseMagistral.sourceTenant)?.keys() || []);\n          const targetServices = Array.from(tenantGroups.get(reverseMagistral.targetTenant)?.keys() || []);\n          const sourceSphereRadius = Math.max(50, sourceServices.length) * 15 + 30;\n          const targetSphereRadius = Math.max(50, targetServices.length) * 15 + 30;\n          \n          // Use unified function to calculate reverse magistral endpoints\n          const { sourceEndpoint: reverseSourceEndpoint, targetEndpoint: reverseTargetEndpoint } = calculateMagistralEndpoints(\n            sourceCenter, targetCenter, sourceSphereRadius, targetSphereRadius\n          );\n          \n          // Use correct endpoints for reverse direction\n          const direction = new THREE.Vector3().subVectors(targetCenter, sourceCenter).normalize();\n          const magistralStart = reverseSourceEndpoint.clone(); // Start at sphere surface\n          const magistralEnd = reverseTargetEndpoint.clone();   // End at sphere surface\n          \n          // Calculate perpendicular offset for separation\n          const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).normalize();\n          const separationOffset = perpendicular.multiplyScalar(25); // 25 unit separation\n          \n          // Store this offset for the reverse magistral\n          const reverseObjKey = `magistral-${reverseKey}`;\n          \n          if (!sceneObjectsRef.current.has(reverseObjKey)) {\n            // Create reverse magistral with offset\n            const reverseMagistralPath = createMagistralPath(\n              magistralStart, // Start at source sphere boundary\n              magistralEnd,   // End at target sphere boundary\n              obstacles, \n              separationOffset, // Apply separation offset\n              reverseMagistral.sourceTenant,\n              reverseMagistral.targetTenant\n            );\n            \n            if (reverseMagistralPath.length >= 2) {\n              // Apply segmentation to reverse magistral as well\n              const reversePath = reverseMagistralPath;\n              const curve = new THREE.CatmullRomCurve3(reversePath);\n              const points = curve.getPoints(100);\n              \n              // Split tube into segments: invisible inside spheres, visible outside\n              const segments = [];\n              for (let i = 0; i < points.length - 1; i++) {\n                const point = points[i];\n                const nextPoint = points[i + 1];\n                \n                // Check if this segment is inside either sphere (more conservative approach)\n                const distanceToSource = point.distanceTo(sourceCenter);\n                const distanceToTarget = point.distanceTo(targetCenter);\n                const nextDistanceToSource = nextPoint.distanceTo(sourceCenter);\n                const nextDistanceToTarget = nextPoint.distanceTo(targetCenter);\n                \n                // Only hide if BOTH points of segment are inside sphere (very conservative - 10% radius)\n                const isInsideSourceSphere = distanceToSource < (sourceSphereRadius * 0.1) && nextDistanceToSource < (sourceSphereRadius * 0.1);\n                const isInsideTargetSphere = distanceToTarget < (targetSphereRadius * 0.1) && nextDistanceToTarget < (targetSphereRadius * 0.1);\n                const isInvisible = isInsideSourceSphere || isInsideTargetSphere;\n                \n                segments.push({\n                  start: point,\n                  end: nextPoint,\n                  isInvisible: isInvisible\n                });\n              }\n              \n              // Group consecutive segments with same visibility\n              const groupedSegments = [];\n              let currentGroup = { points: [segments[0].start], isInvisible: segments[0].isInvisible };\n              \n              for (let i = 0; i < segments.length; i++) {\n                const segment = segments[i];\n                if (segment.isInvisible === currentGroup.isInvisible) {\n                  currentGroup.points.push(segment.end);\n                } else {\n                  // Start new group\n                  groupedSegments.push(currentGroup);\n                  currentGroup = { points: [segment.start, segment.end], isInvisible: segment.isInvisible };\n                }\n              }\n              groupedSegments.push(currentGroup);\n              \n              // Create tube meshes for each group\n              groupedSegments.forEach((group, groupIndex) => {\n                if (group.points.length < 2) return;\n                \n                const groupCurve = new THREE.CatmullRomCurve3(group.points);\n                const groupGeometry = new THREE.TubeGeometry(groupCurve, Math.max(10, group.points.length), 5, 8, false);\n                \n                const groupMaterial = new THREE.MeshBasicMaterial({\n                  color: getMagistralColor(reverseMagistral, true), // Purple for reverse\n                  transparent: true,\n                  opacity: group.isInvisible ? 0.0 : 0.8 // Invisible inside spheres\n                });\n                \n                const groupMesh = new THREE.Mesh(groupGeometry, groupMaterial);\n                groupMesh.userData = {\n                  isMagistral: true,\n                  magistralKey: `${reverseKey}-segment-${groupIndex}`,\n                  sourceTenant: reverseMagistral.sourceTenant,\n                  targetTenant: reverseMagistral.targetTenant,\n                  connectionCount: reverseMagistral.connectionCount,\n                  isInvisible: group.isInvisible\n                };\n                \n                scene.add(groupMesh);\n                sceneObjectsRef.current.set(`${reverseObjKey}-segment-${groupIndex}`, groupMesh);\n              });\n              \n              // Add arrows on reverse magistral (only on visible segments)\n              const arrow1Pos = curve.getPointAt(0.33);\n              const arrow2Pos = curve.getPointAt(0.67);\n              const reverseArrowDirection = new THREE.Vector3().subVectors(targetCenter, sourceCenter).normalize();\n              \n              [arrow1Pos, arrow2Pos].forEach((arrowPos, index) => {\n                // Check if arrow position is outside spheres (visible) - very conservative\n                const distanceToSource = arrowPos.distanceTo(sourceCenter);\n                const distanceToTarget = arrowPos.distanceTo(targetCenter);\n                const isOutsideSpheres = distanceToSource > (sourceSphereRadius * 0.1) && distanceToTarget > (targetSphereRadius * 0.1);\n                \n                if (isOutsideSpheres) {\n                  const arrowKey = `magistral-arrow-${reverseKey}-${index}`;\n                  \n                  if (!sceneObjectsRef.current.has(arrowKey)) {\n                    const arrowGeometry = new THREE.ConeGeometry(16, 40, 6);\n                    const arrowMaterial = new THREE.MeshBasicMaterial({ color: getMagistralColor(reverseMagistral, true) });\n                    const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);\n                    \n                    arrowMesh.position.copy(arrowPos);\n                    arrowMesh.lookAt(arrowPos.clone().add(reverseArrowDirection));\n                    arrowMesh.rotateX(Math.PI / 2);\n                    \n                    arrowMesh.userData = {\n                      isMagistralArrow: true,\n                      magistralKey: reverseKey\n                    };\n                    \n                    scene.add(arrowMesh);\n                    sceneObjectsRef.current.set(arrowKey, arrowMesh);\n                  }\n                }\n              });\n              \n              console.log(`Created reverse magistral: ${reverseKey} with offset and ${reverseMagistral.connectionCount} connections`);\n            }\n          }\n        }\n        \n        // Mark as processed\n        existingMagistrals.set(reverseKey, {\n          source: tenantCenterPositions.get(reverseMagistral.sourceTenant)!.clone(),\n          target: tenantCenterPositions.get(reverseMagistral.targetTenant)!.clone()\n        });\n      }\n    });\n\n    // Note: Branch connections will be added after all nodes are created\n\n    // VERTICAL ARCHITECTURE: Process intra-tenant connections only\n    console.log('ðŸ—ï¸ VERTICAL ARCHITECTURE: Creating intra-tenant connections');\n\n    // Process only intra-tenant connections (inter-tenant are now handled by magistrals)\n    const processedEdges = new Set<string>();\n    \n    data.edges.forEach(edge => {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      const sourceNode = data.nodes.find(n => n.id === sourceId);\n      const targetNode = data.nodes.find(n => n.id === targetId);\n      \n      // Process only intra-tenant connections (inter-tenant handled by magistrals)\n      if (!sourceNode || !targetNode || !sourceNode.tenant || !targetNode.tenant) return;\n      if (sourceNode.tenant !== targetNode.tenant) return; // Skip inter-tenant connections\n      \n      const edgeKey = `${sourceId}->${targetId}`;\n      const arrowKey = `arrow-${edge.id}`;\n      \n      // Skip if already processed as part of bidirectional pair\n      if (processedEdges.has(edgeKey)) return;\n      \n      // Skip if arrow already exists (for incremental updates)\n      if (sceneObjectsRef.current.has(arrowKey)) {\n        console.log(`Skipping existing arrow: ${arrowKey}`);\n        processedEdges.add(edgeKey);\n        // Also mark reverse direction as processed if it's bidirectional\n        const reverseKey = `${targetId}->${sourceId}`;\n        if (data.edges.find(e => {\n          const rSourceId = typeof e.source === 'string' ? e.source : e.source.id;\n          const rTargetId = typeof e.target === 'string' ? e.target : e.target.id;\n          return rSourceId === targetId && rTargetId === sourceId;\n        })) {\n          processedEdges.add(reverseKey);\n        }\n        return;\n      }\n      \n      const sourceX3d = (sourceNode as any)?.x3d;\n      const sourceY3d = (sourceNode as any)?.y3d;\n      const sourceZ3d = (sourceNode as any)?.z3d;\n      const targetX3d = (targetNode as any)?.x3d;\n      const targetY3d = (targetNode as any)?.y3d;\n      const targetZ3d = (targetNode as any)?.z3d;\n\n      if (sourceNode && targetNode && sourceX3d !== undefined && targetX3d !== undefined && lodLevel !== 'low') {\n        // Check if bidirectional connection exists and find return edge\n        const returnEdge = data.edges.find(e => {\n          const rSourceId = typeof e.source === 'string' ? e.source : e.source.id;\n          const rTargetId = typeof e.target === 'string' ? e.target : e.target.id;\n          return rSourceId === targetId && rTargetId === sourceId;\n        });\n        const hasBidirectional = !!returnEdge;\n        \n        // Color based on HTTP status code for forward direction\n        const forwardColor = getStatusColor(edge.status);\n        // Color for return direction (if exists)\n        const returnColor = getStatusColor(returnEdge?.status);\n        \n        const arrowGeometry = new THREE.ConeGeometry(6, 24, 8);\n        \n        if (hasBidirectional) {\n          // Mark both directions as processed to avoid duplicate processing\n          processedEdges.add(edgeKey);\n          processedEdges.add(`${targetId}->${sourceId}`);\n          \n          // Create separate arrows for each direction using new helper function\n          console.log(`Creating separate bidirectional arrows: ${edge.id} and ${returnEdge?.id}`);\n          \n          // Calculate surface points on cylinders - use adaptive radius based on tenant spheres\n          const minObstacleRadius = Math.min(...obstacles.map(o => o.radius));\n          const cylinderRadius = minObstacleRadius * 0.12; // 12% of smallest sphere radius\n          const separationDistance = minObstacleRadius * 0.15; // 15% of radius for separation\n          \n          // Cylinders are oriented along Z-axis, so we need to project onto XY plane\n          const sourceCenter = new THREE.Vector3(sourceX3d, sourceY3d || 0, sourceZ3d || 0);\n          const targetCenter = new THREE.Vector3(targetX3d, targetY3d || 0, targetZ3d || 0);\n          \n          // Calculate direction in XY plane (perpendicular to cylinder axis)\n          const connectionDir2D = new THREE.Vector3(\n            targetX3d - sourceX3d,\n            (targetY3d || 0) - (sourceY3d || 0),\n            0 // Only XY plane for cylinder surface\n          ).normalize();\n          \n          // Surface points on cylinders - project to cylinder surface in XY plane\n          const sourceSurfacePoint = new THREE.Vector3(\n            sourceX3d + connectionDir2D.x * cylinderRadius,\n            (sourceY3d || 0) + connectionDir2D.y * cylinderRadius,\n            sourceZ3d || 0 // Keep Z at segment height\n          );\n          const targetSurfacePoint = new THREE.Vector3(\n            targetX3d - connectionDir2D.x * cylinderRadius,\n            (targetY3d || 0) - connectionDir2D.y * cylinderRadius,\n            targetZ3d || 0 // Keep Z at segment height\n          );\n          \n          // Create forward direction arrow (source â†’ target) with upward offset\n          const forwardArrow = createArrowSystem(\n            sourceSurfacePoint,\n            targetSurfacePoint,\n            sourceCenter,\n            targetCenter,\n            obstacles,\n            cylinderRadius,\n            separationDistance, // Positive offset (upward)\n            edge,\n            forwardColor,\n            lodLevel,\n            calculateLineThickness,\n            sourceNode,\n            targetNode\n          );\n          scene.add(forwardArrow);\n          sceneObjectsRef.current.set(`arrow-${edge.id}-forward`, forwardArrow);\n          \n          // Create reverse direction arrow (target â†’ source) with downward offset\n          if (returnEdge) {\n            const reverseArrow = createArrowSystem(\n              targetSurfacePoint,\n              sourceSurfacePoint,\n              targetCenter,\n              sourceCenter,\n              obstacles,\n              cylinderRadius,\n              -separationDistance, // Negative offset (downward)\n              returnEdge,\n              returnColor,\n              lodLevel,\n              calculateLineThickness,\n              targetNode,\n              sourceNode\n            );\n            scene.add(reverseArrow);\n            sceneObjectsRef.current.set(`arrow-${returnEdge.id}-reverse`, reverseArrow);\n          }\n        } else {\n          // Create single unidirectional arrow using new helper function\n          console.log(`Creating unidirectional arrow: ${arrowKey}`);\n          \n          // Calculate surface points on cylinders - use adaptive radius based on tenant spheres\n          const minObstacleRadius = Math.min(...obstacles.map(o => o.radius));\n          const cylinderRadius = minObstacleRadius * 0.12; // 12% of smallest sphere radius\n          \n          // Cylinder centers for surface calculations\n          const sourceCenter = new THREE.Vector3(sourceX3d, sourceY3d || 0, sourceZ3d || 0);\n          const targetCenter = new THREE.Vector3(targetX3d, targetY3d || 0, targetZ3d || 0);\n          \n          // Calculate direction in XY plane (perpendicular to cylinder axis)\n          const connectionDir2D = new THREE.Vector3(\n            targetX3d - sourceX3d,\n            (targetY3d || 0) - (sourceY3d || 0),\n            0 // Only XY plane for cylinder surface\n          ).normalize();\n          \n          // Surface points on cylinders - project to cylinder surface in XY plane\n          const sourceSurfacePoint = new THREE.Vector3(\n            sourceX3d + connectionDir2D.x * cylinderRadius,\n            (sourceY3d || 0) + connectionDir2D.y * cylinderRadius,\n            sourceZ3d || 0 // Keep Z at segment height\n          );\n          const targetSurfacePoint = new THREE.Vector3(\n            targetX3d - connectionDir2D.x * cylinderRadius,\n            (targetY3d || 0) - connectionDir2D.y * cylinderRadius,\n            targetZ3d || 0 // Keep Z at segment height\n          );\n          \n          // Create unidirectional arrow with no offset (centered)\n          const singleArrow = createArrowSystem(\n            sourceSurfacePoint,\n            targetSurfacePoint,\n            sourceCenter,\n            targetCenter,\n            obstacles,\n            cylinderRadius,\n            0, // No separation offset for unidirectional\n            edge,\n            forwardColor,\n            lodLevel,\n            calculateLineThickness,\n            sourceNode,\n            targetNode\n          );\n          scene.add(singleArrow);\n          sceneObjectsRef.current.set(arrowKey, singleArrow);\n          \n          processedEdges.add(edgeKey);\n        }\n      }\n    });\n\n    // Camera controls with rotation and panning\n    // Initial rotation for standard front view: X right, Y up, Z towards viewer\n    let isMouseDown = false;\n    let mouseX = 0, mouseY = 0;\n    let targetRotationX = 0, targetRotationY = 0;\n    let currentRotationX = 0, currentRotationY = 0;\n    let cameraDistance = 500;\n    let panX = 0, panY = 0;\n    let targetPanX = 0, targetPanY = 0;\n    \n    // Restore camera state if available\n    if (cameraStateRef.current) {\n      const savedState = cameraStateRef.current;\n      currentRotationX = targetRotationX = savedState.rotationX;\n      currentRotationY = targetRotationY = savedState.rotationY;\n      cameraDistance = savedState.distance;\n      panX = targetPanX = savedState.panX;\n      panY = targetPanY = savedState.panY;\n    }\n    \n    // Mouse interaction for cube clicking\n    \n    const onMouseDown = (event: MouseEvent) => {\n      // Check if click is on orientation cube first\n      const rect = renderer.domElement.getBoundingClientRect();\n      const cubeSize = 120;\n      const cubeX = renderer.domElement.clientWidth - cubeSize - 10;\n      const cubeY = 10;\n      \n      const clickX = event.clientX - rect.left;\n      const clickY = event.clientY - rect.top;\n      \n      // If clicking on cube area, handle it separately\n      if (clickX >= cubeX && clickX <= cubeX + cubeSize &&\n          clickY >= cubeY && clickY <= cubeY + cubeSize) {\n        onCubeClick(event);\n        return; // Don't start drag on cube\n      }\n      \n      isMouseDown = true;\n      mouseX = event.clientX;\n      mouseY = event.clientY;\n      renderer.domElement.style.cursor = 'grabbing';\n    };\n    \n    const onMouseUp = () => {\n      isMouseDown = false;\n      renderer.domElement.style.cursor = 'grab';\n    };\n    \n    const onMouseMove = (event: MouseEvent) => {\n      // Check if mouse is over cube area and update cursor\n      const rect = renderer.domElement.getBoundingClientRect();\n      const cubeSize = 120;\n      const cubeX = renderer.domElement.clientWidth - cubeSize - 10;\n      const cubeY = 10;\n      \n      const mouseX_canvas = event.clientX - rect.left;\n      const mouseY_canvas = event.clientY - rect.top;\n      \n      const isOverCube = (mouseX_canvas >= cubeX && mouseX_canvas <= cubeX + cubeSize &&\n                          mouseY_canvas >= cubeY && mouseY_canvas <= cubeY + cubeSize);\n      \n      // Check for arrow hover when not dragging\n      if (!isMouseDown && !isOverCube) {\n        updateMouseAndCheckHover(event);\n      } else if (isOverCube) {\n        renderer.domElement.style.cursor = 'pointer';\n      } else if (!isMouseDown) {\n        renderer.domElement.style.cursor = 'grab';\n      } else {\n        renderer.domElement.style.cursor = 'grabbing';\n      }\n      \n      if (!isMouseDown) return;\n      \n      const deltaX = event.clientX - mouseX;\n      const deltaY = event.clientY - mouseY;\n      \n      // Shift key for panning, otherwise rotation\n      if (event.shiftKey) {\n        // Pan mode - move camera position\n        targetPanX -= deltaX * 2;\n        targetPanY += deltaY * 2;\n      } else {\n        // Rotation mode with constraints to prevent flipping\n        targetRotationY += deltaX * 0.01;\n        targetRotationX += deltaY * 0.01;\n        \n        // Constrain vertical rotation to prevent flipping\n        targetRotationX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, targetRotationX));\n      }\n      \n      mouseX = event.clientX;\n      mouseY = event.clientY;\n    };\n\n    const onWheel = (event: WheelEvent) => {\n      event.preventDefault();\n      cameraDistance += event.deltaY * 2;\n      \n      // Calculate adaptive camera limits based on current scheme size\n      if (data && data.nodes.length > 0) {\n        // Estimate scheme size using similar logic as in animation loop\n        const tenantGroups = Object.groupBy(data.nodes, node => node.tenant || 'default');\n        const tenantCount = Object.keys(tenantGroups).length;\n        const tenantsPerRow = Math.ceil(Math.sqrt(tenantCount));\n        const gridWidth = (tenantsPerRow - 1) * (settings.clusterSpacing || 600);\n        const gridHeight = (Math.ceil(tenantCount / tenantsPerRow) - 1) * (settings.clusterSpacing || 600);\n        const tenantClusterRadius = (settings.nodeSpacing || 120) * 1.5;\n        \n        const schemeWidth = Math.max(gridWidth + tenantClusterRadius, 400);\n        const schemeHeight = Math.max(200, 200);\n        const schemeDepth = Math.max(gridHeight + tenantClusterRadius, 400);\n        const schemeDiagonal = Math.sqrt(schemeWidth * schemeWidth + schemeHeight * schemeHeight + schemeDepth * schemeDepth);\n        \n        // Remove camera distance limits - allow unlimited zoom in/out\n        // const minDistance = schemeDiagonal * 0.15;  // 15% of diagonal\n        // const maxDistance = schemeDiagonal * 0.35;  // 35% of diagonal - max 0.2x relative distance\n        \n        // cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));\n      } else {\n        // Remove fixed limits - allow unlimited zoom even without data\n        // cameraDistance = Math.max(100, Math.min(1500, cameraDistance));\n      }\n    };\n\n    // Click handler for orientation cube\n    const onCubeClick = (event: MouseEvent) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const cubeSize = 120;\n      const cubeX = renderer.domElement.clientWidth - cubeSize - 10;\n      const cubeY = 10;\n      \n      // Check if click is within cube area\n      const clickX = event.clientX - rect.left;\n      const clickY = event.clientY - rect.top;\n      \n      if (clickX >= cubeX && clickX <= cubeX + cubeSize &&\n          clickY >= cubeY && clickY <= cubeY + cubeSize) {\n        \n        // Convert to cube-relative coordinates [-1, 1]\n        const cubeMouseCoords = new THREE.Vector2(\n          ((clickX - cubeX) / cubeSize) * 2 - 1,\n          -((clickY - cubeY) / cubeSize) * 2 + 1\n        );\n        \n        raycaster.setFromCamera(cubeMouseCoords, cubeCamera);\n        const intersects = raycaster.intersectObject(orientationCube.cube);\n        \n        if (intersects.length > 0) {\n          const faceIndex = intersects[0].face?.materialIndex;\n          \n          if (faceIndex !== undefined && faceIndex < orientationCube.faceLabels.length) {\n            const faceName = orientationCube.faceLabels[faceIndex];\n            const orientation = (orientationCube.viewOrientations as any)[faceName];\n            \n            // Animate to the selected view with constraints\n            targetRotationX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, orientation.x));\n            targetRotationY = orientation.y;\n            \n            // Reset panning when switching views\n            targetPanX = 0;\n            targetPanY = 0;\n            \n            // Prevent default drag behavior\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n\n    // Add specific click handler for cube interaction and computer icons\n    const onCanvasClick = (event: MouseEvent) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const cubeSize = 120;\n      const cubeX = renderer.domElement.clientWidth - cubeSize - 10;\n      const cubeY = 10;\n      \n      const clickX = event.clientX - rect.left;\n      const clickY = event.clientY - rect.top;\n      \n      // Check if click is in cube area (top-right corner)\n      const inCubeArea = (clickX >= cubeX && clickX <= cubeX + cubeSize &&\n                         clickY >= cubeY && clickY <= cubeY + cubeSize);\n      \n      if (inCubeArea) {\n        onCubeClick(event);\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n\n      // Check for computer icon clicks\n      const mouseVector = new THREE.Vector2();\n      mouseVector.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n      mouseVector.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n      \n      raycaster.setFromCamera(mouseVector, camera);\n      const intersects = raycaster.intersectObjects(scene.children, true);\n      \n      for (const intersect of intersects) {\n        if (intersect.object.userData?.isComputerIcon && intersect.object.userData?.tenantName) {\n          const tenantName = intersect.object.userData.tenantName;\n          const firstSystem = data?.nodes.find(n => n.tenant === tenantName);\n          const metrics = serviceMetrics.get(firstSystem?.service || tenantName);\n          \n          setMetricsPopup({\n            visible: true,\n            serviceName: firstSystem?.service || tenantName,\n            metrics: metrics || null,\n            position: { x: event.clientX, y: event.clientY }\n          });\n          \n          event.preventDefault();\n          event.stopPropagation();\n          break;\n        }\n      }\n    };\n    \n    // Add mousemove handler for cursor changes\n    const onCanvasMouseMove = (event: MouseEvent) => {\n      const rect = renderer.domElement.getBoundingClientRect();\n      const cubeSize = 120;\n      const cubeX = renderer.domElement.clientWidth - cubeSize - 10;\n      const cubeY = 10;\n      \n      const mouseX_canvas = event.clientX - rect.left;\n      const mouseY_canvas = event.clientY - rect.top;\n      \n      const isOverCube = (mouseX_canvas >= cubeX && mouseX_canvas <= cubeX + cubeSize &&\n                         mouseY_canvas >= cubeY && mouseY_canvas <= cubeY + cubeSize);\n      \n      if (isOverCube) {\n        renderer.domElement.style.cursor = 'pointer';\n      } else {\n        renderer.domElement.style.cursor = isMouseDown ? 'grabbing' : 'grab';\n      }\n    };\n\n    // Attach event listeners\n    renderer.domElement.addEventListener('click', onCanvasClick);\n    renderer.domElement.addEventListener('mousedown', onMouseDown);\n    renderer.domElement.addEventListener('mousemove', onCanvasMouseMove);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('mouseup', onMouseUp);\n    renderer.domElement.addEventListener('wheel', onWheel);\n\n    // Set initial cursor style\n    renderer.domElement.style.cursor = 'grab';\n\n    // CREATE BRANCH CONNECTIONS: From magistral endpoints to individual endpoints\n    console.log('ðŸš¨ ðŸŒ¿ BRANCH CONNECTIONS SECTION STARTED: Creating connections from magistral endpoints to individual endpoints');\n    console.log('ðŸš¨ Available magistrals:', magistrals);\n    console.log('ðŸš¨ Available tenants:', Array.from(tenantCenterPositions.keys()));\n    \n    // Calculate cylinder radius for branch connections\n    const minObstacleRadius = Math.min(...obstacles.map(o => o.radius));\n    const branchCylinderRadius = minObstacleRadius * 0.12; // 12% of smallest sphere radius\n    \n    // Helper function to create branch connections from magistral endpoint to tenant endpoints\n    const createBranchConnections = (magistralEndpoint: THREE.Vector3, tenantName: string, edges: any[]) => {\n      console.log(`ðŸŒ¿ Creating branch connections for tenant: ${tenantName}, magistral endpoint:`, magistralEndpoint);\n      \n      // Find ALL nodes in this tenant (not just from edges)\n      const tenantNodes = data.nodes.filter(node => node.tenant === tenantName);\n      console.log(`ðŸŒ¿ Found ${tenantNodes.length} nodes in tenant ${tenantName}:`, tenantNodes.map(n => n.id));\n      \n      tenantNodes.forEach(targetNode => {\n        // Find existing cylinder for this endpoint to get its position\n        const endpointKey = `endpoint-${targetNode.id}`;\n        const existingCylinder = sceneObjectsRef.current.get(endpointKey) as THREE.Mesh;\n        \n        console.log(`ðŸ”§ DEBUG: Looking for endpoint cylinder: ${endpointKey}, found:`, existingCylinder ? 'YES' : 'NO');\n        if (existingCylinder) {\n          console.log(`ðŸ”§ DEBUG: Found cylinder type: ${existingCylinder.type}, userData:`, existingCylinder.userData);\n          const endpointPosition = existingCylinder.position.clone();\n          console.log(`ðŸ”§ DEBUG: Retrieved cylinder position: (${endpointPosition.x.toFixed(1)}, ${endpointPosition.y.toFixed(1)}, ${endpointPosition.z.toFixed(1)})`);\n          \n          // Continue with branch connection creation\n          const branchKey = `branch-in-${tenantName}-${targetNode.id}`;\n          \n          if (!sceneObjectsRef.current.has(branchKey)) {\n            console.log(`ðŸŒ¿ Creating incoming branch: magistral endpoint â†’ ${targetNode.id} in ${tenantName}`);\n            console.log(`ðŸ”§ Branch connection coordinates: magistral (${magistralEndpoint.x.toFixed(1)}, ${magistralEndpoint.y.toFixed(1)}, ${magistralEndpoint.z.toFixed(1)}) â†’ endpoint (${endpointPosition.x.toFixed(1)}, ${endpointPosition.y.toFixed(1)}, ${endpointPosition.z.toFixed(1)})`);\n            \n            // Create simple line connection from magistral to endpoint\n            const points = [magistralEndpoint.clone(), endpointPosition.clone()];\n            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n            const lineMaterial = new THREE.LineBasicMaterial({ \n              color: 0x8B5CF6, // Purple for incoming (response) connections\n              linewidth: 3 \n            });\n            const lineMesh = new THREE.Line(lineGeometry, lineMaterial);\n            \n            // Add arrow on incoming branch\n            const direction = new THREE.Vector3().subVectors(endpointPosition, magistralEndpoint).normalize();\n            const arrowPosition = magistralEndpoint.clone().add(direction.multiplyScalar(50));\n            const arrowGroup = createDirectionalArrow(scene, arrowPosition, direction, 0x8B5CF6, 0.5);\n            \n            lineMesh.userData = {\n              isBranch: true,\n              tenantName: tenantName,\n              endpointId: targetNode.id,\n              branchType: 'incoming'\n            };\n            \n            scene.add(lineMesh);\n            sceneObjectsRef.current.set(branchKey, lineMesh);\n            sceneObjectsRef.current.set(`${branchKey}-arrow`, arrowGroup);\n            \n            console.log(`âœ… Created incoming branch connection: ${branchKey} for tenant ${tenantName} â†’ endpoint ${targetNode.id}`);\n          } else {\n            console.log(`ðŸŒ¿ Skipping existing incoming branch: ${branchKey}`);\n          }\n        } else {\n          console.log(`âš ï¸ No cylinder found for endpoint: ${endpointKey} (trying endpoint- prefix)`);\n        }\n      });\n    };\n    \n    // Create branch connections for each tenant - ÐžÐ‘Ð Ñ‚Ð¸Ð¿Ð° ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ð¹\n    console.log(`ðŸ”§ DEBUG: Starting branch connections creation for ${tenantCenterPositions.size} tenants`);\n    console.log(`ðŸ”§ DEBUG: Available magistrals: ${magistrals.size}`);\n    console.log(`ðŸ”§ DEBUG: Magistral keys:`, Array.from(magistrals.keys()));\n    \n    tenantCenterPositions.forEach((center, tenantName) => {\n      const services = Array.from(tenantGroups.get(tenantName)?.keys() || []);\n      const sphereRadius = Math.max(50, services.length) * 15 + 30;\n      \n      console.log(`ðŸ”§ DEBUG: Processing tenant ${tenantName} with ${services.length} services, sphere radius: ${sphereRadius}`);\n      \n      // Check what types of magistrals this tenant has\n      let hasIncomingMagistrals = false;\n      let hasOutgoingMagistrals = false;\n      \n      magistrals.forEach((magistral, magistralKey) => {\n        console.log(`ðŸ”§ DEBUG: Checking magistral ${magistralKey}: ${magistral.sourceTenant} â†’ ${magistral.targetTenant}`);\n        if (magistral.targetTenant === tenantName) {\n          hasIncomingMagistrals = true;\n          console.log(`âœ… Found INCOMING magistral for ${tenantName}: ${magistral.sourceTenant} â†’ ${tenantName}`);\n        }\n        if (magistral.sourceTenant === tenantName) {\n          hasOutgoingMagistrals = true;\n          console.log(`âœ… Found OUTGOING magistral for ${tenantName}: ${tenantName} â†’ ${magistral.targetTenant}`);\n        }\n      });\n      \n      console.log(`ðŸ”§ DEBUG: Tenant ${tenantName} magistral status: incoming=${hasIncomingMagistrals}, outgoing=${hasOutgoingMagistrals}`);\n      \n      // Create INCOMING connections (green) if tenant has incoming magistrals\n      if (hasIncomingMagistrals) {\n        console.log(`ðŸŒ¿ Creating INCOMING connections for ${tenantName}: magistral endpoints â†’ endpoints`);\n        \n        // Find closest magistral endpoints for this tenant\n        magistrals.forEach((magistral, magistralKey) => {\n          if (magistral.targetTenant === tenantName) {\n            // Calculate magistral endpoints using unified function\n            const sourceCenter = tenantCenterPositions.get(magistral.sourceTenant);\n            if (sourceCenter) {\n              const sourceSphereRadius = Math.max(50, Array.from(tenantGroups.get(magistral.sourceTenant)?.keys() || []).length) * 15 + 30;\n              \n              // Use unified function to calculate magistral endpoints\n              const { sourceEndpoint, targetEndpoint, direction } = calculateMagistralEndpoints(\n                sourceCenter, center, sourceSphereRadius, sphereRadius\n              );\n              \n              console.log(`ðŸ”§ INCOMING magistral endpoints for ${tenantName} (UNIFIED):`);\n              console.log(`   Source center: (${sourceCenter.x.toFixed(1)}, ${sourceCenter.y.toFixed(1)}, ${sourceCenter.z.toFixed(1)})`);\n              console.log(`   Target center: (${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)})`);\n              console.log(`   Source sphere radius: ${sourceSphereRadius}`);\n              console.log(`   Target sphere radius: ${sphereRadius}`);\n              console.log(`   Direction vector: (${direction.x.toFixed(3)}, ${direction.y.toFixed(3)}, ${direction.z.toFixed(3)})`);\n              console.log(`   Source endpoint: (${sourceEndpoint.x.toFixed(1)}, ${sourceEndpoint.y.toFixed(1)}, ${sourceEndpoint.z.toFixed(1)})`);\n              console.log(`   Target endpoint: (${targetEndpoint.x.toFixed(1)}, ${targetEndpoint.y.toFixed(1)}, ${targetEndpoint.z.toFixed(1)})`);\n              \n              // Find which endpoint is closer to tenant's endpoints\n              const tenantNodes = data.nodes.filter(node => node.tenant === tenantName);\n              let closestMagistralEndpoint = targetEndpoint;\n              let minTotalDistance = Infinity;\n              \n              [sourceEndpoint, targetEndpoint].forEach(endpoint => {\n                let totalDistance = 0;\n                tenantNodes.forEach(node => {\n                  const endpointKey = `endpoint-${node.id}`;\n                  const existingCylinder = sceneObjectsRef.current.get(endpointKey) as THREE.Mesh;\n                  if (existingCylinder) {\n                    totalDistance += endpoint.distanceTo(existingCylinder.position);\n                  }\n                });\n                \n                if (totalDistance < minTotalDistance) {\n                  minTotalDistance = totalDistance;\n                  closestMagistralEndpoint = endpoint;\n                }\n              });\n              \n              console.log(`ðŸŒ¿ Using closest incoming magistral endpoint for ${tenantName}:`, closestMagistralEndpoint);\n              console.log(`ðŸ”§ Selected endpoint distance from tenant nodes: ${minTotalDistance.toFixed(1)}`);\n              console.log(`ðŸ”§ DEBUG: Comparing endpoints - source: (${sourceEndpoint.x.toFixed(1)}, ${sourceEndpoint.y.toFixed(1)}, ${sourceEndpoint.z.toFixed(1)}), target: (${targetEndpoint.x.toFixed(1)}, ${targetEndpoint.y.toFixed(1)}, ${targetEndpoint.z.toFixed(1)})`);\n              console.log(`ðŸ”§ DEBUG: Selected closest endpoint coordinates: (${closestMagistralEndpoint.x.toFixed(1)}, ${closestMagistralEndpoint.y.toFixed(1)}, ${closestMagistralEndpoint.z.toFixed(1)})`);\n              createBranchConnections(closestMagistralEndpoint, tenantName, data.edges);\n            }\n          }\n        });\n      }\n      \n      // Create OUTGOING connections (purple) if tenant has outgoing magistrals\n      if (hasOutgoingMagistrals) {\n        console.log(`ðŸŒ¿ Creating OUTGOING connections for ${tenantName}: endpoints â†’ magistral endpoints`);\n            \n        // Find closest magistral endpoints for this tenant\n        magistrals.forEach((magistral, magistralKey) => {\n          if (magistral.sourceTenant === tenantName) {\n            // Calculate magistral endpoints using unified function\n            const targetCenter = tenantCenterPositions.get(magistral.targetTenant);\n            if (targetCenter) {\n              const targetSphereRadius = Math.max(50, Array.from(tenantGroups.get(magistral.targetTenant)?.keys() || []).length) * 15 + 30;\n              \n              // Use unified function to calculate magistral endpoints\n              const { sourceEndpoint, targetEndpoint, direction } = calculateMagistralEndpoints(\n                center, targetCenter, sphereRadius, targetSphereRadius\n              );\n              \n              console.log(`ðŸ”§ OUTGOING magistral endpoints for ${tenantName} â†’ ${magistral.targetTenant} (UNIFIED):`);\n              console.log(`   Source center: (${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)})`);\n              console.log(`   Target center: (${targetCenter.x.toFixed(1)}, ${targetCenter.y.toFixed(1)}, ${targetCenter.z.toFixed(1)})`);\n              console.log(`   Source sphere radius: ${sphereRadius}`);\n              console.log(`   Target sphere radius: ${targetSphereRadius}`);\n              console.log(`   Direction vector: (${direction.x.toFixed(3)}, ${direction.y.toFixed(3)}, ${direction.z.toFixed(3)})`);\n              console.log(`   Source endpoint: (${sourceEndpoint.x.toFixed(1)}, ${sourceEndpoint.y.toFixed(1)}, ${sourceEndpoint.z.toFixed(1)})`);\n              console.log(`   Target endpoint: (${targetEndpoint.x.toFixed(1)}, ${targetEndpoint.y.toFixed(1)}, ${targetEndpoint.z.toFixed(1)})`);\n              \n              // For outgoing connections, find which endpoint is closer to tenant's endpoints\n              const tenantNodes = data.nodes.filter(node => node.tenant === tenantName);\n              let closestMagistralEndpoint = sourceEndpoint;\n              let minTotalDistance = Infinity;\n              \n              [sourceEndpoint, targetEndpoint].forEach(endpoint => {\n                let totalDistance = 0;\n                tenantNodes.forEach(node => {\n                  const endpointKey = `endpoint-${node.id}`;\n                  const existingCylinder = sceneObjectsRef.current.get(endpointKey) as THREE.Mesh;\n                  if (existingCylinder) {\n                    totalDistance += endpoint.distanceTo(existingCylinder.position);\n                  }\n                });\n                \n                if (totalDistance < minTotalDistance) {\n                  minTotalDistance = totalDistance;\n                  closestMagistralEndpoint = endpoint;\n                }\n              });\n              console.log(`ðŸŒ¿ Found ${tenantNodes.length} nodes in tenant ${tenantName} for outgoing branches:`, tenantNodes.map(n => n.id));\n              \n              tenantNodes.forEach(sourceNode => {\n                // Find existing cylinder for this endpoint to get its position\n                const endpointKey = `endpoint-${sourceNode.id}`;\n                const existingCylinder = sceneObjectsRef.current.get(endpointKey) as THREE.Mesh;\n                \n                if (existingCylinder) {\n                  const endpointPosition = existingCylinder.position.clone();\n                  const branchKey = `branch-out-${tenantName}-${magistral.targetTenant}-${sourceNode.id}`;\n                  \n                  if (!sceneObjectsRef.current.has(branchKey)) {\n                    console.log(`ðŸŒ¿ Creating outgoing branch: ${sourceNode.id} â†’ closest magistral endpoint for ${magistral.targetTenant}`);\n                    \n                    // Create simple line connection from endpoint to closest magistral endpoint\n                    const points = [endpointPosition.clone(), closestMagistralEndpoint.clone()];\n                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n                    const lineMaterial = new THREE.LineBasicMaterial({ \n                      color: 0x10B981, // Green for outgoing (request) connections\n                      linewidth: 3 \n                    });\n                    const lineMesh = new THREE.Line(lineGeometry, lineMaterial);\n                    \n                    // Add arrow on outgoing branch\n                    const direction = new THREE.Vector3().subVectors(closestMagistralEndpoint, endpointPosition);\n                    if (direction.length() > 0) {\n                      direction.normalize();\n                      const arrowPosition = endpointPosition.clone().add(direction.multiplyScalar(50));\n                      const arrowGroup = createDirectionalArrow(scene, arrowPosition, direction, 0x10B981, 0.5);\n                      sceneObjectsRef.current.set(`${branchKey}-arrow`, arrowGroup);\n                    }\n                    \n                    lineMesh.userData = {\n                      isBranch: true,\n                      isOutgoing: true,\n                      tenantName: tenantName,\n                      targetTenant: magistral.targetTenant,\n                      endpointId: sourceNode.id,\n                      branchType: 'outgoing'\n                    };\n                    \n                    scene.add(lineMesh);\n                    sceneObjectsRef.current.set(branchKey, lineMesh);\n                    \n                    console.log(`âœ… Created outgoing branch connection with arrow: ${branchKey} for tenant ${tenantName} endpoint ${sourceNode.id} â†’ closest magistral to ${magistral.targetTenant}`);\n                  } else {\n                    // If spacing changed, force remove existing outgoing branch connection to recreate with correct positions\n                    if (spacingChanged) {\n                      console.log(`ðŸ›£ï¸ [SPACING FIX] Force removing existing outgoing branch: ${branchKey} due to spacing change`);\n                      const existingConnection = sceneObjectsRef.current.get(branchKey);\n                      const existingArrow = sceneObjectsRef.current.get(`${branchKey}-arrow`);\n                      \n                      if (existingConnection && scene) {\n                        scene.remove(existingConnection);\n                        sceneObjectsRef.current.delete(branchKey);\n                      }\n                      if (existingArrow && scene) {\n                        scene.remove(existingArrow);\n                        sceneObjectsRef.current.delete(`${branchKey}-arrow`);\n                      }\n                      \n                      // Now recreate the outgoing branch with correct coordinates\n                      console.log(`ðŸŒ¿ Recreating outgoing branch: ${sourceNode.id} â†’ closest magistral endpoint for ${magistral.targetTenant}`);\n                      \n                      // Create simple line connection from endpoint to closest magistral endpoint\n                      const points = [endpointPosition.clone(), closestMagistralEndpoint.clone()];\n                      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);\n                      const lineMaterial = new THREE.LineBasicMaterial({ \n                        color: 0x10B981, // Green for outgoing (request) connections\n                        linewidth: 3 \n                      });\n                      const lineMesh = new THREE.Line(lineGeometry, lineMaterial);\n                      \n                      // Add arrow on outgoing branch\n                      const direction = new THREE.Vector3().subVectors(closestMagistralEndpoint, endpointPosition);\n                      if (direction.length() > 0) {\n                        direction.normalize();\n                        const arrowPosition = endpointPosition.clone().add(direction.multiplyScalar(50));\n                        const arrowGroup = createDirectionalArrow(scene, arrowPosition, direction, 0x10B981, 0.5);\n                        sceneObjectsRef.current.set(`${branchKey}-arrow`, arrowGroup);\n                      }\n                      \n                      lineMesh.userData = {\n                        isBranch: true,\n                        isOutgoing: true,\n                        tenantName: tenantName,\n                        targetTenant: magistral.targetTenant,\n                        endpointId: sourceNode.id,\n                        branchType: 'outgoing'\n                      };\n                      \n                      scene.add(lineMesh);\n                      sceneObjectsRef.current.set(branchKey, lineMesh);\n                      \n                      console.log(`âœ… Recreated outgoing branch connection with arrow: ${branchKey} for tenant ${tenantName} endpoint ${sourceNode.id} â†’ closest magistral to ${magistral.targetTenant}`);\n                    } else {\n                      console.log(`âš ï¸ Outgoing branch connection already exists: ${branchKey}`);\n                    }\n                  }\n                } else {\n                  console.log(`âš ï¸ No cylinder found for outgoing endpoint: ${endpointKey} (trying endpoint- prefix)`);\n                }\n              });\n            }\n          }\n        });\n      }\n      \n      if (!hasIncomingMagistrals && !hasOutgoingMagistrals) {\n        console.log(`âš ï¸ No magistrals found for tenant ${tenantName} - skipping branch connections`);\n      }\n    });\n\n    // Animation loop\n    let animationFrameCount = 0;\n    const animate = () => {\n      frameRef.current = requestAnimationFrame(animate);\n      animationFrameCount++;\n      \n      // Log animation status every 60 frames (roughly 1 second)\n      if (animationFrameCount % 60 === 0) {\n        console.log('ðŸŽ¬ Animation running, frame:', animationFrameCount);\n      }\n      \n      // Smooth camera rotation and panning\n      currentRotationX += (targetRotationX - currentRotationX) * 0.05;\n      currentRotationY += (targetRotationY - currentRotationY) * 0.05;\n      panX += (targetPanX - panX) * 0.05;\n      panY += (targetPanY - panY) * 0.05;\n      \n      // Always keep camera state updated for instant preservation during data updates\n      cameraStateRef.current = {\n        rotationX: currentRotationX,\n        rotationY: currentRotationY,\n        distance: cameraDistance,\n        panX: panX,\n        panY: panY\n      };\n      \n      // Calculate camera position using proper spherical coordinates\n      // Prevent gimbal lock and coordinate system flipping by constraining rotation angles\n      const constrainedRotationX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, currentRotationX));\n      \n      // Use standard spherical coordinate system: r, theta (azimuth), phi (elevation)\n      // theta = currentRotationY (horizontal rotation around Y axis)\n      // phi = constrainedRotationX (vertical rotation, constrained to avoid flipping)\n      const radius = cameraDistance;\n      const theta = currentRotationY;\n      const phi = constrainedRotationX;\n      \n      // Convert spherical to cartesian coordinates\n      const cosTheta = Math.cos(theta);\n      const sinTheta = Math.sin(theta);\n      const cosPhi = Math.cos(phi);\n      const sinPhi = Math.sin(phi);\n      \n      const baseX = radius * cosPhi * sinTheta;\n      const baseY = radius * sinPhi;\n      const baseZ = radius * cosPhi * cosTheta;\n      \n      // Apply panning offset\n      camera.position.x = baseX + panX;\n      camera.position.y = baseY + panY;\n      camera.position.z = baseZ;\n      \n      // Always look at the center point with pan offset\n      camera.lookAt(panX, panY, 0);\n      \n      // Ensure camera maintains consistent up vector to prevent flipping\n      camera.up.set(0, 1, 0);\n      \n      // Update constrained rotation values for cube synchronization\n      currentRotationX = constrainedRotationX;\n      \n      // Update dynamic lighting to follow camera for consistent illumination\n      const dynamicLightGroup = scene.getObjectByName('dynamicLighting');\n      if (!dynamicLightGroup) {\n        const group = new THREE.Group();\n        group.name = 'dynamicLighting';\n        \n        // Camera-following light for guaranteed illumination\n        const cameraLight = new THREE.DirectionalLight(0xffffff, 2.0);\n        cameraLight.name = 'cameraLight';\n        group.add(cameraLight);\n        \n        scene.add(group);\n      } else {\n        // Update camera light position to follow camera\n        const cameraLight = dynamicLightGroup.getObjectByName('cameraLight') as THREE.DirectionalLight;\n        if (cameraLight) {\n          cameraLight.position.copy(camera.position);\n          cameraLight.target.position.set(panX, panY, 0);\n          cameraLight.target.updateMatrixWorld();\n        }\n      }\n      \n      // Update LOD information in real-time based on distance to nearest visible object\n      if (data && onLODUpdate) {\n        const serviceCount = data.nodes.filter(node => node.service).length;\n        \n        // Find distance to nearest visible object instead of center\n        let nearestObjectDistance = Infinity;\n        \n        // Check distance to all visible tenant spheres and endpoints\n        scene.traverse((object) => {\n          if (object instanceof THREE.Mesh) {\n            // Check tenant spheres and endpoint cylinders\n            if (object.userData?.isTenantSphere || object.userData?.isEndpoint) {\n              const distance = camera.position.distanceTo(object.position);\n              nearestObjectDistance = Math.min(nearestObjectDistance, distance);\n            }\n          }\n        });\n        \n        // Fallback to center distance if no objects found\n        const currentCameraDistance = nearestObjectDistance === Infinity ? camera.position.length() : nearestObjectDistance;\n        \n        // Get current spacing settings to calculate actual scheme bounds\n        const currentNodeSpacing = settings.nodeSpacing || 120;\n        const currentClusterSpacing = settings.clusterSpacing || 600;\n        \n        // Calculate scheme bounds based on actual rendered positions (accounting for spacing)\n        const tenants = [...new Set(data.nodes.map(n => n.tenant).filter(Boolean))];\n        const tenantCount = tenants.length;\n        \n        // Estimate actual scheme bounds based on tenant grid layout and spacing\n        const tenantsPerRow = Math.ceil(Math.sqrt(tenantCount));\n        const gridWidth = (tenantsPerRow - 1) * currentClusterSpacing;\n        const gridHeight = (Math.ceil(tenantCount / tenantsPerRow) - 1) * currentClusterSpacing;\n        \n        // Use more reasonable cluster radius based on actual service layout\n        const tenantClusterRadius = currentNodeSpacing * 1.5;\n        \n        const schemeWidth = Math.max(gridWidth + tenantClusterRadius, 400);\n        const schemeHeight = Math.max(200, 200); // Cylinder height\n        const schemeDepth = Math.max(gridHeight + tenantClusterRadius, 400);\n        const schemeDiagonal = Math.sqrt(schemeWidth * schemeWidth + schemeHeight * schemeHeight + schemeDepth * schemeDepth);\n        \n        // Calculate practical camera zoom range based on nearest object distance\n        const minPracticalDistance = 50;   // Minimum distance to any object\n        const maxPracticalDistance = schemeDiagonal * 0.8;  // 80% of diagonal for overview\n        const practicalRange = maxPracticalDistance - minPracticalDistance;\n        \n        // Normalize current camera distance to 0-1 based on practical range\n        const normalizedDistance = Math.max(0, Math.min(1, \n          (currentCameraDistance - minPracticalDistance) / practicalRange));\n        \n        // LOD thresholds based on distance to nearest object\n        const mediumThreshold = 0.20;  // 20% of practical range - closer to objects = high detail\n        const lowThreshold = 0.40;     // 40% of practical range - further = low detail\n        \n        // For display, show relative distance as percentage\n        const relativeDistance = normalizedDistance;\n        \n        let lodLevel: 'high' | 'medium' | 'low' = 'high';\n        \n        // Distance based LOD using normalized distance\n        if (normalizedDistance > lowThreshold) {\n          lodLevel = 'low';\n        } else if (normalizedDistance > mediumThreshold) {\n          lodLevel = 'medium';  \n        } else {\n          lodLevel = 'high'; // Close distance = high detail\n        }\n        \n        // Service count override only for extreme cases\n        if (serviceCount > 100) {\n          lodLevel = 'low';\n        }\n        \n        // Debug log when LOD level changes OR every 300 frames for spacing debugging\n        if (lastLODLevelRef.current !== lodLevel || animationFrameCount % 300 === 0) {\n          console.log(`ðŸŽ¯ Animation LOD: ${lodLevel} (services: ${serviceCount}, distance to nearest: ${relativeDistance.toFixed(2)}x, thresholds: high<${mediumThreshold.toFixed(2)}x, medium=${mediumThreshold.toFixed(2)}x-${lowThreshold.toFixed(2)}x, low>${lowThreshold.toFixed(2)}x)`);\n          console.log(`ðŸŽ¯ Diagram Size: width=${Math.round(schemeWidth)}, height=${Math.round(schemeHeight)}, depth=${Math.round(schemeDepth)}, diagonal=${Math.round(schemeDiagonal)}`);\n          console.log(`ðŸŽ¯ Camera: nearest object distance=${Math.round(currentCameraDistance)}, spacing: node=${currentNodeSpacing}, cluster=${currentClusterSpacing}`);\n          lastLODLevelRef.current = lodLevel;\n        }\n        \n        // LOD system working correctly\n        \n        // Update parent component with current LOD data\n        onLODUpdate(lodLevel, relativeDistance, serviceCount);\n        \n        // Apply LOD optimizations to existing scene objects\n        scene.traverse((object) => {\n          // LOD optimization for cylinder geometry - more aggressive differences\n          if (object.userData?.isService && object instanceof THREE.Mesh) {\n            const cylinderGeometry = object.geometry as THREE.CylinderGeometry;\n            if (cylinderGeometry) {\n              const newSegments = lodLevel === 'low' ? 4 : lodLevel === 'medium' ? 8 : 32;\n              if (cylinderGeometry.parameters?.radialSegments !== newSegments) {\n                const newGeometry = new THREE.CylinderGeometry(\n                  cylinderGeometry.parameters.radiusTop,\n                  cylinderGeometry.parameters.radiusBottom,\n                  cylinderGeometry.parameters.height,\n                  newSegments\n                );\n                object.geometry.dispose();\n                object.geometry = newGeometry;\n              }\n            }\n          }\n          \n          // Update tenant sphere opacity and visibility based on LOD\n          if (object.userData?.isTenantSphere && object instanceof THREE.Mesh) {\n            const sphereMaterial = object.material as THREE.MeshBasicMaterial;\n            sphereMaterial.opacity = lodLevel === 'low' ? 1.0 : 0.01;\n            sphereMaterial.needsUpdate = true;\n            // Update LOD level in userData for highlighting system\n            object.userData.lodLevel = lodLevel;\n          }\n          \n          // Hide/show cylinders, labels, and arrows based on LOD\n          if (lodLevel === 'low') {\n            // At low LOD, hide most details but keep tenant labels, trunk routes, and main arrows\n            if (object.userData?.isNode || object.userData?.isEndpoint || \n                object.userData?.isBranch || object.userData?.isService) {\n              object.visible = false;\n            }\n            // Hide service and endpoint labels at low LOD\n            if (object.userData?.isServiceLabel || object.userData?.isEndpointLabel) {\n              object.visible = false;\n            }\n            // Keep tenant labels, trunk routes, and arrows visible at all LOD levels\n            if (object.userData?.isTenantLabel || object.userData?.isTrunk || \n                object.userData?.isArrow || object.userData?.isArrowHead || \n                object.userData?.isDirectionIndicator || object.userData?.isTrunkArrow) {\n              object.visible = true;\n            }\n          } else {\n            // At medium/high LOD, show all details\n            if (object.userData?.isNode || object.userData?.isEndpoint || \n                object.userData?.isArrow || object.userData?.isArrowHead || \n                object.userData?.isBranch || object.userData?.isTrunk || object.userData?.isService ||\n                object.userData?.isEndpointLabel || object.userData?.isTenantLabel || object.userData?.isServiceLabel ||\n                object.userData?.isDirectionIndicator || object.userData?.isTrunkArrow) {\n              object.visible = true;\n            }\n          }\n          \n          // LOD optimization for flow indicators\n          if (object.userData?.isFlowIndicator) {\n            if (lodLevel === 'low') {\n              object.visible = false; // Hide flow indicators at low detail\n            } else {\n              object.visible = true;\n            }\n          }\n        });\n      }\n      \n      // Animate flow indicators for data movement\n      scene.traverse((object) => {\n        if (object.userData?.isFlowIndicator && object.userData?.curve) {\n          object.userData.progress += object.userData.speed;\n          if (object.userData.progress > 1) {\n            object.userData.progress = 0;\n          }\n          const point = object.userData.curve.getPoint(object.userData.progress);\n          object.position.copy(point);\n          \n          // Add pulsing effect with vibrant glow\n          const pulse = 1 + 0.4 * Math.sin(Date.now() * 0.015 + object.userData.progress * 12);\n          object.scale.setScalar(pulse);\n        }\n      });\n      \n      // Sync cube rotation with main scene to show current coordinate system orientation\n      // The cube should rotate opposite to camera to show the current coordinate orientation correctly\n      orientationCube.group.rotation.x = -constrainedRotationX;\n      orientationCube.group.rotation.y = -currentRotationY;\n      \n      // Render main scene\n      renderer.clear();\n      renderer.render(scene, camera);\n      \n      // Render orientation cube in top-right corner\n      const width = renderer.domElement.clientWidth;\n      const height = renderer.domElement.clientHeight;\n      const cubeSize = 120;\n      \n      // Clear depth buffer only for cube area to render on top\n      // Convert from DOM coordinates (Y=0 at top) to OpenGL coordinates (Y=0 at bottom)\n      const cubeYOpenGL = height - 10 - cubeSize;\n      renderer.setViewport(width - cubeSize - 10, cubeYOpenGL, cubeSize, cubeSize);\n      renderer.clearDepth();\n      renderer.setClearColor(0xf8f9fa, 0.9); // Light background with transparency\n      renderer.clear(false, true, false); // Clear only color buffer for cube area\n      renderer.render(cubeScene, cubeCamera);\n      \n      // Restore original clear color\n      renderer.setClearColor(0xf0f0f0, 1);\n      \n      // Reset viewport\n      renderer.setViewport(0, 0, width, height);\n    };\n\n    // Start animation\n    console.log('ðŸŽ¬ Starting animation loop');\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      if (mountRef.current && camera && renderer) {\n        camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      // Save camera state before cleanup using current animation variables\n      cameraStateRef.current = {\n        rotationX: currentRotationX,\n        rotationY: currentRotationY,\n        distance: cameraDistance,\n        panX: panX,\n        panY: panY\n      };\n      \n      renderer.domElement.removeEventListener('click', onCanvasClick);\n      renderer.domElement.removeEventListener('mousedown', onMouseDown);\n      renderer.domElement.removeEventListener('mousemove', onCanvasMouseMove);\n      window.removeEventListener('mouseup', onMouseUp);\n      window.removeEventListener('mousemove', onMouseMove);\n      renderer.domElement.removeEventListener('wheel', onWheel);\n      window.removeEventListener('resize', handleResize);\n      \n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      \n      // Don't remove renderer DOM element here - it's managed by the main useEffect\n      \n      // Clean up Three.js resources\n      scene.traverse((object) => {\n        if (object instanceof THREE.Mesh) {\n          object.geometry.dispose();\n          if (object.material instanceof THREE.Material) {\n            object.material.dispose();\n          }\n        }\n      });\n      \n      renderer?.dispose();\n    };\n    \n    // Save current data as previous for next update\n    prevDataRef.current = data;\n  }, [data, settings]);\n\n  // SEPARATE useEffect for spacing changes ONLY\n  useEffect(() => {\n    console.log('ðŸ”„ SEPARATE SPACING USEEFFECT TRIGGERED:', {\n      nodeSpacing: settings.nodeSpacing,\n      clusterSpacing: settings.clusterSpacing,  \n      clusterSpacingY: settings.clusterSpacingY\n    });\n    console.log('ðŸš¨ SPACING USEEFFECT VERSION 2 - SHOULD ALWAYS SHOW ON SPACING CHANGES!');\n    \n    if (!sceneRef.current || !rendererRef.current || !cameraRef.current || !data) {\n      console.log('ðŸ”„ SPACING USEEFFECT: Early return - missing refs or data');\n      return;\n    }\n    \n    // Track spacing changes separately from data changes\n    const currentSpacing = {\n      nodeSpacing: settings.nodeSpacing || 120,\n      clusterSpacing: settings.clusterSpacing || 600,\n      clusterSpacingY: settings.clusterSpacingY || 300\n    };\n    \n    console.log('ðŸ” SPACING USEEFFECT DEBUG:', {\n      currentSpacing,\n      lastSpacing: lastSpacingRef.current,\n      hasLastSpacing: !!lastSpacingRef.current\n    });\n    \n    const spacingChanged = !lastSpacingRef.current || \n        lastSpacingRef.current.nodeSpacing !== currentSpacing.nodeSpacing ||\n        lastSpacingRef.current.clusterSpacing !== currentSpacing.clusterSpacing ||\n        lastSpacingRef.current.clusterSpacingY !== currentSpacing.clusterSpacingY;\n        \n    console.log('ðŸ” SPACING USEEFFECT CHANGE DETECTION:', {\n      spacingChanged,\n      nodeSpacingChanged: lastSpacingRef.current ? lastSpacingRef.current.nodeSpacing !== currentSpacing.nodeSpacing : 'no prev',\n      clusterSpacingChanged: lastSpacingRef.current ? lastSpacingRef.current.clusterSpacing !== currentSpacing.clusterSpacing : 'no prev',\n      clusterSpacingYChanged: lastSpacingRef.current ? lastSpacingRef.current.clusterSpacingY !== currentSpacing.clusterSpacingY : 'no prev'\n    });\n    \n    if (spacingChanged) {\n      console.log('ðŸ“ SPACING USEEFFECT: SPACING CHANGED DETECTED - FORCING FULL CACHE CLEAR:', {\n        previous: lastSpacingRef.current,\n        current: currentSpacing,\n        sceneObjectsSize: sceneObjectsRef.current.size,\n        sceneChildrenCount: sceneRef.current.children.length\n      });\n      \n      // IMMEDIATE CACHE CLEAR FOR SPACING CHANGES\n      console.log('ðŸ§¹ SPACING USEEFFECT: Clearing cache for spacing change');\n      sceneObjectsRef.current.clear();\n      \n      // FORCE RESET PREVIOUS DATA to ensure full rebuild\n      prevDataRef.current = null;\n      \n      // Update lastSpacingRef AFTER clearing cache\n      lastSpacingRef.current = currentSpacing;\n      console.log('ðŸ“ SPACING USEEFFECT: Updated lastSpacingRef to:', lastSpacingRef.current);\n      \n      // Trigger scene update\n      console.log('ðŸ”„ SPACING USEEFFECT: Triggering updateSceneIncrementally...');\n      updateSceneIncrementally(sceneRef.current, rendererRef.current, cameraRef.current, data, sceneObjectsRef.current);\n    }\n  }, [settings.nodeSpacing, settings.clusterSpacing, settings.clusterSpacingY, JSON.stringify(settings)]);\n\n  // Handle brightness changes in real-time\n  useEffect(() => {\n    const renderer = rendererRef.current;\n    if (renderer) {\n      renderer.toneMappingExposure = 2.5 * (settings.brightness || 1.0);\n    }\n  }, [settings.brightness]);\n\n  // Track if highlighting has been applied to prevent multiple passes\n  const highlightingAppliedRef = useRef<string | null>(null);\n  \n  // Handle trace highlighting - Updated at 9:04 PM\n  useEffect(() => {\n    const timestamp = new Date().toISOString();\n    console.log(`ðŸŽ¯ [${timestamp}] Trace highlighting useEffect START - VERSION 3`);\n    console.warn(`ðŸš¨ [${timestamp}] NEW CODE EXECUTING - If you see this, the update worked!`);\n    \n    if (!sceneRef.current || !data) {\n      console.log(`ðŸŽ¯ [${timestamp}] Early return - no scene or data`);\n      return;\n    }\n    \n    // Always allow re-highlighting for user selections\n    // Note: This allows visual feedback when user clicks trace IDs\n    \n    // Mark as applied before doing the work\n    highlightingAppliedRef.current = selectedTraceId;\n\n    console.log(`ðŸŽ¯ [${timestamp}] Trace highlighting useEffect triggered:`, { \n      selectedTraceId, \n      hasScene: !!sceneRef.current,\n      hasData: !!data,\n      nodeCount: data.nodes.length,\n      edgeCount: data.edges.length,\n      sceneObjectKeys: Array.from(sceneObjectsRef.current.keys()).slice(0, 10)\n    });\n    \n    // Add immediate test when trace is selected\n    if (selectedTraceId && data) {\n      console.log('ðŸ§ª TESTING TRACE SELECTION:', {\n        selectedTraceId,\n        relevantEdges: data.edges.filter(e => e.traceId && e.traceId.includes(selectedTraceId)),\n        allTraceIds: data.edges.map(e => e.traceId).filter(Boolean).slice(0, 5)\n      });\n    }\n    \n    // Simplified edge analysis - only show matching edges\n    const matchingTraceEdges = data.edges.filter(e => e.traceId && e.traceId.includes(selectedTraceId));\n    console.log(`ðŸŽ¯ Found ${matchingTraceEdges.length} edges with selected trace ${selectedTraceId}:`);\n    matchingTraceEdges.slice(0, 3).forEach((edge, i) => {\n      console.log(`  â†³ Matching edge ${i}:`, {\n        source: edge.source,\n        target: edge.target,\n        traceId: edge.traceId\n      });\n    });\n    \n\n    \n    // Find nodes we need to highlight\n    const requiredNodeIds = new Set();\n    matchingTraceEdges.forEach(edge => {\n      requiredNodeIds.add(edge.source);\n      requiredNodeIds.add(edge.target);\n    });\n    console.log('ðŸŽ¯ Required nodes for highlighting:', Array.from(requiredNodeIds));\n    \n    // Show coordinates of required nodes\n    Array.from(requiredNodeIds).slice(0, 3).forEach(nodeId => {\n      const node = data.nodes.find(n => n.id === nodeId);\n      if (node) {\n        console.log(`  ðŸ“ Node ${nodeId}:`, {\n          x3d: node.x3d,\n          y3d: node.y3d || 'undefined',\n          z3d: node.z3d,\n          service: node.service,\n          tenant: node.tenant\n        });\n      }\n    });\n    \n    const scene = sceneRef.current;\n    let cylinderCount = 0;\n    let arrowCount = 0;\n    let rebuildCount = 0;\n    \n    // Create set of valid endpoint IDs from data for efficient lookup\n    const validEndpointIds = new Set(data.nodes.map(node => node.id));\n    \n    const traverseTimestamp = new Date().toISOString();\n    console.log(`ðŸ”§ [${traverseTimestamp}] DEBUG: Combined traverse - rebuilding userData AND highlighting`);\n    console.log(`ðŸ”§ [${traverseTimestamp}] Valid endpoint IDs:`, Array.from(validEndpointIds).slice(0, 10), '... (total:', validEndpointIds.size, ')');\n    console.log(`ðŸ”§ [${traverseTimestamp}] Sample node IDs from data:`, data.nodes.slice(0, 5).map(n => ({ id: n.id, label: n.label, service: n.service })));\n    \n    let totalCylinders = 0;\n    let cylindersWithNodeId = 0;\n    let cylindersInValidIds = 0;\n    \n    scene.traverse((object) => {\n      // Debug tenant spheres first\n      if (object instanceof THREE.Mesh && object.userData?.isTenantSphere) {\n        console.log(`ðŸ” Found tenant sphere:`, {\n          tenantName: object.userData.tenantName,\n          lodLevel: object.userData.lodLevel,\n          visible: object.visible,\n          opacity: object.material.opacity\n        });\n      }\n      \n      // Count and handle only cylinders that correspond to actual endpoints\n      if (object instanceof THREE.Mesh && \n          object.geometry instanceof THREE.CylinderGeometry) {\n        \n        totalCylinders++;\n        \n        // Check if this object has a nodeId that matches our endpoint data\n        const nodeId = object.userData?.nodeId;\n        const hasNodeId = !!nodeId;\n        const isValidEndpoint = nodeId && validEndpointIds.has(nodeId);\n        \n        if (hasNodeId) cylindersWithNodeId++;\n        if (isValidEndpoint) cylindersInValidIds++;\n        \n        // Debug first few cylinders to see nodeId matching\n        if (totalCylinders <= 5) {\n          console.log(`ðŸ” Cylinder #${totalCylinders} analysis:`, { \n            nodeId, \n            hasNodeId,\n            isValidEndpoint,\n            userData: Object.keys(object.userData || {}),\n            position: { x: object.position.x, y: object.position.y, z: object.position.z }\n          });\n        }\n        \n        if (isValidEndpoint) {\n          cylinderCount++;\n        }\n      }\n      \n      if (object instanceof THREE.Line || (object instanceof THREE.Mesh && object.userData?.isArrowHead)) {\n        arrowCount++;\n      }\n      \n      // Handle ONLY cylinders that correspond to actual endpoints\n      if (object instanceof THREE.Mesh && \n          object.geometry instanceof THREE.CylinderGeometry &&\n          object.userData?.nodeId &&\n          validEndpointIds.has(object.userData.nodeId)) {\n        rebuildCount++;\n        \n        // Track specific endpoint during highlight\n        const isTrackedEndpoint = object.userData?.nodeId === 'gateway-metrics_route_request';\n        \n        if (isTrackedEndpoint) {\n          console.log('ðŸŽ¯ TRACKED ENDPOINT - Found during highlight:', {\n            nodeId: object.userData?.nodeId,\n            selectedTraceId,\n            fullUserData: JSON.stringify(object.userData),\n            position: { x: object.position.x, y: object.position.y, z: object.position.z }\n          });\n        }\n        \n        // Note: At this point we already filtered by validEndpointIds, so object should have valid nodeId\n        \n        const material = object.material as THREE.MeshBasicMaterial;\n        const nodeId = object.userData?.nodeId;\n        \n        // Debug first few cylinders found during traverse\n        if (cylinderCount < 2) {\n          console.log('ðŸ” Found cylinder during traverse:', {\n            objectType: object.type,\n            nodeId,\n            actualNodeId: object.userData?.nodeId,\n            nodeIdIsUndefined: object.userData?.nodeId === undefined,\n            hasUserData: !!object.userData,\n            isEndpoint: object.userData?.isEndpoint,\n            userDataKeys: object.userData ? Object.keys(object.userData) : [],\n            userDataStringified: JSON.stringify(object.userData),\n            position: { x: object.position.x, y: object.position.y, z: object.position.z }\n          });\n          \n          // Test userData assignment on this object\n          console.log('ðŸ§ª Testing userData assignment on this object...');\n          const originalUserData = { ...object.userData };\n          object.userData.testField = 'test-value-123';\n          console.log('After test assignment:', {\n            testField: object.userData?.testField,\n            userDataKeys: Object.keys(object.userData),\n            userDataStringified: JSON.stringify(object.userData)\n          });\n          \n          // CRITICAL FIX: Restore original userData correctly without losing nodeId\n          delete object.userData.testField;  // Just remove the test field instead of overwriting entire userData\n        }\n        \n        if (selectedTraceId) {\n          // Debug: Log that we're processing a cylinder for highlighting\n          if (rebuildCount <= 5) {\n            console.log(`ðŸŽ¯ Processing cylinder #${rebuildCount} for highlighting:`, {\n              nodeId,\n              rebuildCount,\n              selectedTraceId,\n              hasNodeId: !!nodeId,\n              isInValidIds: validEndpointIds.has(nodeId)\n            });\n          }\n          \n          // CRITICAL FIX: Skip highlighting for cylinders without nodeId\n          if (!nodeId) {\n            // Only dim cylinders without nodeId when a trace is selected\n            if (selectedTraceId) {\n              if (!object.userData.originalColor) {\n                object.userData.originalColor = material.color.getHex();\n              }\n              material.color.setHex(0x666666);\n              material.transparent = true;\n              material.opacity = 0.3;\n              material.needsUpdate = true;\n            }\n            \n            if (cylinderCount < 3) {\n              console.log('ðŸ” Dimming cylinder without nodeId:', { \n                nodeId, \n                selectedTraceId,\n                hasNodeId: !!nodeId\n              });\n            }\n            return; // Skip further processing\n          }\n          \n          // FIXED: Use the pre-calculated requiredNodeIds set\n          const isRelatedToTrace = requiredNodeIds.has(nodeId);\n          \n          // Debug logging for trace-related nodes\n          if (cylinderCount <= 5 || requiredNodeIds.has(nodeId)) {\n            console.log(`ðŸŽ¯ NODE TRACE CHECK #${cylinderCount}:`, {\n              nodeId,\n              isRelatedToTrace,\n              isInRequiredSet: requiredNodeIds.has(nodeId),\n              selectedTraceId,\n              requiredNodesCount: requiredNodeIds.size,\n              allRequiredNodes: Array.from(requiredNodeIds)\n            });\n          }\n          \n          // originalColor should already be set from creation, never overwrite it here\n          if (!object.userData.originalColor) {\n            console.error('âš ï¸ CRITICAL: originalColor missing on cylinder!', {\n              nodeId,\n              currentColor: material.color.getHex(),\n              userData: object.userData\n            });\n          }\n          \n          // Enhanced logging for trace highlighting\n          if (selectedTraceId && cylinderCount <= 5) {\n            console.log(`ðŸŽ¨ CYLINDER COLOR PROCESSING #${cylinderCount}:`, {\n              nodeId,\n              isRelatedToTrace,\n              selectedTraceId,\n              currentColorBefore: material.color.getHex(),\n              originalColor: object.userData.originalColor,\n              materialColor: material.color.getHex()\n            });\n          }\n          \n          if (isRelatedToTrace) {\n            // Keep original color but ensure it's bright and vivid\n            const originalColor = object.userData.originalColor || 0xFFFFFF;\n            const highlightMaterial = new THREE.MeshBasicMaterial({\n              color: originalColor, // Keep original color\n              transparent: false,\n              opacity: 1.0\n            });\n            object.material = highlightMaterial;\n            \n            // Always log trace-related highlighting - SPECIAL CASE: always log required nodes\n            console.log('âœ… HIGHLIGHTING cylinder:', { \n              nodeId, \n              originalColor: object.userData.originalColor,\n              keptOriginalColor: originalColor,\n              materialColorAfterSet: highlightMaterial.color.getHex(),\n              cylinderCount,\n              rebuildCount\n            });\n          } else {\n            // Create new material for dimming to avoid cache interference\n            const dimMaterial = new THREE.MeshBasicMaterial({\n              color: 0x666666, // Gray color\n              transparent: true,\n              opacity: 0.3\n            });\n            object.material = dimMaterial;\n            \n            // Debug log for dimmed cylinders\n            if (cylinderCount < 10) {\n              console.log('â¬œ DIMMING cylinder:', { \n                nodeId, \n                originalColor: object.userData.originalColor,\n                newColorHex: 0x666666,\n                opacity: material.opacity,\n                transparent: material.transparent\n              });\n            }\n          }\n          \n          // Force renderer to update materials immediately\n          if (rendererRef.current && sceneRef.current && cameraRef.current) {\n            rendererRef.current.render(sceneRef.current, cameraRef.current);\n          }\n        } else {\n          // Reset to original color when no trace is selected\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = false;\n          material.opacity = 1.0;\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle service labels (sprites)\n      if (object instanceof THREE.Sprite && object.userData?.isServiceLabel) {\n        const material = object.material as THREE.SpriteMaterial;\n        const serviceName = object.userData.serviceName;\n        \n        if (selectedTraceId) {\n          // Check if this service is related to the selected trace\n          const isRelatedToTrace = data.edges.some(edge => {\n            if (!edge.traceId) return false;\n            const traceIds = edge.traceId.split(',').map(id => id.trim());\n            const isTraceMatch = traceIds.includes(selectedTraceId);\n            // Check if either source or target contains this service name\n            const isServiceMatch = edge.source.includes(serviceName) || edge.target.includes(serviceName);\n            return isTraceMatch && isServiceMatch;\n          });\n          \n          // Store original opacity if not stored\n          if (object.userData.originalOpacity === undefined) {\n            object.userData.originalOpacity = material.opacity;\n          }\n          \n          if (isRelatedToTrace) {\n            // Keep original opacity for highlighted service labels\n            material.opacity = object.userData.originalOpacity || 1.0;\n            material.transparent = material.opacity < 1.0;\n          } else {\n            // Dim non-highlighted service labels\n            material.opacity = 0.2;\n            material.transparent = true;\n          }\n          material.needsUpdate = true;\n        } else {\n          // Reset to original opacity when no trace is selected\n          if (object.userData.originalOpacity !== undefined) {\n            material.opacity = object.userData.originalOpacity;\n            material.transparent = material.opacity < 1.0;\n          } else {\n            material.opacity = 1.0;\n            material.transparent = false;\n          }\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle endpoint labels (sprites without isServiceLabel)\n      if (object instanceof THREE.Sprite && !object.userData?.isServiceLabel && object.userData?.isEndpointLabel) {\n        const material = object.material as THREE.SpriteMaterial;\n        \n        if (selectedTraceId) {\n          // For endpoint labels, check if any related edge is highlighted\n          // Get the key for this label to find associated node\n          const labelKeys = Array.from(sceneObjectsRef.current.keys());\n          const thisLabelKey = labelKeys.find(key => sceneObjectsRef.current.get(key) === object);\n          \n          if (thisLabelKey) {\n            // Extract endpoint ID from label key (format: \"endpoint-label-{endpoint.id}\")\n            const endpointId = thisLabelKey.replace('endpoint-label-', '');\n            \n            // Check if this endpoint is related to the selected trace\n            const isRelatedToTrace = data.edges.some(edge => {\n              if (!edge.traceId) return false;\n              const traceIds = edge.traceId.split(',').map(id => id.trim());\n              const isTraceMatch = traceIds.includes(selectedTraceId);\n              // Check if either source or target matches this endpoint\n              const isEndpointMatch = edge.source === endpointId || edge.target === endpointId;\n              return isTraceMatch && isEndpointMatch;\n            });\n            \n            // Debug logging for first few endpoint labels\n            if (!object.userData.debugged) {\n              console.log('ðŸ” Endpoint label highlight:', {\n                thisLabelKey,\n                endpointId,\n                isRelatedToTrace,\n                selectedTraceId,\n                matchingEdges: data.edges.filter(e => e.traceId && e.traceId.includes(selectedTraceId) && (e.source === endpointId || e.target === endpointId)),\n                allRelevantEdges: data.edges.filter(e => e.source === endpointId || e.target === endpointId).slice(0, 3),\n                objectUserData: object.userData\n              });\n              object.userData.debugged = true;\n            }\n            \n            // Store original opacity if not stored\n            if (object.userData.originalOpacity === undefined) {\n              object.userData.originalOpacity = material.opacity;\n            }\n            \n            if (isRelatedToTrace) {\n              // Keep original opacity for highlighted endpoint labels\n              material.opacity = object.userData.originalOpacity || 1.0;\n              material.transparent = material.opacity < 1.0;\n            } else {\n              // Dim non-highlighted endpoint labels\n              material.opacity = 0.2;\n              material.transparent = true;\n            }\n            material.needsUpdate = true;\n          }\n        } else {\n          // Reset to original opacity when no trace is selected\n          if (object.userData.originalOpacity !== undefined) {\n            material.opacity = object.userData.originalOpacity;\n            material.transparent = material.opacity < 1.0;\n          } else {\n            material.opacity = 1.0;\n            material.transparent = false;\n          }\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle arrows (edges)\n      if (object instanceof THREE.Line && object.userData?.isArrow) {\n        const material = object.material as THREE.LineBasicMaterial;\n        const edgeData = object.userData.edgeData;\n        \n        if (selectedTraceId && edgeData?.traceId) {\n          const traceIds = edgeData.traceId.split(',').map((id: string) => id.trim());\n          const isRelatedToTrace = traceIds.includes(selectedTraceId);\n          \n          // Store original color if not stored\n          if (!object.userData.originalColor) {\n            object.userData.originalColor = material.color.getHex();\n          }\n          \n          if (isRelatedToTrace) {\n            material.color.setHex(object.userData.originalColor);\n            material.transparent = false;\n            material.opacity = 1.0;\n          } else {\n            material.color.setHex(0x888888);\n            material.transparent = true;\n            material.opacity = 0.2;\n          }\n          material.needsUpdate = true;\n        } else {\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = false;\n          material.opacity = 1.0;\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle arrow heads\n      if (object instanceof THREE.Mesh && object.userData?.isArrowHead) {\n        const material = object.material as THREE.MeshBasicMaterial;\n        const edgeData = object.userData.edgeData;\n        \n        if (selectedTraceId && edgeData?.traceId) {\n          const traceIds = edgeData.traceId.split(',').map((id: string) => id.trim());\n          const isRelatedToTrace = traceIds.includes(selectedTraceId);\n          \n          // Store original color if not stored\n          if (!object.userData.originalColor) {\n            object.userData.originalColor = material.color.getHex();\n          }\n          \n          if (isRelatedToTrace) {\n            material.color.setHex(object.userData.originalColor);\n            material.transparent = false;\n            material.opacity = 1.0;\n          } else {\n            material.color.setHex(0x888888);\n            material.transparent = true;\n            material.opacity = 0.2;\n          }\n          material.needsUpdate = true;\n        } else {\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = false;\n          material.opacity = 1.0;\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle magistral lines highlighting\n      if (object instanceof THREE.Mesh && object.userData?.isMagistral) {\n        const material = object.material as THREE.MeshBasicMaterial;\n        const sourceTenant = object.userData.sourceTenant;\n        const targetTenant = object.userData.targetTenant;\n        \n        if (selectedTraceId && sourceTenant && targetTenant) {\n          // Check if there's a connection in the selected trace that crosses this magistral\n          const isRelatedToTrace = data.edges.some(edge => {\n            if (!edge.traceId) return false;\n            const traceIds = edge.traceId.split(',').map(id => id.trim());\n            const isTraceMatch = traceIds.includes(selectedTraceId);\n            \n            if (!isTraceMatch) return false;\n            \n            // Get tenant info for edge endpoints\n            const sourceNode = data.nodes.find(n => n.id === edge.source);\n            const targetNode = data.nodes.find(n => n.id === edge.target);\n            \n            if (!sourceNode || !targetNode) return false;\n            \n            // Check if this edge crosses between the magistral's tenants in either direction\n            const crossesDirectly = (sourceNode.tenant === sourceTenant && targetNode.tenant === targetTenant);\n            const crossesReverse = (sourceNode.tenant === targetTenant && targetNode.tenant === sourceTenant);\n            \n            return crossesDirectly || crossesReverse;\n          });\n          \n          // Store original color if not stored\n          if (!object.userData.originalColor) {\n            object.userData.originalColor = material.color.getHex();\n          }\n          \n          if (isRelatedToTrace) {\n            material.color.setHex(object.userData.originalColor);\n            material.transparent = false;\n            material.opacity = 1.0;\n          } else {\n            material.color.setHex(0x666666);\n            material.transparent = true;\n            material.opacity = 0.3;\n          }\n          material.needsUpdate = true;\n        } else {\n          // Reset to original color when no trace is selected\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = false;\n          material.opacity = 1.0;\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle magistral arrows highlighting\n      if (object instanceof THREE.Mesh && object.userData?.isMagistralArrow) {\n        const material = object.material as THREE.MeshBasicMaterial;\n        const magistralKey = object.userData.magistralKey;\n        \n        if (selectedTraceId && magistralKey) {\n          // Extract tenant names from magistralKey (format: \"sourceTenant->targetTenant\")\n          // magistralKey is stored as the actual key like \"api-gateway->content-management\"\n          const keyParts = magistralKey.split('->');\n          if (keyParts.length === 2) {\n            const sourceTenant = keyParts[0];\n            const targetTenant = keyParts[1];\n            \n            // Check if there's a connection in the selected trace that crosses this magistral\n            const isRelatedToTrace = data.edges.some(edge => {\n              if (!edge.traceId) return false;\n              const traceIds = edge.traceId.split(',').map(id => id.trim());\n              const isTraceMatch = traceIds.includes(selectedTraceId);\n              \n              if (!isTraceMatch) return false;\n              \n              // Get tenant info for edge endpoints\n              const sourceNode = data.nodes.find(n => n.id === edge.source);\n              const targetNode = data.nodes.find(n => n.id === edge.target);\n              \n              if (!sourceNode || !targetNode) return false;\n              \n              // Check if this edge crosses between the magistral's tenants in either direction\n              const crossesDirectly = (sourceNode.tenant === sourceTenant && targetNode.tenant === targetTenant);\n              const crossesReverse = (sourceNode.tenant === targetTenant && targetNode.tenant === sourceTenant);\n              \n              const crosses = crossesDirectly || crossesReverse;\n              if (crosses) {\n                console.log(`ðŸŒ‰ Magistral ${sourceTenant}-${targetTenant} highlighted by trace ${selectedTraceId}:`, {\n                  edge: `${edge.source} â†’ ${edge.target}`,\n                  sourceTenant: sourceNode.tenant,\n                  targetTenant: targetNode.tenant,\n                  crossesDirectly,\n                  crossesReverse\n                });\n              }\n              \n              return crosses;\n            });\n            \n            console.log(`ðŸ¹ Magistral arrow ${magistralKey} analysis:`, {\n              sourceTenant,\n              targetTenant,\n              selectedTraceId,\n              isRelatedToTrace,\n              keyParts\n            });\n            \n            // Store original color if not stored\n            if (!object.userData.originalColor) {\n              object.userData.originalColor = material.color.getHex();\n            }\n            \n            if (isRelatedToTrace) {\n              material.color.setHex(object.userData.originalColor);\n              material.transparent = false;\n              material.opacity = 1.0;\n            } else {\n              material.color.setHex(0x666666);\n              material.transparent = true;\n              material.opacity = 0.3;\n            }\n            material.needsUpdate = true;\n          }\n        } else {\n          // Reset to original color when no trace is selected\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = false;\n          material.opacity = 1.0;\n          material.needsUpdate = true;\n        }\n      }\n      \n      // Handle tenant spheres highlighting (for LOD low mode)\n      if (object instanceof THREE.Mesh && object.userData?.isTenantSphere) {\n        const material = object.material as THREE.MeshBasicMaterial;\n        const tenantName = object.userData.tenantName;\n        \n        if (selectedTraceId && tenantName) {\n          // Check if this tenant has any connections in the selected trace\n          const isRelatedToTrace = data.edges.some(edge => {\n            if (!edge.traceId) return false;\n            const traceIds = edge.traceId.split(',').map(id => id.trim());\n            const isTraceMatch = traceIds.includes(selectedTraceId);\n            \n            if (!isTraceMatch) return false;\n            \n            // Get tenant info for edge endpoints\n            const sourceNode = data.nodes.find(n => n.id === edge.source);\n            const targetNode = data.nodes.find(n => n.id === edge.target);\n            \n            if (!sourceNode || !targetNode) return false;\n            \n            // Check if either endpoint belongs to this tenant\n            return sourceNode.tenant === tenantName || targetNode.tenant === tenantName;\n          });\n          \n          console.log(`ðŸŒ Tenant sphere ${tenantName} analysis:`, {\n            tenantName,\n            selectedTraceId,\n            isRelatedToTrace,\n            currentLOD: object.userData.lodLevel\n          });\n          \n          // Store original color if not stored\n          if (!object.userData.originalColor) {\n            object.userData.originalColor = material.color.getHex();\n          }\n          \n          if (isRelatedToTrace) {\n            material.color.setHex(object.userData.originalColor);\n            material.transparent = true;\n            material.opacity = object.userData.lodLevel === 'low' ? 0.8 : 0.01; // Highlighted: very visible in LOD low mode\n          } else {\n            material.color.setHex(0x333333);\n            material.transparent = true;\n            material.opacity = object.userData.lodLevel === 'low' ? 0.1 : 0.005; // Dimmed: barely visible\n          }\n          material.needsUpdate = true;\n        } else {\n          // Reset to original color when no trace is selected\n          if (object.userData.originalColor) {\n            material.color.setHex(object.userData.originalColor);\n          }\n          material.transparent = true;\n          material.opacity = object.userData.lodLevel === 'low' ? 1.0 : 0.01;\n          material.needsUpdate = true;\n        }\n      }\n    });\n    \n    if (selectedTraceId) {\n      console.log('ðŸ”¥ Traverse complete summary:', {\n        selectedTraceId,\n        totalCylinders,\n        cylindersWithNodeId,\n        cylindersInValidIds,\n        cylinderCount: cylinderCount + ' (processed)',\n        arrowCount,\n        rebuildCount: rebuildCount + ' (with valid nodeId)',\n        requiredNodes: Array.from(requiredNodeIds),\n        matchingEdges: matchingTraceEdges.length\n      });\n    }\n  }, [selectedTraceId, data]);\n\n  if (!data) {\n    return (\n      <div className=\"flex-1 flex items-center justify-center bg-gray-50\">\n        <div className=\"text-center\">\n          <p className=\"text-lg font-medium text-foreground mb-2\">No data to display</p>\n          <p className=\"text-sm text-muted-foreground\">Upload files to generate 3D cylinder visualization</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex-1 relative\">\n      <div ref={mountRef} className=\"w-full h-full\" />\n      \n      {/* Toggle button for legend */}\n      <button\n        onClick={() => setShowLegend(!showLegend)}\n        className=\"absolute top-4 left-4 bg-white/90 backdrop-blur-sm rounded-lg p-2 shadow-lg hover:bg-white/95 transition-colors\"\n        title={showLegend ? \"Hide legend\" : \"Show legend\"}\n      >\n        <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n        </svg>\n      </button>\n\n      {/* Legend panel */}\n      {showLegend && (\n        <div className=\"absolute top-4 left-16 bg-white/90 backdrop-blur-sm rounded-lg p-4 shadow-lg max-w-64\">\n          <h3 className=\"font-semibold text-sm mb-3 flex items-center\">\n            <div className=\"w-2 h-2 bg-gradient-to-r from-purple-500 to-blue-500 rounded-full mr-2\"></div>\n            3D Network Legend\n          </h3>\n          \n          {/* Controls Section */}\n          <div className=\"space-y-2 text-xs mb-4 p-3 bg-slate-50 rounded-lg border border-slate-200/50\">\n            <div className=\"font-medium text-gray-700\">Controls:</div>\n            <div>â€¢ <strong>Drag</strong> to rotate view</div>\n            <div>â€¢ <strong>Shift + Drag</strong> to pan (move)</div>\n            <div>â€¢ <strong>Scroll</strong> to zoom in/out</div>\n            <div>â€¢ <strong>Click orientation cube</strong> for standard views</div>\n          </div>\n          \n          {/* Visual Elements Section */}\n          <div className=\"space-y-3 text-xs mb-4\">\n            <div className=\"font-medium text-gray-700 mb-2\">Visual Elements:</div>\n            <div className=\"flex items-center gap-2 p-2 bg-blue-50 rounded border border-blue-200/50\">\n              <div className=\"w-3 h-3 rounded bg-gradient-to-b from-blue-500 to-red-500\"></div>\n              <span>Service cylinders</span>\n            </div>\n            <div className=\"flex items-center gap-2 p-2 bg-purple-50 rounded border border-purple-200/50\">\n              <div className=\"w-3 h-3 rounded-full bg-purple-600\"></div>\n              <span>Standalone nodes</span>\n            </div>\n          </div>\n          \n          {/* Traffic Flow Section */}\n          <div className=\"space-y-3 text-xs mb-4\">\n            <div className=\"font-medium text-gray-700 mb-2\">Traffic Flow:</div>\n            <div className=\"flex items-center gap-2 p-2 bg-slate-50 rounded border border-slate-200/50\">\n              <div className=\"w-8 h-px bg-gradient-to-r from-slate-400 to-slate-600 relative\">\n                <div className=\"absolute right-0 top-0 w-0 h-0 border-l-4 border-l-slate-600 border-t-2 border-b-2 border-t-transparent border-b-transparent transform -translate-y-1/2\"></div>\n              </div>\n              <span>Unidirectional flow</span>\n            </div>\n            <div className=\"flex items-center gap-2 p-2 bg-red-50 rounded border border-red-200/50\">\n              <div className=\"w-8 h-px bg-gradient-to-r from-red-400 to-red-600 relative\">\n                <div className=\"absolute right-0 top-0 w-0 h-0 border-l-4 border-l-red-600 border-t-2 border-b-2 border-t-transparent border-b-transparent transform -translate-y-1/2\"></div>\n              </div>\n              <span>Bidirectional flow</span>\n            </div>\n            <div className=\"flex items-center gap-2 p-2 bg-purple-50 rounded border border-purple-200/50\">\n              <div className=\"flex space-x-1\">\n                <div className=\"w-1 h-1 bg-purple-400 rounded-full\"></div>\n                <div className=\"w-1 h-1 bg-purple-500 rounded-full\"></div>\n                <div className=\"w-1 h-1 bg-purple-600 rounded-full\"></div>\n              </div>\n              <span>Connection strength</span>\n            </div>\n          </div>\n          \n          {/* Traffic Types Section */}\n          <div className=\"space-y-3 text-xs\">\n            <div className=\"font-medium text-gray-700 mb-2\">Traffic Types:</div>\n            <div className=\"flex items-center gap-2 p-2 bg-red-50 rounded border border-red-200/50\">\n              <div className=\"w-6 h-0.5 bg-red-600\"></div>\n              <span>Inter-service</span>\n            </div>\n            <div className=\"flex items-center gap-2 p-2 bg-green-50 rounded border border-green-200/50\">\n              <div className=\"w-6 h-0.5 bg-green-600\"></div>\n              <span>Intra-service</span>\n            </div>\n            <div className=\"flex items-center gap-2 p-2 bg-purple-50 rounded border border-purple-200/50\">\n              <div className=\"w-6 h-0.5 bg-purple-600\"></div>\n              <span>External traffic</span>\n            </div>\n          </div>\n\n          {/* Scalability Section */}\n          <div className=\"space-y-2 text-xs mt-4\">\n            <div className=\"font-medium text-gray-700 mb-2\">Scalability Features:</div>\n            <div className=\"grid grid-cols-1 gap-1\">\n              <div className=\"flex items-center gap-2 p-2 bg-blue-50 rounded border border-blue-200/50\">\n                <div className=\"w-3 h-3 rounded bg-gradient-to-r from-blue-400 to-blue-600\"></div>\n                <span>Adaptive LOD system</span>\n              </div>\n              <div className=\"flex items-center gap-2 p-2 bg-green-50 rounded border border-green-200/50\">\n                <div className=\"w-3 h-3 rounded bg-gradient-to-r from-green-400 to-green-600\"></div>\n                <span>Dynamic detail levels</span>\n              </div>\n              <div className=\"flex items-center gap-2 p-2 bg-purple-50 rounded border border-purple-200/50\">\n                <div className=\"w-3 h-3 rounded bg-gradient-to-r from-purple-400 to-purple-600\"></div>\n                <span>100+ service support</span>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      {/* Status tooltip */}\n      {tooltip.visible && (\n        <div \n          className=\"absolute z-50 bg-white border border-gray-300 rounded-lg shadow-lg p-3 pointer-events-none\"\n          style={{\n            left: `${tooltip.x + 15}px`,\n            top: `${tooltip.y - 15}px`\n          }}\n        >\n          <div className=\"text-sm font-semibold mb-2\">\n            {tooltip.sourceLabel} â†’ {tooltip.targetLabel}\n          </div>\n          <div className=\"space-y-1\">\n            {Object.entries(tooltip.statusCounts).length > 0 ? (\n              Object.entries(tooltip.statusCounts)\n                .sort(([a], [b]) => a.localeCompare(b))\n                .map(([status, count]) => (\n                  <div key={status} className=\"flex justify-between items-center text-xs\">\n                    <span className=\"font-mono\">{status}:</span>\n                    <span className=\"ml-4 font-semibold\">{count}</span>\n                  </div>\n                ))\n            ) : (\n              <div className=\"text-xs text-gray-500\">No status data</div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Service Metrics Popup */}\n      {metricsPopup.visible && (\n        <ServiceMetricsPopup\n          serviceName={metricsPopup.serviceName}\n          metrics={metricsPopup.metrics}\n          onClose={() => setMetricsPopup(prev => ({ ...prev, visible: false }))}\n          position={metricsPopup.position}\n        />\n      )}\n    </div>\n  );\n}","size_bytes":180814},"client/src/components/DiagramCanvas.tsx":{"content":"import { useEffect, useRef, useState } from \"react\";\nimport * as d3 from \"d3\";\nimport { Button } from \"@/components/ui/button\";\nimport { ZoomIn, ZoomOut, RotateCcw, Crosshair, Maximize, Image, FileDown } from \"lucide-react\";\nimport { applyLayout, exportAsSVG, exportAsPNG } from \"@/lib/diagramUtils\";\nimport type { DiagramData, DiagramSettings, LayoutType } from \"@/types/diagram\";\n\ninterface DiagramCanvasProps {\n  data: DiagramData | null;\n  settings: DiagramSettings;\n  layout: LayoutType;\n  onApplyLayout?: () => void;\n}\n\nexport default function DiagramCanvas({ data, settings, layout }: DiagramCanvasProps) {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [zoomLevel, setZoomLevel] = useState(100);\n  const [transform, setTransform] = useState(d3.zoomIdentity);\n\n  useEffect(() => {\n    if (!data || !svgRef.current) return;\n\n    const svg = d3.select(svgRef.current);\n    const width = 800;\n    const height = 600;\n\n    // Clear previous content\n    svg.selectAll(\"*\").remove();\n\n    // Apply layout to get positioned nodes\n    const { nodes, edges } = applyLayout(layout, [...data.nodes], [...data.edges], width, height, settings.nodeSpacing);\n\n    // Create zoom behavior\n    const zoom = d3.zoom<SVGSVGElement, unknown>()\n      .scaleExtent([0.1, 3])\n      .on(\"zoom\", (event) => {\n        const { transform } = event;\n        setTransform(transform);\n        setZoomLevel(Math.round(transform.k * 100));\n        g.attr(\"transform\", transform);\n      });\n\n    svg.call(zoom);\n\n    // Create main group for zooming/panning\n    const g = svg.append(\"g\");\n\n    // Define arrow markers for different edge types\n    const defs = svg.append(\"defs\");\n    \n    if (settings.showArrows) {\n      // Standard arrow marker\n      defs.append(\"marker\")\n        .attr(\"id\", \"arrowhead\")\n        .attr(\"viewBox\", \"0 -5 10 10\")\n        .attr(\"refX\", 22)\n        .attr(\"refY\", 0)\n        .attr(\"markerWidth\", 8)\n        .attr(\"markerHeight\", 8)\n        .attr(\"orient\", \"auto\")\n        .append(\"path\")\n        .attr(\"d\", \"M0,-5L10,0L0,5\")\n        .attr(\"fill\", \"#374151\")\n        .attr(\"stroke\", \"none\");\n\n      // Circular dependency arrow marker (different color)\n      defs.append(\"marker\")\n        .attr(\"id\", \"arrowhead-circular\")\n        .attr(\"viewBox\", \"0 -5 10 10\")\n        .attr(\"refX\", 22)\n        .attr(\"refY\", 0)\n        .attr(\"markerWidth\", 8)\n        .attr(\"markerHeight\", 8)\n        .attr(\"orient\", \"auto\")\n        .append(\"path\")\n        .attr(\"d\", \"M0,-5L10,0L0,5\")\n        .attr(\"fill\", \"#DC2626\")\n        .attr(\"stroke\", \"none\");\n    }\n\n    // Detect circular dependencies\n    const circularPairs = new Set<string>();\n    edges.forEach(edge => {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      \n      // Check if reverse edge exists\n      const reverseExists = edges.some(otherEdge => {\n        const otherSourceId = typeof otherEdge.source === 'string' ? otherEdge.source : otherEdge.source.id;\n        const otherTargetId = typeof otherEdge.target === 'string' ? otherEdge.target : otherEdge.target.id;\n        return otherSourceId === targetId && otherTargetId === sourceId;\n      });\n      \n      if (reverseExists) {\n        const pairKey = [sourceId, targetId].sort().join('-');\n        circularPairs.add(pairKey);\n      }\n    });\n\n    // Function to check if two curves would overlap\n    const curvesOverlap = (controlX1: number, controlY1: number, controlX2: number, controlY2: number) => {\n      const dx = controlX2 - controlX1;\n      const dy = controlY2 - controlY1;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      return distance < 40; // Minimum separation threshold\n    };\n\n    // Calculate edge positioning with curves for multiple edges\n    const getEdgeCoordinates = (edge: any, curveOffset: number = 0, allCurves: any[] = []) => {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      const source = nodes.find(n => n.id === sourceId);\n      const target = nodes.find(n => n.id === targetId);\n      \n      if (!source || !target || source.x === undefined || source.y === undefined || target.x === undefined || target.y === undefined) {\n        return { x1: 0, y1: 0, x2: 0, y2: 0, path: null, controlX: 0, controlY: 0 };\n      }\n      \n      // If there's a curve offset, create a curved path\n      if (curveOffset !== 0) {\n        const dx = target.x - source.x;\n        const dy = target.y - source.y;\n        const dr = Math.sqrt(dx * dx + dy * dy);\n        \n        if (dr === 0) {\n          return { x1: source.x, y1: source.y, x2: target.x, y2: target.y, path: null, controlX: 0, controlY: 0 };\n        }\n        \n        // Calculate control point for curve\n        const midX = (source.x + target.x) / 2;\n        const midY = (source.y + target.y) / 2;\n        \n        // Create perpendicular offset for curve\n        let perpX = (-dy / dr) * curveOffset;\n        let perpY = (dx / dr) * curveOffset;\n        \n        let controlX = midX + perpX;\n        let controlY = midY + perpY;\n        \n        // Check for overlaps with existing curves\n        let hasOverlap = false;\n        \n        for (const existingCurve of allCurves) {\n          if (curvesOverlap(controlX, controlY, existingCurve.controlX, existingCurve.controlY)) {\n            hasOverlap = true;\n            break;\n          }\n        }\n        \n        // If overlap detected, mirror the curve to opposite side\n        if (hasOverlap) {\n          perpX = -perpX;\n          perpY = -perpY;\n          controlX = midX + perpX;\n          controlY = midY + perpY;\n        }\n        \n        const path = `M${source.x},${source.y} Q${controlX},${controlY} ${target.x},${target.y}`;\n        return { x1: source.x, y1: source.y, x2: target.x, y2: target.y, path, controlX, controlY };\n      }\n      \n      return { x1: source.x, y1: source.y, x2: target.x, y2: target.y, path: null, controlX: 0, controlY: 0 };\n    };\n\n    // Draw edges with proper handling for circular dependencies\n    const edgeGroup = g.append(\"g\").attr(\"class\", \"edges\");\n    \n    // Create all edges with curves for multiple relationships\n    const allEdges: any[] = [];\n    \n    // Group edges by node pairs to determine curve offsets\n    const edgeGroups = new Map<string, any[]>();\n    edges.forEach((edge, index) => {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      const pairKey = [sourceId, targetId].sort().join('-');\n      \n      if (!edgeGroups.has(pairKey)) {\n        edgeGroups.set(pairKey, []);\n      }\n      edgeGroups.get(pairKey)!.push({ ...edge, originalIndex: index });\n    });\n    \n    // Process each group and assign curve offsets\n    const processedCurves: any[] = [];\n    \n    edgeGroups.forEach((groupEdges, pairKey) => {\n      const isCircular = circularPairs.has(pairKey);\n      \n      groupEdges.forEach((edge, groupIndex) => {\n        let curveOffset = 0;\n        \n        // If there are multiple edges between same nodes, add curves\n        if (groupEdges.length > 1) {\n          const totalEdges = groupEdges.length;\n          const maxOffset = 50; // Increased for better separation\n          const isEven = totalEdges % 2 === 0;\n          \n          if (isEven) {\n            // Even number: no line on axis, symmetric pairs\n            const pairsCount = totalEdges / 2;\n            const offsetStep = maxOffset / pairsCount;\n            \n            if (groupIndex < pairsCount) {\n              // Upper curves: +offset\n              curveOffset = offsetStep * (pairsCount - groupIndex);\n            } else {\n              // Lower curves: -offset\n              curveOffset = -offsetStep * (groupIndex - pairsCount + 1);\n            }\n          } else {\n            // Odd number: one line on axis (center), others symmetric\n            const centerIndex = Math.floor(totalEdges / 2);\n            \n            if (groupIndex === centerIndex) {\n              curveOffset = 0; // Center line on axis\n            } else {\n              const pairsCount = Math.floor(totalEdges / 2);\n              const offsetStep = maxOffset / pairsCount;\n              \n              if (groupIndex < centerIndex) {\n                // Upper curves: +offset\n                curveOffset = offsetStep * (centerIndex - groupIndex);\n              } else {\n                // Lower curves: -offset\n                curveOffset = -offsetStep * (groupIndex - centerIndex);\n              }\n            }\n          }\n        }\n        \n        const coords = getEdgeCoordinates(edge, curveOffset, processedCurves);\n        const edgeData = { ...edge, isCircular, curveOffset, coords };\n        \n        // Add to processed curves for intersection checking\n        if (coords.controlX !== 0 || coords.controlY !== 0) {\n          processedCurves.push({ controlX: coords.controlX, controlY: coords.controlY });\n        }\n        \n        allEdges.push(edgeData);\n      });\n    });\n\n    // Separate straight and curved edges\n    const straightEdges = allEdges.filter(d => !d.coords.path);\n    const curvedEdges = allEdges.filter(d => d.coords.path);\n\n    // Draw straight edges as lines\n    const lines = edgeGroup.selectAll(\"line\")\n      .data(straightEdges)\n      .enter().append(\"line\")\n      .attr(\"x1\", (d: any) => d.coords.x1)\n      .attr(\"y1\", (d: any) => d.coords.y1)\n      .attr(\"x2\", (d: any) => d.coords.x2)\n      .attr(\"y2\", (d: any) => d.coords.y2)\n      .attr(\"stroke\", (d: any) => {\n        if (d.trafficType === 'inter-service') return \"#DC2626\";\n        if (d.trafficType === 'intra-service') return \"#059669\";\n        if (d.trafficType === 'external') return \"#7C3AED\";\n        return \"#000000\";\n      })\n      .attr(\"stroke-width\", (d: any) => {\n        const count = d.connectionCount || 1;\n        return Math.max(1, Math.min(5, count)); // Scale from 1px to 5px\n      })\n      .attr(\"marker-end\", settings.showArrows ? \"url(#arrowhead)\" : null)\n      .attr(\"class\", \"edge\")\n      .on(\"mouseover\", function(event: any, d: any) {\n        if (d.connectionCount && d.connectionCount > 1) {\n          const tooltip = d3.select(\"body\").append(\"div\")\n            .attr(\"class\", \"connection-tooltip\")\n            .style(\"position\", \"absolute\")\n            .style(\"background\", \"rgba(0, 0, 0, 0.8)\")\n            .style(\"color\", \"white\")\n            .style(\"padding\", \"8px\")\n            .style(\"border-radius\", \"4px\")\n            .style(\"font-size\", \"12px\")\n            .style(\"pointer-events\", \"none\")\n            .style(\"z-index\", \"1000\")\n            .text(d.connectionCount.toString());\n          \n          tooltip.style(\"left\", (event.pageX + 10) + \"px\")\n            .style(\"top\", (event.pageY - 10) + \"px\");\n        }\n      })\n      .on(\"mouseout\", function() {\n        d3.selectAll(\".connection-tooltip\").remove();\n      });\n\n    // Draw curved edges as paths\n    const paths = edgeGroup.selectAll(\"path\")\n      .data(curvedEdges)\n      .enter().append(\"path\")\n      .attr(\"d\", (d: any) => d.coords.path)\n      .attr(\"stroke\", (d: any) => {\n        if (d.trafficType === 'inter-service') return \"#DC2626\";\n        if (d.trafficType === 'intra-service') return \"#059669\";\n        if (d.trafficType === 'external') return \"#7C3AED\";\n        return \"#000000\";\n      })\n      .attr(\"stroke-width\", (d: any) => {\n        const count = d.connectionCount || 1;\n        return Math.max(1, Math.min(5, count)); // Scale from 1px to 5px\n      })\n      .attr(\"fill\", \"none\")\n      .attr(\"marker-end\", settings.showArrows ? \"url(#arrowhead)\" : null)\n      .attr(\"class\", \"edge\")\n      .on(\"mouseover\", function(event: any, d: any) {\n        if (d.connectionCount && d.connectionCount > 1) {\n          const tooltip = d3.select(\"body\").append(\"div\")\n            .attr(\"class\", \"connection-tooltip\")\n            .style(\"position\", \"absolute\")\n            .style(\"background\", \"rgba(0, 0, 0, 0.8)\")\n            .style(\"color\", \"white\")\n            .style(\"padding\", \"8px\")\n            .style(\"border-radius\", \"4px\")\n            .style(\"font-size\", \"12px\")\n            .style(\"pointer-events\", \"none\")\n            .style(\"z-index\", \"1000\")\n            .text(d.connectionCount.toString());\n          \n          tooltip.style(\"left\", (event.pageX + 10) + \"px\")\n            .style(\"top\", (event.pageY - 10) + \"px\");\n        }\n      })\n      .on(\"mouseout\", function() {\n        d3.selectAll(\".connection-tooltip\").remove();\n      });\n\n    // Draw nodes\n    const node = g.append(\"g\")\n      .selectAll(\"g\")\n      .data(nodes)\n      .enter().append(\"g\")\n      .attr(\"transform\", (d: any) => `translate(${d.x},${d.y})`)\n      .call(d3.drag<any, any>()\n        .on(\"start\", function(event, d: any) {\n          d3.select(this).raise().classed(\"active\", true);\n        })\n        .on(\"drag\", function(event, d: any) {\n          // Update node position\n          d.x += event.dx;\n          d.y += event.dy;\n          \n          // Move the node\n          d3.select(this).attr(\"transform\", `translate(${d.x},${d.y})`);\n          \n          // Recalculate all affected edges to maintain proper curve distribution\n          const affectedEdges = allEdges.filter((edge: any) => {\n            const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n            const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n            return sourceId === d.id || targetId === d.id;\n          });\n          \n          // Rebuild curves for affected node pairs to avoid overlaps\n          const affectedPairs = new Set<string>();\n          affectedEdges.forEach((edge: any) => {\n            const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n            const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n            const pairKey = [sourceId, targetId].sort().join('-');\n            affectedPairs.add(pairKey);\n          });\n          \n          // Recalculate curves for affected pairs\n          const recalculatedCurves: any[] = [];\n          affectedPairs.forEach(pairKey => {\n            const pairEdges = affectedEdges.filter((edge: any) => {\n              const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n              const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n              const edgePairKey = [sourceId, targetId].sort().join('-');\n              return edgePairKey === pairKey;\n            });\n            \n            pairEdges.forEach((edge: any, groupIndex: number) => {\n              let curveOffset = 0;\n              \n              if (pairEdges.length > 1) {\n                const totalEdges = pairEdges.length;\n                const maxOffset = 50;\n                const isEven = totalEdges % 2 === 0;\n                \n                if (isEven) {\n                  const pairsCount = totalEdges / 2;\n                  const offsetStep = maxOffset / pairsCount;\n                  \n                  if (groupIndex < pairsCount) {\n                    curveOffset = offsetStep * (pairsCount - groupIndex);\n                  } else {\n                    curveOffset = -offsetStep * (groupIndex - pairsCount + 1);\n                  }\n                } else {\n                  const centerIndex = Math.floor(totalEdges / 2);\n                  \n                  if (groupIndex === centerIndex) {\n                    curveOffset = 0;\n                  } else {\n                    const pairsCount = Math.floor(totalEdges / 2);\n                    const offsetStep = maxOffset / pairsCount;\n                    \n                    if (groupIndex < centerIndex) {\n                      curveOffset = offsetStep * (centerIndex - groupIndex);\n                    } else {\n                      curveOffset = -offsetStep * (groupIndex - centerIndex);\n                    }\n                  }\n                }\n              }\n              \n              edge.curveOffset = curveOffset;\n              const updatedCoords = getEdgeCoordinates(edge, curveOffset, recalculatedCurves);\n              edge.coords = updatedCoords;\n              \n              if (updatedCoords.controlX !== 0 || updatedCoords.controlY !== 0) {\n                recalculatedCurves.push({ controlX: updatedCoords.controlX, controlY: updatedCoords.controlY });\n              }\n            });\n          });\n          \n          // Update straight line edges\n          lines\n            .filter((l: any) => affectedEdges.includes(l))\n            .each(function(l: any) {\n              if (!l.coords.path) {\n                d3.select(this)\n                  .attr(\"x1\", l.coords.x1)\n                  .attr(\"y1\", l.coords.y1)\n                  .attr(\"x2\", l.coords.x2)\n                  .attr(\"y2\", l.coords.y2);\n              }\n            });\n          \n          // Update curved path edges\n          paths\n            .filter((p: any) => affectedEdges.includes(p))\n            .each(function(p: any) {\n              if (p.coords.path) {\n                d3.select(this).attr(\"d\", p.coords.path);\n              }\n            });\n        })\n        .on(\"end\", function() {\n          d3.select(this).classed(\"active\", false);\n        })\n      );\n\n    // Add circles for nodes\n    const getNodeColor = () => {\n      switch (settings.nodeColor) {\n        case \"red\": return \"#EF4444\";\n        case \"green\": return \"#10B981\";\n        case \"purple\": return \"#8B5CF6\";\n        default: return \"#1976D2\";\n      }\n    };\n\n    node.append(\"circle\")\n      .attr(\"r\", 20)\n      .attr(\"fill\", getNodeColor())\n      .attr(\"stroke\", \"#fff\")\n      .attr(\"stroke-width\", 3);\n\n    // Add labels if enabled\n    if (settings.showLabels) {\n      node.append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dy\", \"0.35em\")\n        .attr(\"fill\", \"white\")\n        .attr(\"font-size\", \"12px\")\n        .attr(\"font-weight\", \"600\")\n        .text((d: any) => d.label.charAt(0).toUpperCase());\n\n      node.append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dy\", \"2.5em\")\n        .attr(\"fill\", \"#374151\")\n        .attr(\"font-size\", \"11px\")\n        .text((d: any) => d.label);\n    }\n\n  }, [data, settings, layout]);\n\n  const handleZoomIn = () => {\n    if (svgRef.current) {\n      const svg = d3.select(svgRef.current);\n      svg.transition().call(\n        d3.zoom<SVGSVGElement, unknown>().transform,\n        transform.scale(1.2)\n      );\n    }\n  };\n\n  const handleZoomOut = () => {\n    if (svgRef.current) {\n      const svg = d3.select(svgRef.current);\n      svg.transition().call(\n        d3.zoom<SVGSVGElement, unknown>().transform,\n        transform.scale(0.8)\n      );\n    }\n  };\n\n  const handleResetZoom = () => {\n    if (svgRef.current) {\n      const svg = d3.select(svgRef.current);\n      svg.transition().call(\n        d3.zoom<SVGSVGElement, unknown>().transform,\n        d3.zoomIdentity\n      );\n    }\n  };\n\n  const handleExportSVG = () => {\n    if (svgRef.current) {\n      exportAsSVG(svgRef.current);\n    }\n  };\n\n  const handleExportPNG = () => {\n    if (svgRef.current) {\n      exportAsPNG(svgRef.current);\n    }\n  };\n\n  if (!data) {\n    return (\n      <div className=\"flex-1 flex flex-col bg-gray-50\">\n        <div className=\"flex-1 relative overflow-hidden\">\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"text-center max-w-md mx-auto px-4\">\n              <div className=\"w-24 h-24 mx-auto mb-6 bg-gray-100 rounded-full flex items-center justify-center\">\n                <FileDown className=\"w-8 h-8 text-gray-400\" />\n              </div>\n              <h3 className=\"text-lg font-semibold text-foreground mb-2\">Create Your First Diagram</h3>\n              <p className=\"text-muted-foreground mb-6\">\n                Upload a CSV or Excel file with source-target columns to automatically generate an interactive network diagram.\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex-1 flex flex-col bg-gray-50\">\n      {/* Canvas Toolbar */}\n      <div className=\"bg-white border-b border-gray-200 px-4 py-3\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-3\">\n            <div className=\"flex items-center space-x-1 bg-gray-100 rounded-lg p-1\">\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleZoomIn}\n                className=\"h-8 w-8 p-0\"\n                title=\"Zoom In\"\n              >\n                <ZoomIn className=\"h-4 w-4\" />\n              </Button>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleZoomOut}\n                className=\"h-8 w-8 p-0\"\n                title=\"Zoom Out\"\n              >\n                <ZoomOut className=\"h-4 w-4\" />\n              </Button>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={handleResetZoom}\n                className=\"h-8 w-8 p-0\"\n                title=\"Reset Zoom\"\n              >\n                <RotateCcw className=\"h-4 w-4\" />\n              </Button>\n            </div>\n            \n            <div className=\"h-6 w-px bg-gray-300\"></div>\n            \n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-8 w-8 p-0\"\n              title=\"Center Diagram\"\n            >\n              <Crosshair className=\"h-4 w-4\" />\n            </Button>\n            \n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              className=\"h-8 w-8 p-0\"\n              title=\"Fullscreen\"\n            >\n              <Maximize className=\"h-4 w-4\" />\n            </Button>\n          </div>\n          \n          <div className=\"flex items-center space-x-3\">\n            <span className=\"text-xs text-muted-foreground\">{zoomLevel}%</span>\n            <div className=\"flex items-center space-x-2\">\n              <Button\n                onClick={handleExportPNG}\n                size=\"sm\"\n                className=\"text-xs\"\n              >\n                <Image className=\"w-3 h-3 mr-1\" />\n                PNG\n              </Button>\n              <Button\n                onClick={handleExportSVG}\n                variant=\"outline\"\n                size=\"sm\"\n                className=\"text-xs\"\n              >\n                <FileDown className=\"w-3 h-3 mr-1\" />\n                SVG\n              </Button>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      {/* Main Canvas Area */}\n      <div className=\"flex-1 relative overflow-hidden\">\n        <svg\n          ref={svgRef}\n          className=\"w-full h-full\"\n          viewBox=\"0 0 800 600\"\n          style={{ background: '#fafafa' }}\n        />\n      </div>\n    </div>\n  );\n}\n","size_bytes":22982},"client/src/components/FileUpload.tsx":{"content":"import { useCallback, useState } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { Upload, FileText, AlertCircle } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { parseFile, validateFileType } from \"@/lib/fileParser\";\nimport type { ParsedFileData, DiagramData, DiagramEdge, DiagramNode } from \"@/types/diagram\";\n\n// Function to detect service patterns from node names (only used as fallback when server doesn't provide service)\nfunction detectServiceFromNodeId(nodeId: string): { service: string; endpoint: string } | null {\n  // Only try simpler patterns to avoid over-parsing complex IDs\n  // Pattern: service.endpoint or service:endpoint  \n  const dotColonPattern = /^([a-zA-Z0-9-_]+)[.:]([a-zA-Z0-9-_]+)$/;\n  const match = nodeId.match(dotColonPattern);\n  if (match) {\n    return { service: match[1], endpoint: match[2] };\n  }\n  \n  return null;\n}\n\n// Function to determine traffic type between nodes\nfunction getTrafficType(sourceService: string | undefined, targetService: string | undefined): 'inter-service' | 'intra-service' | 'external' {\n  if (!sourceService || !targetService) return 'external';\n  if (sourceService === targetService) return 'intra-service';\n  return 'inter-service';\n}\n\n// Function to aggregate data from multiple files with service detection\nfunction aggregateFileData(fileDataArray: ParsedFileData[]): ParsedFileData {\n  const allNodes = new Map<string, DiagramNode>();\n  const connectionCounts = new Map<string, number>();\n  const edgeDetails = new Map<string, DiagramEdge[]>();\n  const statusCounts = new Map<string, Record<string, number>>();\n  const detectedServices = new Map<string, Set<string>>();\n  \n  // Process all files\n  fileDataArray.forEach(fileData => {\n    // Collect unique nodes and preserve server-assigned service names\n    fileData.data.nodes.forEach(node => {\n      const serverService = (node as any).service;\n      let enhancedNode: DiagramNode;\n      \n      if (serverService) {\n        // Preserve server-assigned service grouping exactly as provided\n        enhancedNode = {\n          ...node,\n          service: serverService,\n          nodeType: 'endpoint'\n        };\n        \n        // Track services and their endpoints using exact server service name\n        if (!detectedServices.has(serverService)) {\n          detectedServices.set(serverService, new Set());\n        }\n        detectedServices.get(serverService)!.add(node.id);\n      } else {\n        // Only use auto-detection if server didn't provide service name\n        const servicePattern = detectServiceFromNodeId(node.id);\n        if (servicePattern) {\n          enhancedNode = {\n            ...node,\n            service: servicePattern.service,\n            nodeType: 'endpoint'\n          };\n          \n          if (!detectedServices.has(servicePattern.service)) {\n            detectedServices.set(servicePattern.service, new Set());\n          }\n          detectedServices.get(servicePattern.service)!.add(node.id);\n        } else {\n          enhancedNode = { ...node, nodeType: 'service' };\n        }\n      }\n      \n      allNodes.set(node.id, enhancedNode);\n    });\n    \n    // Count connections between node pairs and track status codes\n    fileData.data.edges.forEach(edge => {\n      const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n      const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n      const connectionKey = `${sourceId}->${targetId}`;\n      \n      connectionCounts.set(connectionKey, (connectionCounts.get(connectionKey) || 0) + 1);\n      \n      if (!edgeDetails.has(connectionKey)) {\n        edgeDetails.set(connectionKey, []);\n      }\n      edgeDetails.get(connectionKey)!.push(edge);\n      \n      // Track status code counts\n      if (edge.status) {\n        if (!statusCounts.has(connectionKey)) {\n          statusCounts.set(connectionKey, {});\n        }\n        const statusCount = statusCounts.get(connectionKey)!;\n        statusCount[edge.status] = (statusCount[edge.status] || 0) + 1;\n      }\n    });\n  });\n  \n  // Skip creating artificial service nodes - treat all nodes as they appear in CSV\n  \n  // Create aggregated edges with connection counts and traffic type\n  const aggregatedEdges: (DiagramEdge & { connectionCount: number })[] = [];\n  connectionCounts.forEach((count, connectionKey) => {\n    const [sourceId, targetId] = connectionKey.split('->');\n    const originalEdges = edgeDetails.get(connectionKey) || [];\n    const firstEdge = originalEdges[0];\n    \n    const sourceNode = allNodes.get(sourceId);\n    const targetNode = allNodes.get(targetId);\n    const trafficType = getTrafficType(sourceNode?.service, targetNode?.service);\n    \n    aggregatedEdges.push({\n      id: `${sourceId}-${targetId}-aggregated`,\n      source: sourceId,\n      target: targetId,\n      label: firstEdge?.label || '',\n      connectionCount: count,\n      trafficType,\n      status: firstEdge?.status, // Preserve status from first edge\n      statusCounts: statusCounts.get(connectionKey) || {}\n    });\n  });\n  \n  const aggregatedData: DiagramData = {\n    nodes: Array.from(allNodes.values()),\n    edges: aggregatedEdges\n  };\n  \n  return {\n    data: aggregatedData,\n    stats: {\n      nodeCount: aggregatedData.nodes.length,\n      edgeCount: aggregatedData.edges.length,\n      componentCount: detectedServices.size || 1\n    }\n  };\n}\n\ninterface FileUploadProps {\n  onFileProcessed: (data: ParsedFileData, filename: string) => void;\n  onMultipleFilesProcessed: (aggregatedData: ParsedFileData, filenames: string[]) => void;\n  onError: (error: string) => void;\n  isProcessing: boolean;\n  setIsProcessing: (processing: boolean) => void;\n}\n\nexport default function FileUpload({ onFileProcessed, onMultipleFilesProcessed, onError, isProcessing, setIsProcessing }: FileUploadProps) {\n  const [dragActive, setDragActive] = useState(false);\n\n  const processMultipleFiles = useCallback(async (files: File[]) => {\n    setIsProcessing(true);\n    const processedFiles: { data: ParsedFileData; filename: string }[] = [];\n    \n    try {\n      for (const file of files) {\n        if (!validateFileType(file)) {\n          onError(`Invalid file type: ${file.name}. Please upload CSV or Excel files only.`);\n          continue;\n        }\n        \n        try {\n          const result = await parseFile(file);\n          processedFiles.push({ data: result, filename: file.name });\n        } catch (error) {\n          onError(`Failed to process ${file.name}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n      }\n      \n      if (processedFiles.length === 0) {\n        onError(\"No files could be processed successfully\");\n        return;\n      }\n      \n      if (processedFiles.length === 1) {\n        onFileProcessed(processedFiles[0].data, processedFiles[0].filename);\n      } else {\n        // Aggregate multiple files\n        const aggregatedData = aggregateFileData(processedFiles.map(f => f.data));\n        const filenames = processedFiles.map(f => f.filename);\n        onMultipleFilesProcessed(aggregatedData, filenames);\n      }\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [onFileProcessed, onMultipleFilesProcessed, onError, setIsProcessing]);\n\n  const onDrop = useCallback((acceptedFiles: File[]) => {\n    if (acceptedFiles.length > 0) {\n      processMultipleFiles(acceptedFiles);\n    }\n  }, [processMultipleFiles]);\n\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop,\n    accept: {\n      'text/csv': ['.csv'],\n      'application/vnd.ms-excel': ['.xls'],\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx']\n    },\n    multiple: true,\n    disabled: isProcessing\n  });\n\n  return (\n    <div className=\"p-6 border-b border-gray-200\">\n      <h2 className=\"text-lg font-semibold text-foreground mb-4\">Import Data</h2>\n      \n      <div \n        {...getRootProps()} \n        className={`border-2 border-dashed rounded-lg p-6 text-center transition-colors cursor-pointer ${\n          isDragActive || dragActive \n            ? 'border-primary bg-primary/5' \n            : 'border-gray-300 hover:border-primary/50'\n        } ${isProcessing ? 'pointer-events-none opacity-50' : ''}`}\n      >\n        <input {...getInputProps()} />\n        <div className=\"upload-content\">\n          {isProcessing ? (\n            <div className=\"flex flex-col items-center\">\n              <div className=\"w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin mb-3\"></div>\n              <p className=\"text-sm font-medium text-foreground mb-1\">Processing file...</p>\n              <p className=\"text-xs text-muted-foreground\">Parsing data structure</p>\n            </div>\n          ) : (\n            <>\n              <Upload className=\"w-8 h-8 text-gray-400 mx-auto mb-3\" />\n              <p className=\"text-sm font-medium text-foreground mb-1\">Drop your CSV or Excel files here</p>\n              <p className=\"text-xs text-muted-foreground\">or click to browse (select multiple files)</p>\n            </>\n          )}\n        </div>\n      </div>\n\n      <div className=\"mt-4 space-y-2\">\n        <div className=\"flex items-center text-xs text-muted-foreground\">\n          <FileText className=\"w-3 h-3 mr-2\" />\n          <span>Supported formats: CSV, Excel (.xlsx, .xls)</span>\n        </div>\n        <div className=\"flex items-center text-xs text-muted-foreground\">\n          <AlertCircle className=\"w-3 h-3 mr-2\" />\n          <span>Required columns: source, target</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":9550},"client/src/components/HelpPanel.tsx":{"content":"import { X } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface HelpPanelProps {\n  isOpen: boolean;\n  onClose: () => void;\n}\n\nexport default function HelpPanel({ isOpen, onClose }: HelpPanelProps) {\n  return (\n    <div className={`fixed inset-y-0 right-0 w-96 bg-white shadow-2xl transform transition-transform duration-300 ease-in-out z-50 ${\n      isOpen ? 'translate-x-0' : 'translate-x-full'\n    }`}>\n      <div className=\"h-full flex flex-col\">\n        <div className=\"flex items-center justify-between p-6 border-b border-gray-200\">\n          <h2 className=\"text-lg font-semibold text-foreground\">Help & Tips</h2>\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onClose}\n            className=\"h-8 w-8 p-0\"\n          >\n            <X className=\"h-4 w-4\" />\n          </Button>\n        </div>\n        \n        <div className=\"flex-1 overflow-y-auto p-6\">\n          <div className=\"space-y-6\">\n            <div>\n              <h3 className=\"font-semibold text-foreground mb-2\">File Format</h3>\n              <p className=\"text-sm text-muted-foreground mb-3\">Your file should contain at least two columns:</p>\n              <div className=\"bg-muted p-3 rounded-lg text-sm font-mono\">\n                <div>source,target</div>\n                <div>Node A,Node B</div>\n                <div>Node B,Node C</div>\n                <div>Node A,Node D</div>\n              </div>\n            </div>\n            \n            <div>\n              <h3 className=\"font-semibold text-foreground mb-2\">Navigation</h3>\n              <ul className=\"text-sm text-muted-foreground space-y-1\">\n                <li>â€¢ Mouse wheel: Zoom in/out</li>\n                <li>â€¢ Click & drag: Pan around</li>\n                <li>â€¢ Drag nodes: Reposition manually</li>\n              </ul>\n            </div>\n            \n            <div>\n              <h3 className=\"font-semibold text-foreground mb-2\">Layout Algorithms</h3>\n              <ul className=\"text-sm text-muted-foreground space-y-2\">\n                <li><strong>Force-directed:</strong> Natural clustering</li>\n                <li><strong>Hierarchical:</strong> Tree-like structure</li>\n                <li><strong>Circular:</strong> Nodes in a circle</li>\n                <li><strong>Grid:</strong> Organized rows and columns</li>\n              </ul>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":2443},"client/src/components/LayoutControls.tsx":{"content":"import { Button } from \"@/components/ui/button\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Slider } from \"@/components/ui/slider\";\nimport { Wand2 } from \"lucide-react\";\nimport type { LayoutType } from \"@/types/diagram\";\n\ninterface LayoutControlsProps {\n  layout: LayoutType;\n  spacing: number;\n  onLayoutChange: (layout: LayoutType) => void;\n  onSpacingChange: (spacing: number) => void;\n  onApplyLayout: () => void;\n  disabled?: boolean;\n}\n\nexport default function LayoutControls({\n  layout,\n  spacing,\n  onLayoutChange,\n  onSpacingChange,\n  onApplyLayout,\n  disabled = false\n}: LayoutControlsProps) {\n  return (\n    <div className=\"p-6 border-b border-gray-200\">\n      <h3 className=\"text-sm font-semibold text-foreground mb-3\">Layout Options</h3>\n      <div className=\"space-y-3\">\n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-1\">Algorithm</label>\n          <Select value={layout} onValueChange={onLayoutChange} disabled={disabled}>\n            <SelectTrigger className=\"w-full\">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"force\">Force-directed</SelectItem>\n              <SelectItem value=\"hierarchical\">Hierarchical</SelectItem>\n              <SelectItem value=\"circular\">Circular</SelectItem>\n              <SelectItem value=\"grid\">Grid</SelectItem>\n              <SelectItem value=\"service-grouped\">Service Grouped</SelectItem>\n              <SelectItem value=\"network-topology\">Network Topology</SelectItem>\n              <SelectItem value=\"3d-network\">3D Network View</SelectItem>\n            </SelectContent>\n          </Select>\n        </div>\n        \n        <div>\n          <label className=\"block text-xs font-medium text-muted-foreground mb-1\">\n            Node Spacing: {spacing}px\n          </label>\n          <Slider\n            value={[spacing]}\n            onValueChange={(value) => onSpacingChange(value[0])}\n            min={50}\n            max={200}\n            step={10}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n        \n        <Button \n          onClick={onApplyLayout} \n          disabled={disabled}\n          className=\"w-full\"\n          variant=\"outline\"\n        >\n          <Wand2 className=\"w-4 h-4 mr-2\" />\n          Apply Layout\n        </Button>\n      </div>\n    </div>\n  );\n}\n","size_bytes":2456},"client/src/components/ServiceMetricsPopup.tsx":{"content":"import { useState } from \"react\";\nimport { Card, CardHeader, CardTitle, CardContent } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { \n  Computer, \n  Cpu, \n  HardDrive, \n  Activity, \n  Network, \n  Users, \n  Clock, \n  AlertTriangle,\n  CheckCircle,\n  XCircle,\n  X\n} from \"lucide-react\";\nimport type { ServiceMetrics } from \"@shared/schema\";\n\ninterface ServiceMetricsPopupProps {\n  serviceName: string;\n  metrics: ServiceMetrics | null;\n  onClose: () => void;\n  position: { x: number; y: number };\n}\n\nfunction getHealthColor(status: string) {\n  switch (status) {\n    case \"healthy\": return \"text-green-400\";\n    case \"warning\": return \"text-yellow-400\";\n    case \"critical\": return \"text-red-400\";\n    default: return \"text-gray-400\";\n  }\n}\n\nfunction getHealthIcon(status: string) {\n  switch (status) {\n    case \"healthy\": return CheckCircle;\n    case \"warning\": return AlertTriangle;\n    case \"critical\": return XCircle;\n    default: return Activity;\n  }\n}\n\nfunction getUsageColor(percentage: number) {\n  if (percentage >= 85) return \"text-red-400\";\n  if (percentage >= 70) return \"text-yellow-400\";\n  return \"text-green-400\";\n}\n\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return \"0 MB/s\";\n  return `${bytes.toFixed(1)} MB/s`;\n}\n\nexport default function ServiceMetricsPopup({ \n  serviceName, \n  metrics, \n  onClose, \n  position \n}: ServiceMetricsPopupProps) {\n  if (!metrics) {\n    return (\n      <div \n        className=\"fixed z-50 bg-slate-800 border border-slate-600 rounded-lg shadow-2xl p-4 min-w-80\"\n        style={{ \n          left: Math.min(position.x, window.innerWidth - 320), \n          top: Math.min(position.y, window.innerHeight - 400)\n        }}\n      >\n        <div className=\"flex items-center justify-between mb-3\">\n          <div className=\"flex items-center space-x-2\">\n            <Computer className=\"w-4 h-4 text-blue-400\" />\n            <h3 className=\"text-sm font-semibold text-slate-200\">{serviceName}</h3>\n          </div>\n          <Button \n            variant=\"ghost\" \n            size=\"sm\" \n            onClick={onClose}\n            className=\"h-6 w-6 p-0 text-slate-400 hover:text-slate-200\"\n          >\n            <X className=\"w-4 h-4\" />\n          </Button>\n        </div>\n        <div className=\"text-center py-4\">\n          <div className=\"text-slate-400 text-sm\">No metrics available</div>\n        </div>\n      </div>\n    );\n  }\n\n  const HealthIcon = getHealthIcon(metrics.healthStatus);\n\n  return (\n    <div \n      className=\"fixed z-50 bg-slate-800 border border-slate-600 rounded-lg shadow-2xl p-4 min-w-80 max-w-96\"\n      style={{ \n        left: Math.min(position.x, window.innerWidth - 400), \n        top: Math.min(position.y, window.innerHeight - 500)\n      }}\n    >\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-3\">\n        <div className=\"flex items-center space-x-2\">\n          <Computer className=\"w-4 h-4 text-blue-400\" />\n          <h3 className=\"text-sm font-semibold text-slate-200\">{serviceName}</h3>\n          <Badge \n            variant={metrics.deploymentType === \"kubernetes\" ? \"default\" : \"secondary\"}\n            className=\"text-xs\"\n          >\n            {metrics.deploymentType === \"kubernetes\" ? \"K8s\" : \"VM\"}\n          </Badge>\n        </div>\n        <Button \n          variant=\"ghost\" \n          size=\"sm\" \n          onClick={onClose}\n          className=\"h-6 w-6 p-0 text-slate-400 hover:text-slate-200\"\n        >\n          <X className=\"w-4 h-4\" />\n        </Button>\n      </div>\n\n      {/* Health Status */}\n      <div className=\"flex items-center space-x-2 mb-4 p-2 bg-slate-700/50 rounded-md\">\n        <HealthIcon className={`w-4 h-4 ${getHealthColor(metrics.healthStatus)}`} />\n        <span className={`text-sm font-medium ${getHealthColor(metrics.healthStatus)}`}>\n          {metrics.healthStatus.charAt(0).toUpperCase() + metrics.healthStatus.slice(1)}\n        </span>\n        <span className=\"text-xs text-slate-400 ml-auto\">\n          {new Date(metrics.timestamp).toLocaleTimeString()}\n        </span>\n      </div>\n\n      {/* Resource Usage */}\n      <div className=\"space-y-3\">\n        <div className=\"grid grid-cols-2 gap-3\">\n          <div className=\"flex items-center space-x-2\">\n            <Cpu className=\"w-3 h-3 text-blue-400\" />\n            <div>\n              <div className=\"text-xs text-slate-400\">CPU</div>\n              <div className={`text-sm font-medium ${getUsageColor(metrics.cpuUsage)}`}>\n                {metrics.cpuUsage.toFixed(1)}%\n              </div>\n            </div>\n          </div>\n          \n          <div className=\"flex items-center space-x-2\">\n            <Activity className=\"w-3 h-3 text-purple-400\" />\n            <div>\n              <div className=\"text-xs text-slate-400\">Memory</div>\n              <div className={`text-sm font-medium ${getUsageColor(metrics.memoryUsage)}`}>\n                {metrics.memoryUsage.toFixed(1)}%\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-3\">\n          <div className=\"flex items-center space-x-2\">\n            <HardDrive className=\"w-3 h-3 text-green-400\" />\n            <div>\n              <div className=\"text-xs text-slate-400\">Disk</div>\n              <div className={`text-sm font-medium ${getUsageColor(metrics.diskUsage)}`}>\n                {metrics.diskUsage.toFixed(1)}%\n              </div>\n            </div>\n          </div>\n          \n          <div className=\"flex items-center space-x-2\">\n            <Users className=\"w-3 h-3 text-cyan-400\" />\n            <div>\n              <div className=\"text-xs text-slate-400\">Connections</div>\n              <div className=\"text-sm font-medium text-slate-200\">\n                {metrics.activeConnections}\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Network */}\n        <div className=\"border-t border-slate-600 pt-3\">\n          <div className=\"flex items-center space-x-1 mb-2\">\n            <Network className=\"w-3 h-3 text-indigo-400\" />\n            <span className=\"text-xs text-slate-400\">Network I/O</span>\n          </div>\n          <div className=\"grid grid-cols-2 gap-3 text-xs\">\n            <div>\n              <span className=\"text-slate-400\">In: </span>\n              <span className=\"text-slate-200\">{formatBytes(metrics.networkIn)}</span>\n            </div>\n            <div>\n              <span className=\"text-slate-400\">Out: </span>\n              <span className=\"text-slate-200\">{formatBytes(metrics.networkOut)}</span>\n            </div>\n          </div>\n        </div>\n\n        {/* Performance */}\n        <div className=\"border-t border-slate-600 pt-3\">\n          <div className=\"grid grid-cols-2 gap-3\">\n            <div className=\"flex items-center space-x-2\">\n              <Clock className=\"w-3 h-3 text-orange-400\" />\n              <div>\n                <div className=\"text-xs text-slate-400\">Response</div>\n                <div className=\"text-sm font-medium text-slate-200\">\n                  {metrics.responseTime}ms\n                </div>\n              </div>\n            </div>\n            \n            <div className=\"flex items-center space-x-2\">\n              <AlertTriangle className=\"w-3 h-3 text-red-400\" />\n              <div>\n                <div className=\"text-xs text-slate-400\">Error Rate</div>\n                <div className={`text-sm font-medium ${metrics.errorRate > 5 ? 'text-red-400' : metrics.errorRate > 2 ? 'text-yellow-400' : 'text-green-400'}`}>\n                  {metrics.errorRate.toFixed(2)}%\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Kubernetes specific */}\n        {metrics.deploymentType === \"kubernetes\" && metrics.podCount && (\n          <div className=\"border-t border-slate-600 pt-3\">\n            <div className=\"flex items-center space-x-2\">\n              <div className=\"w-3 h-3 bg-blue-500 rounded-sm\"></div>\n              <div>\n                <div className=\"text-xs text-slate-400\">Active Pods</div>\n                <div className=\"text-sm font-medium text-slate-200\">\n                  {metrics.podCount}\n                </div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}","size_bytes":8322},"client/src/components/Sidebar.tsx":{"content":"import { useState, useRef } from \"react\";\nimport LayoutControls from \"./LayoutControls\";\nimport Statistics from \"./Statistics\";\nimport TraceList from \"./TraceList\";\nimport UnifiedSettings from \"./UnifiedSettings\";\nimport type { ParsedFileData, DiagramSettings, LayoutType, DiagramData } from \"@/types/diagram\";\n\ninterface SidebarProps {\n  layout: LayoutType;\n  settings: DiagramSettings;\n  stats: ParsedFileData[\"stats\"] | null;\n  data: DiagramData | null;\n  onLayoutChange: (layout: LayoutType) => void;\n  onSpacingChange: (spacing: number) => void;\n  onApplyLayout: () => void;\n  onSettingsChange: (settings: DiagramSettings) => void;\n  hasData: boolean;\n  selectedTraceId: string | null;\n  onTraceSelect: (traceId: string | null) => void;\n  lodLevel?: 'high' | 'medium' | 'low';\n  relativeDistance?: number;\n  serviceCount?: number;\n}\n\nexport default function Sidebar({\n  layout,\n  settings,\n  stats,\n  data,\n  onLayoutChange,\n  onSpacingChange,\n  onApplyLayout,\n  onSettingsChange,\n  hasData,\n  selectedTraceId,\n  onTraceSelect,\n  lodLevel,\n  relativeDistance,\n  serviceCount\n}: SidebarProps) {\n  const [sidebarWidth, setSidebarWidth] = useState(320); // Default width\n  const [isResizing, setIsResizing] = useState(false);\n  const sidebarRef = useRef<HTMLDivElement>(null);\n  \n  const handleMouseDown = (e: React.MouseEvent) => {\n    e.preventDefault();\n    setIsResizing(true);\n    \n    const startX = e.clientX;\n    const startWidth = sidebarWidth;\n    \n    const handleMouseMove = (e: MouseEvent) => {\n      const deltaX = e.clientX - startX;\n      const newWidth = Math.max(250, Math.min(600, startWidth + deltaX)); // Min 250px, max 600px\n      setSidebarWidth(newWidth);\n    };\n    \n    const handleMouseUp = () => {\n      setIsResizing(false);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      document.body.style.cursor = '';\n      document.body.style.userSelect = '';\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n    document.body.style.cursor = 'col-resize';\n    document.body.style.userSelect = 'none';\n  };\n  return (\n    <div \n      ref={sidebarRef}\n      className=\"bg-gradient-to-b from-slate-900 to-slate-800 border-r border-slate-700/60 flex flex-col shadow-lg h-full relative\"\n      style={{ width: `${sidebarWidth}px` }}\n    >\n      \n      <div className=\"flex-1 overflow-y-auto\">\n        <UnifiedSettings\n          settings={settings}\n          onSettingsChange={onSettingsChange}\n          onSpacingChange={onSpacingChange}\n          disabled={!hasData}\n          lodLevel={lodLevel}\n          relativeDistance={relativeDistance}\n          serviceCount={serviceCount}\n        />\n        \n        <Statistics stats={stats} data={data} />\n        \n        <TraceList \n          data={data} \n          selectedTraceId={selectedTraceId}\n          onTraceSelect={onTraceSelect}\n        />\n      </div>\n      \n      {/* Resize handle */}\n      <div\n        className={`absolute top-0 right-0 w-1 h-full cursor-col-resize transition-colors ${\n          isResizing ? 'bg-blue-400' : 'bg-transparent hover:bg-slate-500'\n        }`}\n        onMouseDown={handleMouseDown}\n        style={{ right: '-2px' }}\n      />\n    </div>\n  );\n}\n","size_bytes":3317},"client/src/components/Statistics.tsx":{"content":"import { CheckCircle, AlertCircle, XCircle, Activity, Filter } from \"lucide-react\";\nimport { useState } from \"react\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport type { DiagramStats, DiagramData } from \"@/types/diagram\";\n\ninterface StatisticsProps {\n  stats: DiagramStats | null;\n  data: DiagramData | null;\n}\n\nfunction calculateStatusStats(data: DiagramData | null, selectedConnection?: string) {\n  if (!data?.edges) return { total: 0, success: 0, clientError: 0, serverError: 0 };\n  \n  let total = 0;\n  let success = 0;\n  let clientError = 0;\n  let serverError = 0;\n  \n  data.edges.forEach(edge => {\n    // Ð•ÑÐ»Ð¸ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ, Ñ„Ð¸Ð»ÑŒÑ‚Ñ€ÑƒÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÑ‚Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ\n    if (selectedConnection && selectedConnection !== 'all') {\n      const edgeId = `${edge.source} â†’ ${edge.target}`;\n      if (edgeId !== selectedConnection) return;\n    }\n    \n    if (edge.statusCounts) {\n      Object.entries(edge.statusCounts).forEach(([status, count]) => {\n        const statusCode = parseInt(status);\n        const numCount = count as number;\n        total += numCount;\n        \n        if (statusCode >= 200 && statusCode < 300) {\n          success += numCount;\n        } else if (statusCode >= 400 && statusCode < 500) {\n          clientError += numCount;\n        } else if (statusCode >= 500 && statusCode < 600) {\n          serverError += numCount;\n        }\n      });\n    }\n  });\n  \n  return { total, success, clientError, serverError };\n}\n\nfunction getConnectionOptions(data: DiagramData | null) {\n  if (!data?.edges) return [];\n  \n  const connections = data.edges\n    .filter(edge => edge.statusCounts && Object.keys(edge.statusCounts).length > 0)\n    .map(edge => `${edge.source} â†’ ${edge.target}`)\n    .sort();\n  \n  return ['all', ...connections];\n}\n\nexport default function Statistics({ stats, data }: StatisticsProps) {\n  const [selectedConnection, setSelectedConnection] = useState<string>('all');\n  const connectionOptions = getConnectionOptions(data);\n  const statusStats = calculateStatusStats(data, selectedConnection);\n  \n  const statCards = [\n    {\n      icon: CheckCircle,\n      label: \"Success (2xx)\",\n      value: statusStats.total > 0 ? Math.round((statusStats.success / statusStats.total) * 100) : 0,\n      suffix: \"%\",\n      color: \"from-green-500 to-emerald-600\",\n      bgColor: \"bg-green-900/30\",\n      textColor: \"text-green-300\"\n    },\n    {\n      icon: AlertCircle,\n      label: \"Client Errors (4xx)\", \n      value: statusStats.total > 0 ? Math.round((statusStats.clientError / statusStats.total) * 100) : 0,\n      suffix: \"%\",\n      color: \"from-orange-500 to-red-600\",\n      bgColor: \"bg-orange-900/30\",\n      textColor: \"text-orange-300\"\n    },\n    {\n      icon: XCircle,\n      label: \"Server Errors (5xx)\",\n      value: statusStats.total > 0 ? Math.round((statusStats.serverError / statusStats.total) * 100) : 0,\n      suffix: \"%\",\n      color: \"from-red-500 to-red-700\", \n      bgColor: \"bg-red-900/30\",\n      textColor: \"text-red-300\"\n    },\n    {\n      icon: Activity,\n      label: \"Total Requests\",\n      value: statusStats.total,\n      suffix: \"\",\n      color: \"from-blue-500 to-purple-600\",\n      bgColor: \"bg-blue-900/30\",\n      textColor: \"text-blue-300\"\n    }\n  ];\n\n  return (\n    <div className=\"p-4 flex-1 overflow-y-auto\">\n      <h3 className=\"text-sm font-semibold text-slate-200 mb-3 flex items-center\">\n        <div className=\"w-2 h-2 bg-gradient-to-r from-purple-400 to-blue-400 rounded-full mr-2\"></div>\n        Request Statistics\n      </h3>\n      \n      {/* Connection Filter */}\n      {connectionOptions.length > 1 && (\n        <div className=\"mb-3\">\n          <div className=\"flex items-center gap-1 mb-2\">\n            <Filter className=\"w-3 h-3 text-slate-400\" />\n            <span className=\"text-xs font-medium text-slate-400\">Connection:</span>\n          </div>\n          <Select value={selectedConnection} onValueChange={setSelectedConnection}>\n            <SelectTrigger className=\"w-full h-8 text-xs\">\n              <SelectValue placeholder=\"Select connection\" />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"all\">All Connections</SelectItem>\n              {connectionOptions.slice(1).map(connection => (\n                <SelectItem key={connection} value={connection}>\n                  {connection}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      )}\n      \n      <div className=\"space-y-2\">\n        {statCards.map((stat, index) => {\n          const IconComponent = stat.icon;\n          return (\n            <div key={index} className={`${stat.bgColor} rounded-lg p-3 border border-slate-600/30 shadow-sm hover:shadow-md transition-all duration-200`}>\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-2\">\n                  <div className={`w-6 h-6 bg-gradient-to-r ${stat.color} rounded-md flex items-center justify-center shadow-sm`}>\n                    <IconComponent className=\"w-3 h-3 text-white\" />\n                  </div>\n                  <span className={`text-xs font-medium ${stat.textColor}`}>{stat.label}</span>\n                </div>\n                <span className={`text-sm font-bold ${stat.textColor}`}>\n                  {stat.value.toLocaleString()}{stat.suffix}\n                </span>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n}\n","size_bytes":5563},"client/src/components/TimeRangeControls.tsx":{"content":"import { useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Calendar, Clock } from \"lucide-react\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Label } from \"@/components/ui/label\";\nimport { Input } from \"@/components/ui/input\";\n\ninterface TimeRangeControlsProps {\n  onTimeRangeChange: (range: { from: Date; to: Date }) => void;\n  onIntervalChange: (intervalMs: number) => void;\n  onRefreshToggle: (enabled: boolean) => void;\n  isRefreshing: boolean;\n  currentInterval: number;\n}\n\nconst TIME_RANGES = [\n  { label: \"Last 5 minutes\", value: 5 * 60 * 1000 },\n  { label: \"Last 15 minutes\", value: 15 * 60 * 1000 },\n  { label: \"Last 30 minutes\", value: 30 * 60 * 1000 },\n  { label: \"Last 1 hour\", value: 60 * 60 * 1000 },\n  { label: \"Last 3 hours\", value: 3 * 60 * 60 * 1000 },\n  { label: \"Last 6 hours\", value: 6 * 60 * 60 * 1000 },\n  { label: \"Last 12 hours\", value: 12 * 60 * 60 * 1000 },\n  { label: \"Last 24 hours\", value: 24 * 60 * 60 * 1000 },\n];\n\nconst REFRESH_INTERVALS = [\n  { label: \"Off\", value: 0 },\n  { label: \"1s\", value: 1000 },\n  { label: \"5s\", value: 5000 },\n  { label: \"10s\", value: 10000 },\n  { label: \"30s\", value: 30000 },\n  { label: \"1m\", value: 60000 },\n  { label: \"5m\", value: 5 * 60000 },\n];\n\nexport default function TimeRangeControls({\n  onTimeRangeChange,\n  onIntervalChange,\n  onRefreshToggle,\n  isRefreshing,\n  currentInterval\n}: TimeRangeControlsProps) {\n  const [selectedRange, setSelectedRange] = useState(\"15m\");\n  const [customFrom, setCustomFrom] = useState(\"\");\n  const [customTo, setCustomTo] = useState(\"\");\n  const [isCustomRange, setIsCustomRange] = useState(false);\n\n  const handleQuickRangeSelect = (rangeMs: number, label: string) => {\n    const now = new Date();\n    const from = new Date(now.getTime() - rangeMs);\n    setSelectedRange(label);\n    setIsCustomRange(false);\n    onTimeRangeChange({ from, to: now });\n  };\n\n  const handleCustomRangeApply = () => {\n    if (customFrom && customTo) {\n      const from = new Date(customFrom);\n      const to = new Date(customTo);\n      if (from < to) {\n        onTimeRangeChange({ from, to });\n        setIsCustomRange(true);\n        setSelectedRange(\"Custom\");\n      }\n    }\n  };\n\n\n\n  return (\n    <div className=\"flex items-center space-x-2 text-sm\">\n      {/* Time Range Selector */}\n      <Popover>\n        <PopoverTrigger asChild>\n          <Button variant=\"outline\" size=\"sm\" className=\"h-8\">\n            <Calendar className=\"w-3 h-3 mr-1\" />\n            {selectedRange}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent className=\"w-80\">\n          <div className=\"space-y-4\">\n            <div>\n              <Label className=\"text-xs font-medium mb-2 block\">Quick ranges</Label>\n              <div className=\"grid grid-cols-2 gap-1\">\n                {TIME_RANGES.map((range) => (\n                  <Button\n                    key={range.label}\n                    variant={selectedRange === range.label ? \"default\" : \"ghost\"}\n                    size=\"sm\"\n                    className=\"h-7 text-xs justify-start\"\n                    onClick={() => handleQuickRangeSelect(range.value, range.label)}\n                  >\n                    {range.label}\n                  </Button>\n                ))}\n              </div>\n            </div>\n            \n            <div>\n              <Label className=\"text-xs font-medium mb-2 block\">Custom range</Label>\n              <div className=\"space-y-2\">\n                <div>\n                  <Label className=\"text-xs\">From</Label>\n                  <Input\n                    type=\"datetime-local\"\n                    value={customFrom}\n                    onChange={(e) => setCustomFrom(e.target.value)}\n                    className=\"h-7 text-xs\"\n                  />\n                </div>\n                <div>\n                  <Label className=\"text-xs\">To</Label>\n                  <Input\n                    type=\"datetime-local\"\n                    value={customTo}\n                    onChange={(e) => setCustomTo(e.target.value)}\n                    className=\"h-7 text-xs\"\n                  />\n                </div>\n                <Button\n                  size=\"sm\"\n                  onClick={handleCustomRangeApply}\n                  disabled={!customFrom || !customTo}\n                  className=\"h-7 w-full text-xs\"\n                >\n                  Apply custom range\n                </Button>\n              </div>\n            </div>\n          </div>\n        </PopoverContent>\n      </Popover>\n\n      {/* Refresh Interval */}\n      <Select \n        value={currentInterval.toString()} \n        onValueChange={(value) => {\n          const interval = parseInt(value);\n          onIntervalChange(interval);\n          if (interval > 0) {\n            onRefreshToggle(true);\n          } else {\n            onRefreshToggle(false);\n          }\n        }}\n      >\n        <SelectTrigger className=\"h-8 w-16\">\n          <SelectValue />\n        </SelectTrigger>\n        <SelectContent>\n          {REFRESH_INTERVALS.map((interval) => (\n            <SelectItem key={interval.value} value={interval.value.toString()}>\n              {interval.label}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n\n\n\n      {/* Current time indicator */}\n      <div className=\"text-xs text-muted-foreground\">\n        <Clock className=\"w-3 h-3 inline mr-1\" />\n        {new Date().toLocaleTimeString()}\n      </div>\n    </div>\n  );\n}","size_bytes":5612},"client/src/components/TraceList.tsx":{"content":"import { Card, CardHeader, CardTitle, CardContent } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport type { DiagramData } from \"@/types/diagram\";\n\ninterface TraceListProps {\n  data: DiagramData | null;\n  selectedTraceId: string | null;\n  onTraceSelect: (traceId: string | null) => void;\n}\n\nexport default function TraceList({ data, selectedTraceId, onTraceSelect }: TraceListProps) {\n  if (!data || !data.edges.length) {\n    return (\n      <Card className=\"w-full\">\n        <CardHeader>\n          <CardTitle className=\"text-sm\">Trace IDs</CardTitle>\n        </CardHeader>\n        <CardContent>\n          <p className=\"text-xs text-muted-foreground\">ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ</p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  // Collect all trace IDs from edges\n  const traceConnections = new Map<string, string[]>();\n  \n  data.edges.forEach(edge => {\n    if (edge.traceId) {\n      // Handle multiple trace IDs separated by comma\n      const traceIds = edge.traceId.split(',').map(id => id.trim());\n      traceIds.forEach(traceId => {\n        if (!traceConnections.has(traceId)) {\n          traceConnections.set(traceId, []);\n        }\n        const connectionLabel = `${edge.source} â†’ ${edge.target}`;\n        if (!traceConnections.get(traceId)!.includes(connectionLabel)) {\n          traceConnections.get(traceId)!.push(connectionLabel);\n        }\n      });\n    }\n  });\n\n  const sortedTraces = Array.from(traceConnections.entries()).sort(([a], [b]) => a.localeCompare(b));\n\n  return (\n    <div className=\"p-4\">\n      <h3 className=\"text-sm font-semibold text-slate-200 mb-3 flex items-center justify-between\">\n        <div className=\"flex items-center\">\n          <div className=\"w-2 h-2 bg-gradient-to-r from-purple-500 to-blue-500 rounded-full mr-2\"></div>\n          Trace IDs\n        </div>\n        <Badge variant=\"secondary\" className=\"text-xs\">\n          {sortedTraces.length}\n        </Badge>\n      </h3>\n      \n      <ScrollArea className=\"h-40\">\n        {sortedTraces.length === 0 ? (\n          <p className=\"text-xs text-muted-foreground\">ÐÐµÑ‚ trace_id Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…</p>\n        ) : (\n          <div className=\"space-y-1\">\n            {sortedTraces.map(([traceId, connections]) => (\n              <div \n                key={traceId} \n                className={`border rounded-lg p-2 cursor-pointer transition-colors ${\n                  selectedTraceId === traceId \n                    ? 'bg-blue-900/40 border-blue-400 border-2' \n                    : 'border-slate-600/30 hover:bg-slate-700/30'\n                }`}\n                onClick={() => onTraceSelect(selectedTraceId === traceId ? null : traceId)}\n              >\n                <div className=\"flex items-center gap-2 mb-1\">\n                  <Badge \n                    variant={selectedTraceId === traceId ? \"default\" : \"outline\"} \n                    className=\"text-xs font-mono px-1 py-0\"\n                  >\n                    {traceId}\n                  </Badge>\n                  <span className=\"text-xs text-muted-foreground\">\n                    ({connections.length})\n                  </span>\n                </div>\n                {connections.length > 0 && (\n                  <div className=\"text-xs text-muted-foreground font-mono\">\n                    {connections[0]}{connections.length > 1 && ` +${connections.length - 1}`}\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        )}\n      </ScrollArea>\n    </div>\n  );\n}","size_bytes":3592},"client/src/components/UnifiedSettings.tsx":{"content":"import { Switch } from \"@/components/ui/switch\";\nimport { Slider } from \"@/components/ui/slider\";\nimport type { DiagramSettings } from \"@/types/diagram\";\n\ninterface UnifiedSettingsProps {\n  settings: DiagramSettings;\n  onSettingsChange: (settings: DiagramSettings) => void;\n  onSpacingChange: (spacing: number) => void;\n  disabled?: boolean;\n  lodLevel?: 'high' | 'medium' | 'low';\n  relativeDistance?: number;\n  serviceCount?: number;\n}\n\nexport default function UnifiedSettings({\n  settings,\n  onSettingsChange,\n  onSpacingChange,\n  disabled = false,\n  lodLevel = 'high',\n  relativeDistance = 0,\n  serviceCount = 0,\n}: UnifiedSettingsProps) {\n  console.log('ðŸ”§ UnifiedSettings render: disabled=', disabled, 'settings.clusterSpacing=', settings.clusterSpacing);\n  \n  const handleToggle = (key: keyof DiagramSettings, value: boolean) => {\n    onSettingsChange({ ...settings, [key]: value });\n  };\n\n  const handleBrightnessChange = (value: number[]) => {\n    onSettingsChange({ ...settings, brightness: value[0] });\n  };\n\n  const handleSpacingChange = (value: number[]) => {\n    onSpacingChange(value[0]);\n  };\n\n  const handleClusterSpacingChange = (value: number[]) => {\n    console.log('ðŸ”§ UnifiedSettings: clusterSpacing changing from', settings.clusterSpacing, 'to', value[0]);\n    console.log('ðŸ”§ UnifiedSettings: disabled=', disabled, 'should prevent this call if true');\n    const newSettings = { ...settings, clusterSpacing: value[0] };\n    console.log('ðŸ”§ UnifiedSettings: calling onSettingsChange with:', newSettings);\n    onSettingsChange(newSettings);\n  };\n\n  const handleClusterSpacingYChange = (value: number[]) => {\n    onSettingsChange({ ...settings, clusterSpacingY: value[0] });\n  };\n\n  return (\n    <div className=\"space-y-4 p-4 bg-slate-800/50 rounded-lg border border-slate-700/60\">\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"text-sm font-medium text-slate-200\">Settings</h3>\n        <div className={`px-2 py-1 rounded text-xs font-medium ${\n          lodLevel === 'high' ? 'bg-green-700 text-green-100' :\n          lodLevel === 'medium' ? 'bg-yellow-700 text-yellow-100' :\n          'bg-red-700 text-red-100'\n        }`}>\n          LOD: {lodLevel.toUpperCase()}\n        </div>\n      </div>\n      \n      {/* LOD Information */}\n      <div className=\"text-xs text-slate-400 space-y-1\">\n        <div>Services: {serviceCount} | Relative Distance: {relativeDistance?.toFixed(2)}x</div>\n        <div className=\"text-xs\">\n          {lodLevel === 'low' && 'âš¡ Low detail: simplified geometry, no animations'}\n          {lodLevel === 'medium' && 'ðŸ”§ Medium detail: balanced performance'}\n          {lodLevel === 'high' && 'âœ¨ High detail: full animations & geometry'}\n        </div>\n      </div>\n      \n      <div className=\"space-y-4\">\n        {/* Node Spacing */}\n        <div>\n          <label className=\"block text-xs font-medium text-slate-400 mb-2\">\n            Node Spacing: {settings.nodeSpacing}\n          </label>\n          <Slider\n            value={[settings.nodeSpacing]}\n            onValueChange={handleSpacingChange}\n            min={50}\n            max={300}\n            step={10}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n\n        {/* Cluster Spacing */}\n        <div>\n          <label className=\"block text-xs font-medium text-slate-400 mb-2\">\n            Cluster Spacing: {settings.clusterSpacing || 600}\n          </label>\n          <Slider\n            value={[settings.clusterSpacing || 600]}\n            onValueChange={handleClusterSpacingChange}\n            onValueCommit={(value) => console.log('ðŸ”§ Slider COMMIT:', value)}\n            min={200}\n            max={1500}\n            step={50}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n\n        {/* Cluster Spacing Y */}\n        <div>\n          <label className=\"block text-xs font-medium text-slate-400 mb-2\">\n            Cluster Spacing Y: {settings.clusterSpacingY || 300}\n          </label>\n          <Slider\n            value={[settings.clusterSpacingY || 300]}\n            onValueChange={handleClusterSpacingYChange}\n            min={0}\n            max={1000}\n            step={25}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n\n        {/* Display Options */}\n        <div className=\"space-y-3\">\n          <div className=\"flex items-center justify-between\">\n            <label className=\"text-xs font-medium text-slate-400\">Show Labels</label>\n            <Switch\n              checked={settings.showLabels}\n              onCheckedChange={(checked) => handleToggle(\"showLabels\", checked)}\n              disabled={disabled}\n            />\n          </div>\n          \n          <div className=\"flex items-center justify-between\">\n            <label className=\"text-xs font-medium text-slate-400\">Show Arrows</label>\n            <Switch\n              checked={settings.showArrows}\n              onCheckedChange={(checked) => handleToggle(\"showArrows\", checked)}\n              disabled={disabled}\n            />\n          </div>\n        </div>\n        \n        {/* Brightness Control */}\n        <div>\n          <label className=\"block text-xs font-medium text-slate-400 mb-2\">\n            Brightness: {(settings.brightness || 1.0).toFixed(1)}x\n          </label>\n          <Slider\n            value={[settings.brightness || 1.0]}\n            onValueChange={handleBrightnessChange}\n            min={0.1}\n            max={3.0}\n            step={0.1}\n            disabled={disabled}\n            className=\"w-full\"\n          />\n        </div>\n\n      </div>\n    </div>\n  );\n}","size_bytes":5652},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","size_bytes":565},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","size_bytes":3895},"client/src/lib/diagramUtils.ts":{"content":"import * as d3 from \"d3\";\nimport type { DiagramNode, DiagramEdge, LayoutType } from \"@/types/diagram\";\n\nexport function applyForceLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number,\n  spacing: number = 100\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  const simulation = d3.forceSimulation(nodes as any)\n    .force(\"link\", d3.forceLink(edges).id((d: any) => d.id).distance(spacing))\n    .force(\"charge\", d3.forceManyBody().strength(-300))\n    .force(\"center\", d3.forceCenter(width / 2, height / 2))\n    .force(\"collision\", d3.forceCollide().radius(30));\n\n  // Run simulation\n  for (let i = 0; i < 300; i++) {\n    simulation.tick();\n  }\n\n  return { nodes, edges };\n}\n\nexport function applyHierarchicalLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  // Create a simple hierarchical layout\n  const nodeMap = new Map(nodes.map(node => [node.id, node]));\n  const levels: string[][] = [];\n  const visited = new Set<string>();\n  const inDegree = new Map<string, number>();\n\n  // Calculate in-degrees\n  nodes.forEach(node => inDegree.set(node.id, 0));\n  edges.forEach(edge => {\n    const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n    inDegree.set(targetId, (inDegree.get(targetId) || 0) + 1);\n  });\n\n  // Find root nodes (no incoming edges)\n  let currentLevel = nodes.filter(node => inDegree.get(node.id) === 0).map(node => node.id);\n  if (currentLevel.length === 0) {\n    currentLevel = [nodes[0]?.id].filter(Boolean);\n  }\n\n  while (currentLevel.length > 0 && visited.size < nodes.length) {\n    levels.push([...currentLevel]);\n    currentLevel.forEach(nodeId => visited.add(nodeId));\n\n    const nextLevel = new Set<string>();\n    currentLevel.forEach(nodeId => {\n      edges.forEach(edge => {\n        const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n        const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n        \n        if (sourceId === nodeId && !visited.has(targetId)) {\n          nextLevel.add(targetId);\n        }\n      });\n    });\n\n    currentLevel = Array.from(nextLevel);\n  }\n\n  // Position nodes\n  const levelHeight = height / Math.max(levels.length, 1);\n  levels.forEach((level, levelIndex) => {\n    const nodeWidth = width / Math.max(level.length, 1);\n    level.forEach((nodeId, nodeIndex) => {\n      const node = nodeMap.get(nodeId);\n      if (node) {\n        node.x = (nodeIndex + 0.5) * nodeWidth;\n        node.y = (levelIndex + 0.5) * levelHeight;\n      }\n    });\n  });\n\n  return { nodes, edges };\n}\n\nexport function applyCircularLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  const centerX = width / 2;\n  const centerY = height / 2;\n  const radius = Math.min(width, height) * 0.3;\n\n  nodes.forEach((node, index) => {\n    const angle = (2 * Math.PI * index) / nodes.length;\n    node.x = centerX + radius * Math.cos(angle);\n    node.y = centerY + radius * Math.sin(angle);\n  });\n\n  return { nodes, edges };\n}\n\nexport function applyGridLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  const cols = Math.ceil(Math.sqrt(nodes.length));\n  const rows = Math.ceil(nodes.length / cols);\n  const cellWidth = width / cols;\n  const cellHeight = height / rows;\n\n  nodes.forEach((node, index) => {\n    const row = Math.floor(index / cols);\n    const col = index % cols;\n    node.x = (col + 0.5) * cellWidth;\n    node.y = (row + 0.5) * cellHeight;\n  });\n\n  return { nodes, edges };\n}\n\nexport function applyServiceGroupedLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number,\n  spacing: number = 100\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  // Group nodes by service\n  const serviceGroups = new Map<string, DiagramNode[]>();\n  const standaloneNodes: DiagramNode[] = [];\n  \n  nodes.forEach(node => {\n    if (node.nodeType === 'endpoint' && node.service) {\n      if (!serviceGroups.has(node.service)) {\n        serviceGroups.set(node.service, []);\n      }\n      serviceGroups.get(node.service)!.push(node);\n    } else {\n      standaloneNodes.push(node);\n    }\n  });\n  \n  const margin = 80;\n  const serviceRadius = 100;\n  const servicesPerRow = Math.ceil(Math.sqrt(serviceGroups.size + standaloneNodes.length));\n  const serviceSpacing = spacing * 2.5;\n  \n  // Layout services in a grid pattern\n  let serviceIndex = 0;\n  serviceGroups.forEach((endpoints, serviceName) => {\n    const row = Math.floor(serviceIndex / servicesPerRow);\n    const col = serviceIndex % servicesPerRow;\n    \n    const serviceCenterX = margin + col * serviceSpacing + serviceSpacing / 2;\n    const serviceCenterY = margin + row * serviceSpacing + serviceSpacing / 2;\n    \n    // Position endpoints in a circle around service center\n    endpoints.forEach((endpoint, idx) => {\n      const angle = (idx / endpoints.length) * 2 * Math.PI;\n      const radius = Math.min(serviceRadius, 30 + endpoints.length * 8);\n      endpoint.x = serviceCenterX + Math.cos(angle) * radius;\n      endpoint.y = serviceCenterY + Math.sin(angle) * radius;\n    });\n    \n    serviceIndex++;\n  });\n  \n  // Position standalone nodes\n  standaloneNodes.forEach((node, idx) => {\n    const row = Math.floor((serviceIndex + idx) / servicesPerRow);\n    const col = (serviceIndex + idx) % servicesPerRow;\n    \n    node.x = margin + col * serviceSpacing + serviceSpacing / 2;\n    node.y = margin + row * serviceSpacing + serviceSpacing / 2;\n  });\n\n  return { nodes, edges };\n}\n\nexport function applyNetworkTopologyLayout(\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number,\n  spacing: number = 100\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  // Calculate connection counts for each node\n  const connectionCounts = new Map<string, number>();\n  edges.forEach(edge => {\n    const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n    const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n    connectionCounts.set(sourceId, (connectionCounts.get(sourceId) || 0) + 1);\n    connectionCounts.set(targetId, (connectionCounts.get(targetId) || 0) + 1);\n  });\n  \n  // Sort nodes by connection count (hubs first)\n  const sortedNodes = [...nodes].sort((a, b) => \n    (connectionCounts.get(b.id) || 0) - (connectionCounts.get(a.id) || 0)\n  );\n  \n  const centerX = width / 2;\n  const centerY = height / 2;\n  const maxRadius = Math.min(width, height) / 3;\n  \n  // Place nodes in concentric circles based on connectivity\n  sortedNodes.forEach((node, idx) => {\n    if (idx === 0) {\n      // Central hub (most connected)\n      node.x = centerX;\n      node.y = centerY;\n    } else {\n      const ring = Math.ceil(idx / 8); // 8 nodes per ring\n      const ringRadius = Math.min(maxRadius, ring * 60);\n      const nodesInRing = Math.min(8, sortedNodes.length - ((ring - 1) * 8));\n      const angleStep = (2 * Math.PI) / nodesInRing;\n      const angle = ((idx - 1) % 8) * angleStep;\n      \n      node.x = centerX + Math.cos(angle) * ringRadius;\n      node.y = centerY + Math.sin(angle) * ringRadius;\n    }\n  });\n\n  return { nodes, edges };\n}\n\nexport function applyLayout(\n  layoutType: LayoutType,\n  nodes: DiagramNode[],\n  edges: DiagramEdge[],\n  width: number,\n  height: number,\n  spacing: number = 100\n): { nodes: DiagramNode[]; edges: DiagramEdge[] } {\n  switch (layoutType) {\n    case \"force\":\n      return applyForceLayout(nodes, edges, width, height, spacing);\n    case \"hierarchical\":\n      return applyHierarchicalLayout(nodes, edges, width, height);\n    case \"circular\":\n      return applyCircularLayout(nodes, edges, width, height);\n    case \"grid\":\n      return applyGridLayout(nodes, edges, width, height);\n    case \"service-grouped\":\n      return applyServiceGroupedLayout(nodes, edges, width, height, spacing);\n    case \"network-topology\":\n      return applyNetworkTopologyLayout(nodes, edges, width, height, spacing);\n    default:\n      return { nodes, edges };\n  }\n}\n\nexport function exportAsSVG(svgElement: SVGSVGElement, filename: string = \"diagram.svg\") {\n  const serializer = new XMLSerializer();\n  const svgString = serializer.serializeToString(svgElement);\n  const blob = new Blob([svgString], { type: \"image/svg+xml\" });\n  const url = URL.createObjectURL(blob);\n  \n  const link = document.createElement(\"a\");\n  link.href = url;\n  link.download = filename;\n  link.click();\n  \n  URL.revokeObjectURL(url);\n}\n\nexport function exportAsPNG(svgElement: SVGSVGElement, filename: string = \"diagram.png\") {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return;\n\n  const svgData = new XMLSerializer().serializeToString(svgElement);\n  const img = new Image();\n  \n  img.onload = () => {\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n    \n    canvas.toBlob((blob) => {\n      if (blob) {\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement(\"a\");\n        link.href = url;\n        link.download = filename;\n        link.click();\n        URL.revokeObjectURL(url);\n      }\n    });\n  };\n  \n  const svgBlob = new Blob([svgData], { type: \"image/svg+xml;charset=utf-8\" });\n  img.src = URL.createObjectURL(svgBlob);\n}\n","size_bytes":9440},"client/src/lib/eventProcessor.ts":{"content":"import type { ParsedFileData, DiagramData, DiagramNode, DiagramEdge } from \"@/types/diagram\";\n\ninterface NetworkEvent {\n  id: number;\n  source: string;\n  target: string;\n  sourceService: string;\n  targetService: string;\n  sourceTenant: string;\n  targetTenant: string;\n  sourceSystem: string;\n  targetSystem: string;\n  sourceLabel: string;\n  targetLabel: string;\n  status: string;\n  method: string;\n  responseTime: number;\n  timestamp: string;\n  traceId?: string;\n  metadata: any;\n}\n\n// Convert network events from database to diagram format\nexport function processNetworkEvents(events: NetworkEvent[]): ParsedFileData {\n  const allNodes = new Map<string, DiagramNode>();\n  const connectionCounts = new Map<string, number>();\n  const statusCounts = new Map<string, Record<string, number>>();\n  const traceIds = new Map<string, Set<string>>();\n  const detectedServices = new Map<string, Set<string>>();\n  \n  // Process events to extract nodes and edges\n  events.forEach(event => {\n    const sourceId = event.source;\n    const targetId = event.target;\n    const connectionKey = `${sourceId}->${targetId}`;\n    \n    // Track connection counts\n    connectionCounts.set(connectionKey, (connectionCounts.get(connectionKey) || 0) + 1);\n    \n    // Track status codes for this connection\n    if (!statusCounts.has(connectionKey)) {\n      statusCounts.set(connectionKey, {});\n    }\n    const statusCount = statusCounts.get(connectionKey)!;\n    statusCount[event.status] = (statusCount[event.status] || 0) + 1;\n    \n    // Track trace IDs for this connection\n    if (event.traceId) {\n      if (!traceIds.has(connectionKey)) {\n        traceIds.set(connectionKey, new Set());\n      }\n      traceIds.get(connectionKey)!.add(event.traceId);\n    }\n    \n    // Track services and their endpoints\n    if (!detectedServices.has(event.sourceService)) {\n      detectedServices.set(event.sourceService, new Set());\n    }\n    detectedServices.get(event.sourceService)!.add(event.sourceLabel);\n    \n    if (!detectedServices.has(event.targetService)) {\n      detectedServices.set(event.targetService, new Set());\n    }\n    detectedServices.get(event.targetService)!.add(event.targetLabel);\n    \n    // Create or update source node\n    if (!allNodes.has(sourceId)) {\n      allNodes.set(sourceId, {\n        id: sourceId,\n        label: event.sourceLabel,\n        service: event.sourceService,\n        tenant: event.sourceTenant,\n        system: event.sourceSystem,\n        nodeType: 'endpoint'\n      });\n    }\n    \n    // Create or update target node\n    if (!allNodes.has(targetId)) {\n      allNodes.set(targetId, {\n        id: targetId,\n        label: event.targetLabel,\n        service: event.targetService,\n        tenant: event.targetTenant,\n        system: event.targetSystem,\n        nodeType: 'endpoint'\n      });\n    }\n  });\n  \n  // Create edges with connection strength and status information\n  const edges: DiagramEdge[] = [];\n  const processedConnections = new Set<string>();\n  \n  events.forEach(event => {\n    const sourceId = event.source;\n    const targetId = event.target;\n    const forwardKey = `${sourceId}->${targetId}`;\n    const reverseKey = `${targetId}->${sourceId}`;\n    \n    if (processedConnections.has(forwardKey)) return;\n    \n    const forwardCount = connectionCounts.get(forwardKey) || 0;\n    const reverseCount = connectionCounts.get(reverseKey) || 0;\n    \n    // Determine traffic type\n    const sourceService = event.sourceService;\n    const targetService = event.targetService;\n    let trafficType: 'inter-service' | 'intra-service' | 'external';\n    \n    if (!sourceService || !targetService) {\n      trafficType = 'external';\n    } else if (sourceService === targetService) {\n      trafficType = 'intra-service';\n    } else {\n      trafficType = 'inter-service';\n    }\n    \n    if (forwardCount > 0) {\n      const connectionTraces = traceIds.get(forwardKey);\n      edges.push({\n        id: `${sourceId}-${targetId}`,\n        source: sourceId,\n        target: targetId,\n        connectionCount: forwardCount,\n        trafficType,\n        statusCounts: statusCounts.get(forwardKey) || {},\n        traceId: connectionTraces && connectionTraces.size > 0 ? Array.from(connectionTraces).join(',') : undefined\n      });\n      processedConnections.add(forwardKey);\n    }\n    \n    // Add reverse edge only if it has connections and hasn't been processed\n    if (reverseCount > 0 && !processedConnections.has(reverseKey)) {\n      const reverseTraces = traceIds.get(reverseKey);\n      edges.push({\n        id: `${targetId}-${sourceId}`,\n        source: targetId,\n        target: sourceId,\n        connectionCount: reverseCount,\n        trafficType,\n        statusCounts: statusCounts.get(reverseKey) || {},\n        traceId: reverseTraces && reverseTraces.size > 0 ? Array.from(reverseTraces).join(',') : undefined\n      });\n      processedConnections.add(reverseKey);\n    }\n  });\n  \n  const aggregatedData: DiagramData = {\n    nodes: Array.from(allNodes.values()),\n    edges\n  };\n  \n  const stats = {\n    nodeCount: aggregatedData.nodes.length,\n    edgeCount: aggregatedData.edges.length,\n    componentCount: detectedServices.size\n  };\n  \n  return {\n    data: aggregatedData,\n    stats\n  };\n}\n\n// Merge real-time events with existing file data\nexport function mergeEventData(existingData: ParsedFileData | null, eventData: ParsedFileData): ParsedFileData {\n  if (!existingData) return eventData;\n  \n  // Combine nodes from both sources\n  const allNodes = new Map<string, DiagramNode>();\n  \n  // Add existing nodes\n  existingData.data.nodes.forEach(node => {\n    allNodes.set(node.id, node);\n  });\n  \n  // Add/update with real-time nodes\n  eventData.data.nodes.forEach(node => {\n    allNodes.set(node.id, node);\n  });\n  \n  // Combine edges, preferring real-time data for connections that exist in both\n  const allEdges = new Map<string, DiagramEdge>();\n  \n  // Add existing edges\n  existingData.data.edges.forEach(edge => {\n    const key = `${edge.source}-${edge.target}`;\n    allEdges.set(key, edge);\n  });\n  \n  // Update with real-time edges (they override existing ones)\n  eventData.data.edges.forEach(edge => {\n    const key = `${edge.source}-${edge.target}`;\n    allEdges.set(key, edge);\n  });\n  \n  const mergedData: DiagramData = {\n    nodes: Array.from(allNodes.values()),\n    edges: Array.from(allEdges.values())\n  };\n  \n  const stats = {\n    nodeCount: mergedData.nodes.length,\n    edgeCount: mergedData.edges.length,\n    componentCount: new Set(mergedData.nodes.map(n => n.service).filter(Boolean)).size\n  };\n  \n  return {\n    data: mergedData,\n    stats\n  };\n}","size_bytes":6569},"client/src/lib/fileParser.ts":{"content":"export async function parseFile(file: File): Promise<any> {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  const response = await fetch('/api/parse-file', {\n    method: 'POST',\n    body: formData,\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || 'Failed to parse file');\n  }\n\n  return response.json();\n}\n\nexport function validateFileType(file: File): boolean {\n  const allowedTypes = [\n    'text/csv',\n    'application/vnd.ms-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n  ];\n  \n  const allowedExtensions = ['.csv', '.xlsx', '.xls'];\n  const hasValidType = allowedTypes.includes(file.type);\n  const hasValidExtension = allowedExtensions.some(ext => \n    file.name.toLowerCase().endsWith(ext)\n  );\n\n  return hasValidType || hasValidExtension;\n}\n","size_bytes":861},"client/src/lib/opentelemetryProcessor.ts":{"content":"import type { DiagramData, DiagramNode, DiagramEdge, ParsedFileData, DiagramStats } from '@/types/diagram';\n\n// OpenTelemetry types matching server schema\ninterface OtelTrace {\n  id: number;\n  traceId: string;\n  serviceName: string;\n  serviceVersion: string;\n  tenant: string;\n  system: string;\n  startTime: string;\n  endTime: string | null;\n  duration: number | null;\n  spanCount: number;\n  status: string;\n  statusMessage: string | null;\n  attributes: Record<string, any>;\n  resource: Record<string, any>;\n  createdAt: string;\n}\n\ninterface OtelSpan {\n  id: number;\n  traceId: string;\n  spanId: string;\n  parentSpanId: string | null;\n  operationName: string;\n  serviceName: string;\n  tenant: string;\n  system: string;\n  kind: string; // client, server, internal, producer, consumer\n  startTime: string;\n  endTime: string | null;\n  duration: number | null;\n  status: string;\n  statusMessage: string | null;\n  attributes: Record<string, any>;\n  events: any[];\n  links: any[];\n  resource: Record<string, any>;\n  createdAt: string;\n}\n\n// Span kind mappings\nconst SPAN_KINDS: Record<string, string> = {\n  'client': 'Client',\n  'server': 'Server', \n  'internal': 'Internal',\n  'producer': 'Producer',\n  'consumer': 'Consumer'\n} as const;\n\n// Status color mappings\nconst STATUS_COLORS = {\n  'ok': '#22c55e',      // green\n  'error': '#ef4444',   // red\n  'unset': '#6b7280'    // gray\n} as const;\n\n// Process OpenTelemetry traces and spans into diagram format\nexport function processOpenTelemetryData(traces: OtelTrace[], allSpans: OtelSpan[]): ParsedFileData {\n  const nodes: DiagramNode[] = [];\n  const edges: DiagramEdge[] = [];\n  const nodeMap = new Map<string, DiagramNode>();\n  const edgeMap = new Map<string, DiagramEdge>();\n\n  // Create service nodes from spans\n  const serviceMap = new Map<string, { service: string; operations: Set<string>; version: string }>();\n  \n  allSpans.forEach(span => {\n    const serviceKey = span.serviceName;\n    if (!serviceMap.has(serviceKey)) {\n      serviceMap.set(serviceKey, {\n        service: span.serviceName,\n        operations: new Set(),\n        version: span.resource?.['service.version'] || 'unknown'\n      });\n    }\n    serviceMap.get(serviceKey)!.operations.add(span.operationName);\n  });\n\n  // Create nodes for each service.operation combination\n  allSpans.forEach(span => {\n    const nodeId = `${span.serviceName}_${span.operationName}`;\n    \n    if (!nodeMap.has(nodeId)) {\n      const node: DiagramNode = {\n        id: nodeId,\n        label: span.operationName,\n        type: 'endpoint',\n        x: 0,\n        y: 0,\n        service: span.serviceName,\n        tenant: span.tenant,\n        system: span.system,\n        nodeType: 'endpoint',\n        endpoints: new Set([span.operationName])\n      };\n      \n      nodeMap.set(nodeId, node);\n      nodes.push(node);\n    }\n  });\n\n  // Create edges from span relationships and service calls\n  traces.forEach(trace => {\n    const traceSpans = allSpans.filter(span => span.traceId === trace.traceId);\n    \n    // Sort spans by start time to understand call order\n    traceSpans.sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());\n    \n    // Create edges based on parent-child relationships\n    traceSpans.forEach(span => {\n      if (span.parentSpanId) {\n        const parentSpan = traceSpans.find(s => s.spanId === span.parentSpanId);\n        if (parentSpan) {\n          const sourceId = `${parentSpan.serviceName}_${parentSpan.operationName}`;\n          const targetId = `${span.serviceName}_${span.operationName}`;\n          \n          // Only create edge if it's between different services\n          if (parentSpan.serviceName !== span.serviceName) {\n            const edgeId = `${sourceId}-${targetId}`;\n            \n            if (!edgeMap.has(edgeId)) {\n              const edge: DiagramEdge = {\n                id: edgeId,\n                source: sourceId,\n                target: targetId,\n                label: `${SPAN_KINDS[span.kind] || span.kind} Call`,\n                connectionCount: 0,\n                trafficType: 'inter-service',\n                latency: span.duration ? Math.round(span.duration / 1000000) : 0, // Convert to ms\n                status: span.status,\n                statusCounts: {},\n                traceId: span.traceId\n              };\n              \n              edgeMap.set(edgeId, edge);\n              edges.push(edge);\n            }\n            \n            // Update connection count and status\n            const edge = edgeMap.get(edgeId)!;\n            edge.connectionCount = (edge.connectionCount || 0) + 1;\n            \n            // Update traceId (combine if multiple traces use same edge)\n            if (edge.traceId && edge.traceId !== span.traceId) {\n              const existingTraces = edge.traceId.split(',').map(id => id.trim());\n              if (!existingTraces.includes(span.traceId)) {\n                edge.traceId = `${edge.traceId},${span.traceId}`;\n              }\n            } else if (!edge.traceId) {\n              edge.traceId = span.traceId;\n            }\n            \n            // Track status codes\n            const statusKey = span.attributes?.['http.status_code'] || span.status;\n            if (!edge.statusCounts) edge.statusCounts = {};\n            edge.statusCounts[statusKey] = (edge.statusCounts[statusKey] || 0) + 1;\n          }\n        }\n      }\n    });\n  });\n\n  // Calculate statistics\n  const stats: DiagramStats = {\n    nodeCount: nodes.length,\n    edgeCount: edges.length,\n    totalConnections: edges.reduce((sum, edge) => sum + (edge.connectionCount || 1), 0),\n    connectedComponents: calculateConnectedComponents(nodes, edges),\n    componentCount: calculateConnectedComponents(nodes, edges)\n  };\n\n  const data: DiagramData = { nodes, edges };\n\n  return { data, stats };\n}\n\n// Merge OpenTelemetry data with existing file data\nexport function mergeOpenTelemetryData(\n  existingData: ParsedFileData | null,\n  otelData: ParsedFileData\n): ParsedFileData {\n  if (!existingData) {\n    return otelData;\n  }\n\n  const nodeMap = new Map<string, DiagramNode>();\n  const edgeMap = new Map<string, DiagramEdge>();\n\n  // Add existing nodes\n  existingData.data.nodes.forEach(node => {\n    nodeMap.set(node.id, { ...node });\n  });\n\n  // Add existing edges\n  existingData.data.edges.forEach(edge => {\n    edgeMap.set(edge.id, { ...edge });\n  });\n\n  // Merge new nodes\n  otelData.data.nodes.forEach(node => {\n    if (nodeMap.has(node.id)) {\n      // Update existing node\n      const existing = nodeMap.get(node.id)!;\n      if (node.endpoints) {\n        existing.endpoints = [...new Set([...(existing.endpoints || []), ...node.endpoints])];\n      }\n    } else {\n      nodeMap.set(node.id, { ...node });\n    }\n  });\n\n  // Merge new edges\n  otelData.data.edges.forEach(edge => {\n    if (edgeMap.has(edge.id)) {\n      // Merge connection counts and status codes\n      const existing = edgeMap.get(edge.id)!;\n      existing.connectionCount = (existing.connectionCount || 0) + (edge.connectionCount || 1);\n      \n      if (edge.statusCounts) {\n        if (!existing.statusCounts) existing.statusCounts = {};\n        Object.entries(edge.statusCounts).forEach(([status, count]) => {\n          existing.statusCounts![status] = (existing.statusCounts![status] || 0) + count;\n        });\n      }\n      \n      // Update latency (average)\n      if (edge.latency && existing.latency) {\n        existing.latency = Math.round((existing.latency + edge.latency) / 2);\n      } else if (edge.latency) {\n        existing.latency = edge.latency;\n      }\n    } else {\n      edgeMap.set(edge.id, { ...edge });\n    }\n  });\n\n  const mergedNodes = Array.from(nodeMap.values());\n  const mergedEdges = Array.from(edgeMap.values());\n\n  const stats: DiagramStats = {\n    nodeCount: mergedNodes.length,\n    edgeCount: mergedEdges.length,\n    totalConnections: mergedEdges.reduce((sum, edge) => sum + (edge.connectionCount || 1), 0),\n    connectedComponents: calculateConnectedComponents(mergedNodes, mergedEdges),\n    componentCount: calculateConnectedComponents(mergedNodes, mergedEdges)\n  };\n\n  return {\n    data: { nodes: mergedNodes, edges: mergedEdges },\n    stats\n  };\n}\n\n// Calculate connected components for graph analysis\nfunction calculateConnectedComponents(nodes: DiagramNode[], edges: DiagramEdge[]): number {\n  const nodeSet = new Set(nodes.map(n => n.id));\n  const adjacencyList = new Map<string, Set<string>>();\n  \n  // Initialize adjacency list\n  nodes.forEach(node => {\n    adjacencyList.set(node.id, new Set());\n  });\n  \n  // Build adjacency list\n  edges.forEach(edge => {\n    const source = typeof edge.source === 'string' ? edge.source : edge.source.id;\n    const target = typeof edge.target === 'string' ? edge.target : edge.target.id;\n    \n    if (nodeSet.has(source) && nodeSet.has(target)) {\n      adjacencyList.get(source)?.add(target);\n      adjacencyList.get(target)?.add(source);\n    }\n  });\n  \n  const visited = new Set<string>();\n  let components = 0;\n  \n  function dfs(nodeId: string) {\n    visited.add(nodeId);\n    adjacencyList.get(nodeId)?.forEach(neighbor => {\n      if (!visited.has(neighbor)) {\n        dfs(neighbor);\n      }\n    });\n  }\n  \n  nodes.forEach(node => {\n    if (!visited.has(node.id)) {\n      dfs(node.id);\n      components++;\n    }\n  });\n  \n  return components;\n}\n\n// Convert traces for trace list display\nexport function convertTracesForDisplay(traces: OtelTrace[]): Array<{\n  traceId: string;\n  serviceName: string;\n  duration: number;\n  spanCount: number;\n  status: string;\n  timestamp: string;\n}> {\n  return traces.map(trace => ({\n    traceId: trace.traceId,\n    serviceName: trace.serviceName,\n    duration: trace.duration || 0,\n    spanCount: trace.spanCount,\n    status: trace.status,\n    timestamp: trace.startTime\n  }));\n}\n\n// Get span hierarchy for a trace\nexport function getSpanHierarchy(spans: OtelSpan[]): Array<OtelSpan & { level: number; children: string[] }> {\n  const spanMap = new Map(spans.map(span => [span.spanId, span]));\n  const hierarchy: Array<OtelSpan & { level: number; children: string[] }> = [];\n  \n  // Find root spans (no parent)\n  const rootSpans = spans.filter(span => !span.parentSpanId);\n  \n  function buildHierarchy(span: OtelSpan, level: number = 0): void {\n    const children = spans.filter(s => s.parentSpanId === span.spanId).map(s => s.spanId);\n    \n    hierarchy.push({\n      ...span,\n      level,\n      children\n    });\n    \n    // Process children\n    children.forEach(childId => {\n      const childSpan = spanMap.get(childId);\n      if (childSpan) {\n        buildHierarchy(childSpan, level + 1);\n      }\n    });\n  }\n  \n  rootSpans.forEach(rootSpan => buildHierarchy(rootSpan));\n  \n  return hierarchy;\n}","size_bytes":10666},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey[0] as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","size_bytes":1376},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","size_bytes":166},"client/src/pages/DiagramGenerator.tsx":{"content":"import { useState, useMemo } from \"react\";\nimport { ChartGantt, Download, HelpCircle } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport Sidebar from \"@/components/Sidebar\";\nimport DiagramCanvas from \"@/components/DiagramCanvas\";\nimport Diagram3D from \"@/components/Diagram3D\";\nimport HelpPanel from \"@/components/HelpPanel\";\nimport DataGeneratorControls from \"@/components/DataGeneratorControls\";\nimport { processNetworkEvents, mergeEventData } from \"@/lib/eventProcessor\";\nimport { processOpenTelemetryData, mergeOpenTelemetryData } from \"@/lib/opentelemetryProcessor\";\nimport type { ParsedFileData, DiagramSettings, LayoutType } from \"@/types/diagram\";\n\nexport default function DiagramGenerator() {\n  const [data, setData] = useState<ParsedFileData | null>(null);\n  const [fileName, setFileName] = useState<string>(\"\");\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [layout, setLayout] = useState<LayoutType>(\"force\");\n  const [settings, setSettings] = useState<DiagramSettings>({\n    showLabels: true,\n    showArrows: true,\n    nodeColor: \"primary\",\n    nodeSpacing: 120,\n    clusterSpacing: 600,\n    clusterSpacingY: 300,\n    edgeColor: \"#6b7280\",\n    backgroundColor: \"#f8fafc\",\n    showLegend: true,\n    brightness: 1.0,\n  });\n  const [helpOpen, setHelpOpen] = useState(false);\n  const [refreshLayout, setRefreshLayout] = useState(0);\n  const [realTimeData, setRealTimeData] = useState<ParsedFileData | null>(null);\n  const [isRealTimeMode, setIsRealTimeMode] = useState(false);\n  const [diagram3DRef, setDiagram3DRef] = useState<{ saveCameraState: () => void } | null>(null);\n  const [selectedTraceId, setSelectedTraceId] = useState<string | null>(null);\n  const [isOpenTelemetryMode, setIsOpenTelemetryMode] = useState(false);\n  const [openTelemetryData, setOpenTelemetryData] = useState<ParsedFileData | null>(null);\n  const [isDataGeneratorActive, setIsDataGeneratorActive] = useState(false);\n  const [lodInfo, setLodInfo] = useState<{ \n    level: 'high' | 'medium' | 'low', \n    relativeDistance: number, \n    serviceCount: number \n  }>({ level: 'high', relativeDistance: 0, serviceCount: 0 });\n  \n  const { toast } = useToast();\n\n  const handleFileProcessed = (newData: ParsedFileData, newFileName: string) => {\n    setData(newData);\n    setFileName(newFileName);\n\n    setRefreshLayout(prev => prev + 1);\n    toast({\n      title: \"File processed successfully\",\n      description: `Loaded ${newData.stats.nodeCount} nodes and ${newData.stats.edgeCount} edges`,\n    });\n  };\n\n  const handleMultipleFilesProcessed = (aggregatedData: ParsedFileData, filenames: string[]) => {\n    const combinedFileName = `${filenames.length} files combined`;\n    setData(aggregatedData);\n    setFileName(combinedFileName);\n\n    setRefreshLayout(prev => prev + 1);\n    \n    const totalConnections = aggregatedData.data.edges.reduce((sum, edge) => sum + (edge.connectionCount || 1), 0);\n    toast({\n      title: \"Multiple files processed successfully\",\n      description: `Combined ${filenames.length} files: ${aggregatedData.stats.nodeCount} nodes, ${totalConnections} total connections`,\n    });\n  };\n\n  const handleError = (error: string) => {\n    toast({\n      title: \"Error processing file\",\n      description: error,\n      variant: \"destructive\",\n    });\n  };\n\n  const handleLayoutChange = (newLayout: LayoutType) => {\n    setLayout(newLayout);\n  };\n\n  const handleSpacingChange = (spacing: number) => {\n    setSettings(prev => ({ ...prev, nodeSpacing: spacing }));\n  };\n\n  const handleApplyLayout = () => {\n    setRefreshLayout(prev => prev + 1);\n    toast({\n      title: \"Layout applied\",\n      description: `Applied ${layout} layout with ${settings.nodeSpacing}px spacing`,\n    });\n  };\n\n  const handleClearData = () => {\n    setData(null);\n    setFileName(\"\");\n    setRealTimeData(null);\n    setIsRealTimeMode(false);\n    setOpenTelemetryData(null);\n    setIsOpenTelemetryMode(false);\n    setRefreshLayout(prev => prev + 1);\n    toast({\n      title: \"Data cleared\",\n      description: \"All diagram data has been removed\",\n    });\n  };\n\n  const handleBeforeUpdate = () => {\n    // This will be called before data updates to save camera state\n    if (diagram3DRef && diagram3DRef.saveCameraState) {\n      diagram3DRef.saveCameraState();\n    }\n  };\n\n  const handleLODUpdate = (level: 'high' | 'medium' | 'low', relativeDistance: number, serviceCount: number) => {\n    setLodInfo({ level, relativeDistance, serviceCount });\n  };\n\n  const handleRealTimeDataUpdate = (events: any[]) => {\n    if (events.length === 0) {\n      // Clear real-time data when no events found\n      setRealTimeData(null);\n      setRefreshLayout(prev => prev + 1);\n      return;\n    }\n    \n    const eventData = processNetworkEvents(events);\n    setRealTimeData(eventData);\n    setIsRealTimeMode(true);\n    \n    // Auto-switch to 3D mode for real-time data\n    if (layout !== \"3d-network\") {\n      setLayout(\"3d-network\");\n    }\n    \n    setRefreshLayout(prev => prev + 1);\n    \n    toast({\n      title: \"Real-time data loaded\",\n      description: `${events.length} events â€¢ ${eventData.stats.nodeCount} nodes â€¢ ${eventData.stats.edgeCount} connections`,\n    });\n  };\n\n  const handleOpenTelemetryDataUpdate = (otelData: { traces: any[]; spans: any[] }) => {\n    if (!otelData.traces || otelData.traces.length === 0) {\n      setOpenTelemetryData(null);\n      setIsOpenTelemetryMode(false);\n      setRefreshLayout(prev => prev + 1);\n      return;\n    }\n    \n    const processedData = processOpenTelemetryData(otelData.traces, otelData.spans);\n    setOpenTelemetryData(processedData);\n    setIsOpenTelemetryMode(true);\n    \n    // Auto-switch to 3D mode for OpenTelemetry data\n    if (layout !== \"3d-network\") {\n      setLayout(\"3d-network\");\n    }\n    \n    setRefreshLayout(prev => prev + 1);\n    \n    toast({\n      title: \"OpenTelemetry data loaded\",\n      description: `${otelData.traces.length} traces â€¢ ${processedData.stats.nodeCount} nodes â€¢ ${processedData.stats.edgeCount} connections`,\n    });\n  };\n\n  const handleDataGeneratorUpdate = (data: any) => {\n    // Check if this is OpenTelemetry data (has traces and spans)\n    if (data && typeof data === 'object' && 'traces' in data && 'spans' in data) {\n      handleOpenTelemetryDataUpdate(data);\n    } else if (Array.isArray(data)) {\n      // This is network events data\n      handleRealTimeDataUpdate(data);\n    }\n  };\n\n  // Memoize the display data to prevent unnecessary re-renders\n  const displayData = useMemo(() => {\n    const result = openTelemetryData ? (data ? mergeOpenTelemetryData(data, openTelemetryData) : openTelemetryData) : (realTimeData && data ? mergeEventData(data, realTimeData) : realTimeData || data);\n    \n    console.log('ðŸ“Š useMemo recalculating displayData', { \n      hasRealTime: !!realTimeData, \n      hasFileData: !!data,\n      hasOpenTelemetry: !!openTelemetryData,\n      realTimeEdges: realTimeData?.data.edges.length || 0,\n      fileDataEdges: data?.data.edges.length || 0,\n      otelEdges: openTelemetryData?.data.edges.length || 0,\n      resultEdges: result?.data.edges.length || 0,\n      sampleTraceIds: result?.data.edges.slice(0, 3).map(e => e.traceId) || []\n    });\n    \n    return result;\n  }, [realTimeData, data, openTelemetryData]);\n\n  const handleExport = () => {\n    // This will be handled by the DiagramCanvas component\n    toast({\n      title: \"Export options\",\n      description: \"Use the export buttons in the canvas toolbar\",\n    });\n  };\n\n  return (\n    <>\n      {/* Header */}\n      <header className=\"bg-gradient-to-r from-slate-900 via-purple-900 to-slate-900 shadow-lg border-b border-purple-500/20 sticky top-0 z-40 backdrop-blur-sm\">\n        <div className=\"max-w-full px-4 sm:px-6 lg:px-8\">\n          <div className=\"flex justify-between items-center h-16\">\n            <div className=\"flex items-center space-x-4\">\n              <div className=\"flex items-center space-x-3\">\n                <div className=\"w-10 h-10 bg-gradient-to-br from-purple-500 to-blue-600 rounded-xl flex items-center justify-center shadow-lg ring-2 ring-purple-500/30\">\n                  <ChartGantt className=\"w-5 h-5 text-white\" />\n                </div>\n                <div className=\"flex flex-col\">\n                  <h1 className=\"text-xl font-bold bg-gradient-to-r from-white to-purple-100 bg-clip-text text-transparent\">\n                    DiagramFlow\n                  </h1>\n                  <span className=\"text-xs text-purple-200/70 font-medium\">3D Network Visualization</span>\n                </div>\n              </div>\n              <div className=\"hidden md:flex items-center space-x-6 ml-8\">\n                <div className=\"flex items-center space-x-2 bg-black/20 backdrop-blur-sm rounded-lg px-3 py-1.5 border border-purple-500/20\">\n                  <div className=\"w-2 h-2 bg-green-400 rounded-full animate-pulse\"></div>\n                  <span className=\"text-sm text-purple-100 font-medium\">\n                    {fileName || \"No file loaded\"}\n                  </span>\n                </div>\n              </div>\n            </div>\n            \n            {/* Unified data generator controls */}\n            <div className=\"flex-1 flex justify-center\">\n              <DataGeneratorControls \n                onDataUpdate={handleDataGeneratorUpdate} \n                onBeforeUpdate={handleBeforeUpdate}\n                isActive={isDataGeneratorActive}\n                onActiveChange={setIsDataGeneratorActive}\n              />\n            </div>\n            \n            <div className=\"flex items-center space-x-3\">\n              <Button\n                onClick={handleExport}\n                className=\"bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white shadow-lg hover:shadow-xl transition-all duration-200 border-0 ring-1 ring-purple-500/30\"\n              >\n                <Download className=\"w-4 h-4 mr-2\" />\n                <span className=\"hidden sm:inline font-medium\">Export</span>\n              </Button>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={() => setHelpOpen(true)}\n                className=\"h-9 w-9 p-0 text-purple-200 hover:text-white hover:bg-purple-500/20 rounded-xl transition-all duration-200\"\n              >\n                <HelpCircle className=\"h-5 w-5\" />\n              </Button>\n            </div>\n          </div>\n        </div>\n      </header>\n\n      <div className=\"flex overflow-hidden\" style={{ height: 'calc(100vh - 4rem)' }}>\n        <Sidebar\n          layout={layout}\n          settings={settings}\n          stats={displayData?.stats || null}\n          data={displayData?.data || null}\n          onLayoutChange={handleLayoutChange}\n          onSpacingChange={handleSpacingChange}\n          onApplyLayout={handleApplyLayout}\n          onSettingsChange={(newSettings) => {\n            console.log('ðŸ”§ DiagramGenerator: onSettingsChange called with:', newSettings);\n            console.log('ðŸ”§ DiagramGenerator: hasData=', !!displayData, 'displayData=', displayData ? `${displayData.data?.nodes?.length || 0} nodes` : 'null');\n            setSettings(newSettings);\n          }}\n          hasData={!!displayData}\n          selectedTraceId={selectedTraceId}\n          onTraceSelect={(traceId) => {\n            console.log('ðŸŽ¯ onTraceSelect called with:', traceId);\n            setSelectedTraceId(traceId);\n          }}\n          lodLevel={lodInfo.level}\n          relativeDistance={lodInfo.relativeDistance}\n          serviceCount={lodInfo.serviceCount}\n        />\n\n        {layout === \"3d-network\" ? (\n          <Diagram3D\n            data={displayData?.data || null}\n            settings={settings}\n            onApplyLayout={handleApplyLayout}\n            selectedTraceId={selectedTraceId}\n            onLODUpdate={handleLODUpdate}\n          />\n        ) : (\n          <DiagramCanvas\n            data={displayData?.data || null}\n            settings={settings}\n            layout={layout}\n            key={refreshLayout} // Force re-render when layout is applied\n          />\n        )}\n      </div>\n\n      <HelpPanel isOpen={helpOpen} onClose={() => setHelpOpen(false)} />\n    </>\n  );\n}\n","size_bytes":12230},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","size_bytes":711},"client/src/test/components.test.tsx":{"content":"import { describe, it, expect, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport Statistics from '@/components/Statistics';\nimport TraceList from '@/components/TraceList';\nimport type { DiagramData } from '@/types/diagram';\n\n// Create a test query client\nconst createTestQueryClient = () => new QueryClient({\n  defaultOptions: {\n    queries: { retry: false },\n    mutations: { retry: false },\n  },\n});\n\n// Wrapper component for tests that need QueryClient\nconst TestWrapper = ({ children }: { children: React.ReactNode }) => {\n  const queryClient = createTestQueryClient();\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};\n\ndescribe('Statistics Component', () => {\n  const mockData: DiagramData = {\n    nodes: [\n      { id: 'node1', label: 'API Service', service: 'api-service' },\n      { id: 'node2', label: 'Gateway Service', service: 'gateway-service' },\n    ],\n    edges: [\n      {\n        id: 'edge1',\n        source: 'node1',\n        target: 'node2',\n        connectionCount: 100,\n        statusCounts: { '200': 80, '404': 15, '500': 5 }\n      }\n    ]\n  };\n\n  const mockStats = {\n    nodeCount: 2,\n    edgeCount: 1,\n    componentCount: 1\n  };\n\n  it('should render statistics correctly', () => {\n    render(\n      <TestWrapper>\n        <Statistics stats={mockStats} data={mockData} />\n      </TestWrapper>\n    );\n\n    expect(screen.getByText('Request Statistics')).toBeInTheDocument();\n  });\n\n  it('should display HTTP status percentages', () => {\n    render(\n      <TestWrapper>\n        <Statistics stats={mockStats} data={mockData} />\n      </TestWrapper>\n    );\n\n    // Should show success percentage (80/100 = 80%)\n    expect(screen.getByText(/80%/)).toBeInTheDocument();\n  });\n\n  it('should handle connection filtering', async () => {\n    render(\n      <TestWrapper>\n        <Statistics stats={mockStats} data={mockData} />\n      </TestWrapper>\n    );\n\n    // Should have a connection filter dropdown if multiple connections exist\n    const filterSelect = screen.getByRole('combobox');\n    expect(filterSelect).toBeInTheDocument();\n  });\n\n  it('should handle null data gracefully', () => {\n    render(\n      <TestWrapper>\n        <Statistics stats={null} data={null} />\n      </TestWrapper>\n    );\n\n    expect(screen.getByText('Request Statistics')).toBeInTheDocument();\n  });\n});\n\ndescribe('TraceList Component', () => {\n  const mockData: DiagramData = {\n    nodes: [\n      { id: 'node1', label: 'Service 1', service: 'service1' },\n      { id: 'node2', label: 'Service 2', service: 'service2' },\n    ],\n    edges: [\n      {\n        id: 'edge1',\n        source: 'node1',\n        target: 'node2',\n        traceId: 'trace-001',\n        connectionCount: 5\n      },\n      {\n        id: 'edge2',\n        source: 'node2',\n        target: 'node1',\n        traceId: 'trace-002',\n        connectionCount: 3\n      }\n    ]\n  };\n\n  const mockOnTraceSelect = vi.fn();\n\n  beforeEach(() => {\n    mockOnTraceSelect.mockClear();\n  });\n\n  it('should render trace list with trace IDs', () => {\n    render(\n      <TraceList \n        data={mockData} \n        selectedTraceId={null} \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    expect(screen.getByText('Trace IDs')).toBeInTheDocument();\n    expect(screen.getByText('trace-001')).toBeInTheDocument();\n    expect(screen.getByText('trace-002')).toBeInTheDocument();\n  });\n\n  it('should call onTraceSelect when trace is clicked', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <TraceList \n        data={mockData} \n        selectedTraceId={null} \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    const traceButton = screen.getByText('trace-001').closest('div');\n    if (traceButton) {\n      await user.click(traceButton);\n      expect(mockOnTraceSelect).toHaveBeenCalledWith('trace-001');\n    }\n  });\n\n  it('should highlight selected trace', () => {\n    render(\n      <TraceList \n        data={mockData} \n        selectedTraceId=\"trace-001\" \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    const selectedTrace = screen.getByText('trace-001').closest('div');\n    expect(selectedTrace).toHaveClass('bg-blue-100');\n  });\n\n  it('should deselect trace when clicking selected trace', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <TraceList \n        data={mockData} \n        selectedTraceId=\"trace-001\" \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    const traceButton = screen.getByText('trace-001').closest('div');\n    if (traceButton) {\n      await user.click(traceButton);\n      expect(mockOnTraceSelect).toHaveBeenCalledWith(null);\n    }\n  });\n\n  it('should show connection count for each trace', () => {\n    render(\n      <TraceList \n        data={mockData} \n        selectedTraceId={null} \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    // Should show connection counts in parentheses\n    expect(screen.getByText('(1)')).toBeInTheDocument(); // One connection per trace\n  });\n\n  it('should handle empty data', () => {\n    render(\n      <TraceList \n        data={{ nodes: [], edges: [] }} \n        selectedTraceId={null} \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    expect(screen.getByText('ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ')).toBeInTheDocument();\n  });\n\n  it('should handle null data', () => {\n    render(\n      <TraceList \n        data={null} \n        selectedTraceId={null} \n        onTraceSelect={mockOnTraceSelect} \n      />\n    );\n\n    expect(screen.getByText('ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ')).toBeInTheDocument();\n  });\n});\n\ndescribe('Component Integration', () => {\n  it('should work together in typical usage scenario', () => {\n    const mockData: DiagramData = {\n      nodes: [\n        { id: 'api-service_auth', label: 'auth', service: 'api-service' },\n        { id: 'gateway-service_contact', label: 'contact', service: 'gateway-service' },\n      ],\n      edges: [\n        {\n          id: 'edge1',\n          source: 'api-service_auth',\n          target: 'gateway-service_contact',\n          traceId: 'trace-001',\n          connectionCount: 50,\n          statusCounts: { '200': 45, '404': 3, '500': 2 }\n        }\n      ]\n    };\n\n    const mockStats = {\n      nodeCount: 2,\n      edgeCount: 1,\n      componentCount: 1\n    };\n\n    const mockOnTraceSelect = vi.fn();\n\n    render(\n      <TestWrapper>\n        <div>\n          <Statistics stats={mockStats} data={mockData} />\n          <TraceList \n            data={mockData} \n            selectedTraceId={null} \n            onTraceSelect={mockOnTraceSelect} \n          />\n        </div>\n      </TestWrapper>\n    );\n\n    // Both components should render\n    expect(screen.getByText('Request Statistics')).toBeInTheDocument();\n    expect(screen.getByText('Trace IDs')).toBeInTheDocument();\n    expect(screen.getByText('trace-001')).toBeInTheDocument();\n  });\n});","size_bytes":7085},"client/src/test/diagramUtils.test.ts":{"content":"import { describe, it, expect, beforeEach } from 'vitest';\nimport { applyForceLayout, applyCircularLayout, applyGridLayout, applyHierarchicalLayout } from '@/lib/diagramUtils';\nimport type { DiagramData, DiagramNode, DiagramEdge } from '@/types/diagram';\n\ndescribe('Diagram Utils', () => {\n  let sampleData: DiagramData;\n\n  beforeEach(() => {\n    sampleData = {\n      nodes: [\n        { id: 'node1', label: 'Node 1', service: 'service1' },\n        { id: 'node2', label: 'Node 2', service: 'service1' },\n        { id: 'node3', label: 'Node 3', service: 'service2' },\n        { id: 'node4', label: 'Node 4', service: 'service2' },\n      ],\n      edges: [\n        { id: 'edge1', source: 'node1', target: 'node2', connectionCount: 5 },\n        { id: 'edge2', source: 'node2', target: 'node3', connectionCount: 3 },\n        { id: 'edge3', source: 'node3', target: 'node4', connectionCount: 2 },\n      ]\n    };\n  });\n\n  describe('Force Layout', () => {\n    it('should apply force layout and set positions', () => {\n      const result = applyForceLayout(sampleData, 100);\n      \n      // Check that all nodes have position coordinates\n      result.nodes.forEach(node => {\n        expect(node.x).toBeDefined();\n        expect(node.y).toBeDefined();\n        expect(typeof node.x).toBe('number');\n        expect(typeof node.y).toBe('number');\n      });\n    });\n\n    it('should maintain node spacing based on spacing parameter', () => {\n      const result = applyForceLayout(sampleData, 200);\n      \n      // With higher spacing, nodes should be more spread out\n      const positions = result.nodes.map(node => ({ x: node.x!, y: node.y! }));\n      expect(positions.length).toBe(4);\n    });\n  });\n\n  describe('Circular Layout', () => {\n    it('should arrange nodes in a circle', () => {\n      const result = applyCircularLayout(sampleData, 100);\n      \n      // Check that all nodes have positions\n      result.nodes.forEach(node => {\n        expect(node.x).toBeDefined();\n        expect(node.y).toBeDefined();\n      });\n\n      // Check that nodes are arranged roughly in a circle\n      const centerX = result.nodes.reduce((sum, node) => sum + node.x!, 0) / result.nodes.length;\n      const centerY = result.nodes.reduce((sum, node) => sum + node.y!, 0) / result.nodes.length;\n      \n      // All nodes should be roughly the same distance from center\n      const distances = result.nodes.map(node => \n        Math.sqrt(Math.pow(node.x! - centerX, 2) + Math.pow(node.y! - centerY, 2))\n      );\n      \n      const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;\n      distances.forEach(distance => {\n        expect(Math.abs(distance - avgDistance)).toBeLessThan(50); // Allow some variance\n      });\n    });\n  });\n\n  describe('Grid Layout', () => {\n    it('should arrange nodes in a grid pattern', () => {\n      const result = applyGridLayout(sampleData, 100);\n      \n      // Check that all nodes have positions\n      result.nodes.forEach(node => {\n        expect(node.x).toBeDefined();\n        expect(node.y).toBeDefined();\n      });\n\n      // Check that positions are grid-aligned\n      const uniqueX = [...new Set(result.nodes.map(node => node.x))];\n      const uniqueY = [...new Set(result.nodes.map(node => node.y))];\n      \n      // Should have organized positions\n      expect(uniqueX.length).toBeGreaterThan(0);\n      expect(uniqueY.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Hierarchical Layout', () => {\n    it('should arrange nodes in hierarchical levels', () => {\n      const result = applyHierarchicalLayout(sampleData, 100);\n      \n      // Check that all nodes have positions\n      result.nodes.forEach(node => {\n        expect(node.x).toBeDefined();\n        expect(node.y).toBeDefined();\n      });\n\n      // Y positions should form distinct levels\n      const yPositions = result.nodes.map(node => node.y!);\n      const uniqueY = [...new Set(yPositions)].sort((a, b) => a - b);\n      \n      // Should have hierarchical structure (multiple Y levels)\n      expect(uniqueY.length).toBeGreaterThan(1);\n    });\n  });\n\n  describe('Layout Input Validation', () => {\n    it('should handle empty data gracefully', () => {\n      const emptyData: DiagramData = { nodes: [], edges: [] };\n      \n      expect(() => applyForceLayout(emptyData, 100)).not.toThrow();\n      expect(() => applyCircularLayout(emptyData, 100)).not.toThrow();\n      expect(() => applyGridLayout(emptyData, 100)).not.toThrow();\n      expect(() => applyHierarchicalLayout(emptyData, 100)).not.toThrow();\n    });\n\n    it('should handle single node', () => {\n      const singleNodeData: DiagramData = {\n        nodes: [{ id: 'node1', label: 'Single Node', service: 'service1' }],\n        edges: []\n      };\n\n      const result = applyForceLayout(singleNodeData, 100);\n      expect(result.nodes[0].x).toBeDefined();\n      expect(result.nodes[0].y).toBeDefined();\n    });\n  });\n});","size_bytes":4879},"client/src/test/eventProcessor.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport { processNetworkEvents, mergeEventData } from '@/lib/eventProcessor';\nimport type { ParsedFileData } from '@/types/diagram';\n\ndescribe('Event Processor', () => {\n  const mockNetworkEvents = [\n    {\n      id: 1,\n      source: 'api-service1_auth',\n      target: 'gateway-service1_contact',\n      sourceService: 'api-service1',\n      targetService: 'gateway-service1',\n      sourceLabel: 'auth',\n      targetLabel: 'contact',\n      status: '200',\n      method: 'POST',\n      responseTime: 150,\n      timestamp: '2025-01-06T12:00:00Z',\n      traceId: 'trace-001',\n      metadata: {}\n    },\n    {\n      id: 2,\n      source: 'gateway-service1_contact',\n      target: 'platform-service2_auth',\n      sourceService: 'gateway-service1',\n      targetService: 'platform-service2',\n      sourceLabel: 'contact',\n      targetLabel: 'auth',\n      status: '200',\n      method: 'GET',\n      responseTime: 75,\n      timestamp: '2025-01-06T12:00:01Z',\n      traceId: 'trace-001',\n      metadata: {}\n    },\n    {\n      id: 3,\n      source: 'api-service1_auth',\n      target: 'gateway-service1_contact',\n      sourceService: 'api-service1',\n      targetService: 'gateway-service1',\n      sourceLabel: 'auth',\n      targetLabel: 'contact',\n      status: '404',\n      method: 'POST',\n      responseTime: 200,\n      timestamp: '2025-01-06T12:00:02Z',\n      traceId: 'trace-002',\n      metadata: {}\n    }\n  ];\n\n  describe('processNetworkEvents', () => {\n    it('should process network events into diagram format', () => {\n      const result = processNetworkEvents(mockNetworkEvents);\n\n      expect(result.data.nodes).toHaveLength(4); // 4 unique endpoints\n      expect(result.data.edges).toHaveLength(2); // 2 unique connections\n\n      // Check nodes are created correctly\n      const nodeIds = result.data.nodes.map(node => node.id);\n      expect(nodeIds).toContain('api-service1_auth');\n      expect(nodeIds).toContain('gateway-service1_contact');\n      expect(nodeIds).toContain('platform-service2_auth');\n\n      // Check services are assigned correctly\n      const authNode = result.data.nodes.find(node => node.id === 'api-service1_auth');\n      expect(authNode?.service).toBe('api-service1');\n      expect(authNode?.label).toBe('auth');\n    });\n\n    it('should aggregate connection counts correctly', () => {\n      const result = processNetworkEvents(mockNetworkEvents);\n\n      // Find the edge between api-service1_auth and gateway-service1_contact\n      const edge = result.data.edges.find(edge => \n        edge.source === 'api-service1_auth' && edge.target === 'gateway-service1_contact'\n      );\n      \n      expect(edge?.connectionCount).toBe(2); // Two events for this connection\n    });\n\n    it('should track status codes correctly', () => {\n      const result = processNetworkEvents(mockNetworkEvents);\n\n      const edge = result.data.edges.find(edge => \n        edge.source === 'api-service1_auth' && edge.target === 'gateway-service1_contact'\n      );\n      \n      expect(edge?.statusCounts).toEqual({\n        '200': 1,\n        '404': 1\n      });\n    });\n\n    it('should include trace IDs in edges', () => {\n      const result = processNetworkEvents(mockNetworkEvents);\n\n      const edges = result.data.edges;\n      expect(edges.some(edge => edge.traceId?.includes('trace-001'))).toBe(true);\n      expect(edges.some(edge => edge.traceId?.includes('trace-002'))).toBe(true);\n    });\n\n    it('should calculate statistics correctly', () => {\n      const result = processNetworkEvents(mockNetworkEvents);\n\n      expect(result.stats.nodeCount).toBe(4);\n      expect(result.stats.edgeCount).toBe(2);\n      expect(result.stats.componentCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('mergeEventData', () => {\n    it('should merge existing data with new event data', () => {\n      const existingData: ParsedFileData = {\n        data: {\n          nodes: [\n            { id: 'existing-node', label: 'Existing', service: 'existing-service' }\n          ],\n          edges: [\n            { id: 'existing-edge', source: 'node1', target: 'existing-node', connectionCount: 1 }\n          ]\n        },\n        stats: { nodeCount: 1, edgeCount: 1, componentCount: 1 }\n      };\n\n      const eventData = processNetworkEvents(mockNetworkEvents);\n      const result = mergeEventData(existingData, eventData);\n\n      // Should have nodes from both datasets\n      expect(result.data.nodes.length).toBeGreaterThan(existingData.data.nodes.length);\n      expect(result.data.edges.length).toBeGreaterThan(existingData.data.edges.length);\n\n      // Should preserve existing nodes\n      const existingNode = result.data.nodes.find(node => node.id === 'existing-node');\n      expect(existingNode).toBeDefined();\n    });\n\n    it('should handle null existing data', () => {\n      const eventData = processNetworkEvents(mockNetworkEvents);\n      const result = mergeEventData(null, eventData);\n\n      expect(result).toEqual(eventData);\n    });\n  });\n\n  describe('Edge Cases', () => {\n    it('should handle empty events array', () => {\n      const result = processNetworkEvents([]);\n      \n      expect(result.data.nodes).toHaveLength(0);\n      expect(result.data.edges).toHaveLength(0);\n      expect(result.stats.nodeCount).toBe(0);\n      expect(result.stats.edgeCount).toBe(0);\n    });\n\n    it('should handle malformed events gracefully', () => {\n      const malformedEvents = [\n        {\n          id: 1,\n          source: '',\n          target: '',\n          sourceService: 'service1',\n          targetService: 'service2',\n          sourceLabel: 'label1',\n          targetLabel: 'label2',\n          status: '200',\n          method: 'GET',\n          responseTime: 100,\n          timestamp: '2025-01-06T12:00:00Z',\n          metadata: {}\n        }\n      ];\n\n      expect(() => processNetworkEvents(malformedEvents as any)).not.toThrow();\n    });\n  });\n});","size_bytes":5872},"client/src/test/integration.test.tsx":{"content":"import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport DiagramGenerator from '@/pages/DiagramGenerator';\n\n// Mock file upload API\nvi.mock('@/lib/queryClient', () => ({\n  apiRequest: vi.fn(),\n  queryClient: new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  }),\n}));\n\nconst TestWrapper = ({ children }: { children: React.ReactNode }) => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};\n\ndescribe('DiagramGenerator Integration Tests', () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('should render main application components', () => {\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Check that header is rendered\n    expect(screen.getByText('DiagramFlow')).toBeInTheDocument();\n    expect(screen.getByText('3D Network Visualization')).toBeInTheDocument();\n\n    // Check that sidebar components are rendered\n    expect(screen.getByText('Request Statistics')).toBeInTheDocument();\n    expect(screen.getByText('Trace IDs')).toBeInTheDocument();\n  });\n\n  it('should show empty state when no data is loaded', () => {\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    expect(screen.getByText('No file loaded')).toBeInTheDocument();\n    expect(screen.getByText('ÐÐµÑ‚ trace_id Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…')).toBeInTheDocument();\n  });\n\n  it('should handle trace selection and deselection', async () => {\n    const mockData = {\n      data: {\n        nodes: [\n          { id: 'node1', label: 'Service 1', service: 'service1' },\n          { id: 'node2', label: 'Service 2', service: 'service2' },\n        ],\n        edges: [\n          {\n            id: 'edge1',\n            source: 'node1',\n            target: 'node2',\n            traceId: 'trace-001',\n            connectionCount: 5,\n            statusCounts: { '200': 4, '404': 1 }\n          }\n        ]\n      },\n      stats: { nodeCount: 2, edgeCount: 1, componentCount: 1 }\n    };\n\n    // Mock the initial state with data\n    const DiagramGeneratorWithData = () => {\n      const [data, setData] = useState(mockData);\n      const [selectedTraceId, setSelectedTraceId] = useState<string | null>(null);\n      \n      return (\n        <div>\n          <Statistics stats={data.stats} data={data.data} />\n          <TraceList \n            data={data.data} \n            selectedTraceId={selectedTraceId} \n            onTraceSelect={setSelectedTraceId} \n          />\n        </div>\n      );\n    };\n\n    render(\n      <TestWrapper>\n        <DiagramGeneratorWithData />\n      </TestWrapper>\n    );\n\n    // Should show trace list with trace ID\n    expect(screen.getByText('trace-001')).toBeInTheDocument();\n\n    // Click on trace to select it\n    const traceElement = screen.getByText('trace-001').closest('div');\n    if (traceElement) {\n      await userEvent.click(traceElement);\n      \n      // Check that trace becomes selected (highlighted)\n      await waitFor(() => {\n        expect(traceElement).toHaveClass('bg-blue-100');\n      });\n    }\n  });\n\n  it('should display correct statistics for network data', () => {\n    const mockData = {\n      data: {\n        nodes: [\n          { id: 'api-service_auth', label: 'auth', service: 'api-service' },\n          { id: 'gateway-service_contact', label: 'contact', service: 'gateway-service' },\n        ],\n        edges: [\n          {\n            id: 'edge1',\n            source: 'api-service_auth',\n            target: 'gateway-service_contact',\n            connectionCount: 100,\n            statusCounts: { '200': 85, '404': 10, '500': 5 }\n          }\n        ]\n      },\n      stats: { nodeCount: 2, edgeCount: 1, componentCount: 1 }\n    };\n\n    const StatisticsTest = () => (\n      <Statistics stats={mockData.stats} data={mockData.data} />\n    );\n\n    render(\n      <TestWrapper>\n        <StatisticsTest />\n      </TestWrapper>\n    );\n\n    // Should show success rate (85%)\n    expect(screen.getByText(/85%/)).toBeInTheDocument();\n    \n    // Should show total requests\n    expect(screen.getByText('100')).toBeInTheDocument();\n  });\n\n  it('should handle layout changes', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Look for any layout controls if they exist\n    // Since layout controls are currently hidden, this test verifies they don't interfere\n    expect(screen.queryByText('Layout')).not.toBeInTheDocument();\n  });\n\n  it('should handle export functionality', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Find and click export button\n    const exportButton = screen.getByText('Export');\n    expect(exportButton).toBeInTheDocument();\n    \n    await user.click(exportButton);\n    \n    // Should show export message (since actual export is handled by canvas)\n    await waitFor(() => {\n      expect(screen.getByText(/export options/i)).toBeInTheDocument();\n    });\n  });\n\n  it('should show help panel when help button is clicked', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Find help button (circle with question mark)\n    const helpButton = screen.getByRole('button', { name: /help/i });\n    expect(helpButton).toBeInTheDocument();\n    \n    await user.click(helpButton);\n    \n    // Help panel should open\n    await waitFor(() => {\n      expect(screen.getByText(/help/i)).toBeInTheDocument();\n    });\n  });\n\n  it('should handle real-time controls', () => {\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Real-time header should be present\n    expect(screen.getByText(/real.*time/i) || screen.getByText(/time.*range/i)).toBeInTheDocument();\n  });\n\n  it('should maintain responsive design', () => {\n    // Test mobile viewport\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: 375,\n    });\n    \n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Should still render main components on mobile\n    expect(screen.getByText('DiagramFlow')).toBeInTheDocument();\n    expect(screen.getByText('Request Statistics')).toBeInTheDocument();\n  });\n});\n\ndescribe('3D Visualization Tests', () => {\n  it('should switch to 3D mode correctly', () => {\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // 3D mode should be default for real-time data\n    // Canvas container should be present\n    const canvasContainer = document.querySelector('[data-testid=\"3d-canvas\"]') || \n                           document.querySelector('canvas') ||\n                           document.querySelector('#diagram-canvas');\n    \n    // Canvas might not render in test environment, but container should exist\n    expect(document.body).toBeInTheDocument();\n  });\n});\n\ndescribe('Data Processing Tests', () => {\n  it('should handle empty file upload gracefully', async () => {\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // File upload components should be present but not throw errors with empty data\n    expect(screen.getByText('No file loaded')).toBeInTheDocument();\n  });\n\n  it('should merge real-time and file data correctly', () => {\n    // This would test the useMemo logic in DiagramGenerator\n    // The component should handle both file data and real-time data\n    render(\n      <TestWrapper>\n        <DiagramGenerator />\n      </TestWrapper>\n    );\n\n    // Should show proper empty state\n    expect(screen.getByText('ÐÐµÑ‚ trace_id Ð² Ð´Ð°Ð½Ð½Ñ‹Ñ…')).toBeInTheDocument();\n  });\n});","size_bytes":8202},"client/src/test/setup.ts":{"content":"import '@testing-library/jest-dom';\nimport { expect, afterEach } from 'vitest';\nimport { cleanup } from '@testing-library/react';\n\n// Cleanup after each test\nafterEach(() => {\n  cleanup();\n});\n\n// Mock Three.js to prevent WebGL errors in tests\nvi.mock('three', () => ({\n  Scene: vi.fn(() => ({\n    add: vi.fn(),\n    remove: vi.fn(),\n    traverse: vi.fn(),\n    clear: vi.fn(),\n    children: [],\n  })),\n  WebGLRenderer: vi.fn(() => ({\n    setSize: vi.fn(),\n    render: vi.fn(),\n    domElement: document.createElement('canvas'),\n    dispose: vi.fn(),\n    setPixelRatio: vi.fn(),\n    shadowMap: {\n      enabled: false,\n      type: ''\n    }\n  })),\n  PerspectiveCamera: vi.fn(() => ({\n    position: { set: vi.fn() },\n    lookAt: vi.fn(),\n    updateProjectionMatrix: vi.fn(),\n  })),\n  Vector3: vi.fn(() => ({\n    set: vi.fn(),\n    copy: vi.fn(),\n    add: vi.fn(),\n    sub: vi.fn(),\n    multiplyScalar: vi.fn(),\n    normalize: vi.fn(),\n    dot: vi.fn(),\n    cross: vi.fn(),\n    distanceTo: vi.fn(() => 1),\n    clone: vi.fn(),\n    subVectors: vi.fn(),\n    x: 0,\n    y: 0,\n    z: 0,\n  })),\n  Mesh: vi.fn(),\n  MeshLambertMaterial: vi.fn(),\n  CylinderGeometry: vi.fn(),\n  SpriteMaterial: vi.fn(),\n  Sprite: vi.fn(),\n  CanvasTexture: vi.fn(),\n  DirectionalLight: vi.fn(),\n  AmbientLight: vi.fn(),\n  OrbitControls: vi.fn(),\n  Group: vi.fn(),\n  Line: vi.fn(),\n  LineBasicMaterial: vi.fn(),\n  BufferGeometry: vi.fn(),\n  Float32BufferAttribute: vi.fn(),\n  ConeGeometry: vi.fn(),\n  MeshBasicMaterial: vi.fn(),\n  PCFSoftShadowMap: 'PCFSoftShadowMap',\n}));\n\n// Mock browser APIs\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\n// Mock ResizeObserver\nglobal.ResizeObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n}));\n\n// Mock URL.createObjectURL\nObject.defineProperty(URL, 'createObjectURL', {\n  writable: true,\n  value: vi.fn(() => 'blob:mock-url'),\n});","size_bytes":2179},"client/src/test/utils.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport { cn } from '@/lib/utils';\n\ndescribe('Utils', () => {\n  describe('cn (className utility)', () => {\n    it('should merge class names correctly', () => {\n      const result = cn('bg-red-500', 'text-white');\n      expect(result).toContain('bg-red-500');\n      expect(result).toContain('text-white');\n    });\n\n    it('should handle conditional classes', () => {\n      const result = cn('base-class', true && 'conditional-class', false && 'hidden-class');\n      expect(result).toContain('base-class');\n      expect(result).toContain('conditional-class');\n      expect(result).not.toContain('hidden-class');\n    });\n\n    it('should handle undefined and null values', () => {\n      const result = cn('base-class', undefined, null, 'other-class');\n      expect(result).toContain('base-class');\n      expect(result).toContain('other-class');\n    });\n  });\n});","size_bytes":904},"client/src/types/diagram.ts":{"content":"export interface DiagramNode {\n  id: string;\n  label: string;\n  type: string;\n  x: number;\n  y: number;\n  z?: number;\n  service?: string;\n  tenant?: string;\n  system?: string;\n  radius?: number;\n  color?: string;\n  count?: number;\n  isService?: boolean;\n  metadata?: any;\n  traceId?: string;\n  nodeType?: string;\n  endpoints?: Set<any>;\n}\n\nexport interface DiagramEdge {\n  id: string;\n  source: string;\n  target: string;\n  label?: string;\n  weight?: number;\n  color?: string;\n  status?: string;\n  method?: string;\n  responseTime?: number;\n  count?: number;\n  isDirectional?: boolean;\n  metadata?: any;\n  traceId?: string;\n  connectionCount?: number;\n  statusCounts?: Record<string, number>;\n  latency?: number;\n  trafficType?: string;\n}\n\nexport interface DiagramData {\n  nodes: DiagramNode[];\n  edges: DiagramEdge[];\n}\n\nexport interface DiagramStats {\n  nodeCount: number;\n  edgeCount: number;\n  totalConnections: number;\n  connectedComponents: number;\n  services?: string[];\n  endpoints?: string[];\n  componentCount?: number;\n}\n\nexport interface DiagramSettings {\n  nodeSpacing: number;\n  clusterSpacing: number;\n  clusterSpacingY: number;\n  showLabels: boolean;\n  showArrows: boolean;\n  nodeColor: string;\n  edgeColor: string;\n  backgroundColor: string;\n  showLegend: boolean;\n  brightness?: number;\n}\n\nexport interface ParsedFileData {\n  data: DiagramData;\n  stats: DiagramStats;\n  filename?: string;\n}\n\nexport type LayoutType = \n  | \"force\" \n  | \"hierarchical\" \n  | \"circular\" \n  | \"grid\" \n  | \"service-grouped\" \n  | \"3d-network\";\n\nexport interface TraceInfo {\n  traceId: string;\n  serviceName: string;\n  operationName: string;\n  startTime: string;\n  duration: number;\n  status: string;\n  spanCount: number;\n}","size_bytes":1713},"k8s/overlays/local/app-patch.yaml":{"content":"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: diagram-generator-app\nspec:\n  replicas: 1\n  template:\n    spec:\n      containers:\n      - name: app\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"200m\"\n        env:\n        - name: NODE_ENV\n          value: \"development\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: diagram-generator-service\nspec:\n  type: NodePort\n  ports:\n  - port: 80\n    targetPort: 5000\n    nodePort: 30080\n    protocol: TCP","size_bytes":565},"k8s/overlays/local/kustomization.yaml":{"content":"apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nmetadata:\n  name: diagram-generator-local\n\nbases:\n- ../../base\n\npatchesStrategicMerge:\n- app-patch.yaml\n- postgres-patch.yaml\n\nnamePrefix: local-\n\ncommonLabels:\n  environment: local\n  \nimages:\n- name: diagram-generator\n  newName: localhost:5000/diagram-generator\n  newTag: latest\n\nreplicas:\n- name: diagram-generator-app\n  count: 1\n- name: postgres-deployment\n  count: 1","size_bytes":435},"k8s/overlays/local/postgres-patch.yaml":{"content":"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: postgres-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: postgres\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: postgres-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 500Mi\n  storageClassName: local-path","size_bytes":502},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","size_bytes":1977},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","size_bytes":4420},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","size_bytes":1584},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","size_bytes":140},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","size_bytes":1419},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground hover:bg-primary/80\",\n        secondary:\n          \"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80\",\n        outline: \"text-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","size_bytes":1128},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","size_bytes":2712},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\n        destructive:\n          \"bg-destructive text-destructive-foreground hover:bg-destructive/90\",\n        outline:\n          \"border border-input bg-background hover:bg-accent hover:text-accent-foreground\",\n        secondary:\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\n        ghost: \"hover:bg-accent hover:text-accent-foreground\",\n        link: \"text-primary underline-offset-4 hover:underline\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","size_bytes":1901},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","size_bytes":2695},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"rounded-lg border bg-card text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n))\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\n\nexport { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }\n","size_bytes":1858},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","size_bytes":6210},"client/src/components/ui/chart.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","size_bytes":10481},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","size_bytes":1056},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","size_bytes":329},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","size_bytes":4885},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","size_bytes":7428},"client/src/components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","size_bytes":3848},"client/src/components/ui/drawer.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","size_bytes":3021},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","size_bytes":7609},"client/src/components/ui/form.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","size_bytes":4120},"client/src/components/ui/hover-card.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","size_bytes":1251},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","size_bytes":2154},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","size_bytes":791},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","size_bytes":710},"client/src/components/ui/menubar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","size_bytes":8605},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","size_bytes":5128},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","size_bytes":2751},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","size_bytes":1280},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","size_bytes":791},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","size_bytes":1467},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","size_bytes":1723},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }","size_bytes":1641},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","size_bytes":5742},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","size_bytes":756},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","size_bytes":4281},"client/src/components/ui/sidebar.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { VariantProps, cva } from \"class-variance-authority\"\nimport { PanelLeft } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContextProps = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nconst SidebarProvider = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    defaultOpen?: boolean\n    open?: boolean\n    onOpenChange?: (open: boolean) => void\n  }\n>(\n  (\n    {\n      defaultOpen = true,\n      open: openProp,\n      onOpenChange: setOpenProp,\n      className,\n      style,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const isMobile = useIsMobile()\n    const [openMobile, setOpenMobile] = React.useState(false)\n\n    // This is the internal state of the sidebar.\n    // We use openProp and setOpenProp for control from outside the component.\n    const [_open, _setOpen] = React.useState(defaultOpen)\n    const open = openProp ?? _open\n    const setOpen = React.useCallback(\n      (value: boolean | ((value: boolean) => boolean)) => {\n        const openState = typeof value === \"function\" ? value(open) : value\n        if (setOpenProp) {\n          setOpenProp(openState)\n        } else {\n          _setOpen(openState)\n        }\n\n        // This sets the cookie to keep the sidebar state.\n        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n      },\n      [setOpenProp, open]\n    )\n\n    // Helper to toggle the sidebar.\n    const toggleSidebar = React.useCallback(() => {\n      return isMobile\n        ? setOpenMobile((open) => !open)\n        : setOpen((open) => !open)\n    }, [isMobile, setOpen, setOpenMobile])\n\n    // Adds a keyboard shortcut to toggle the sidebar.\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (\n          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n          (event.metaKey || event.ctrlKey)\n        ) {\n          event.preventDefault()\n          toggleSidebar()\n        }\n      }\n\n      window.addEventListener(\"keydown\", handleKeyDown)\n      return () => window.removeEventListener(\"keydown\", handleKeyDown)\n    }, [toggleSidebar])\n\n    // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n    // This makes it easier to style the sidebar with Tailwind classes.\n    const state = open ? \"expanded\" : \"collapsed\"\n\n    const contextValue = React.useMemo<SidebarContextProps>(\n      () => ({\n        state,\n        open,\n        setOpen,\n        isMobile,\n        openMobile,\n        setOpenMobile,\n        toggleSidebar,\n      }),\n      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n    )\n\n    return (\n      <SidebarContext.Provider value={contextValue}>\n        <TooltipProvider delayDuration={0}>\n          <div\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH,\n                \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n                ...style,\n              } as React.CSSProperties\n            }\n            className={cn(\n              \"group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar\",\n              className\n            )}\n            ref={ref}\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </SidebarContext.Provider>\n    )\n  }\n)\nSidebarProvider.displayName = \"SidebarProvider\"\n\nconst Sidebar = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    side?: \"left\" | \"right\"\n    variant?: \"sidebar\" | \"floating\" | \"inset\"\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n  }\n>(\n  (\n    {\n      side = \"left\",\n      variant = \"sidebar\",\n      collapsible = \"offcanvas\",\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n    if (collapsible === \"none\") {\n      return (\n        <div\n          className={cn(\n            \"flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground\",\n            className\n          )}\n          ref={ref}\n          {...props}\n        >\n          {children}\n        </div>\n      )\n    }\n\n    if (isMobile) {\n      return (\n        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n          <SheetContent\n            data-sidebar=\"sidebar\"\n            data-mobile=\"true\"\n            className=\"w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden\"\n            style={\n              {\n                \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n              } as React.CSSProperties\n            }\n            side={side}\n          >\n            <SheetHeader className=\"sr-only\">\n              <SheetTitle>Sidebar</SheetTitle>\n              <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n            </SheetHeader>\n            <div className=\"flex h-full w-full flex-col\">{children}</div>\n          </SheetContent>\n        </Sheet>\n      )\n    }\n\n    return (\n      <div\n        ref={ref}\n        className=\"group peer hidden text-sidebar-foreground md:block\"\n        data-state={state}\n        data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n        data-variant={variant}\n        data-side={side}\n      >\n        {/* This is what handles the sidebar gap on desktop */}\n        <div\n          className={cn(\n            \"relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear\",\n            \"group-data-[collapsible=offcanvas]:w-0\",\n            \"group-data-[side=right]:rotate-180\",\n            variant === \"floating\" || variant === \"inset\"\n              ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon]\"\n          )}\n        />\n        <div\n          className={cn(\n            \"fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex\",\n            side === \"left\"\n              ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n              : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n            // Adjust the padding for floating and inset variants.\n            variant === \"floating\" || variant === \"inset\"\n              ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]\"\n              : \"group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n            className\n          )}\n          {...props}\n        >\n          <div\n            data-sidebar=\"sidebar\"\n            className=\"flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow\"\n          >\n            {children}\n          </div>\n        </div>\n      </div>\n    )\n  }\n)\nSidebar.displayName = \"Sidebar\"\n\nconst SidebarTrigger = React.forwardRef<\n  React.ElementRef<typeof Button>,\n  React.ComponentProps<typeof Button>\n>(({ className, onClick, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      ref={ref}\n      data-sidebar=\"trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeft />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n})\nSidebarTrigger.displayName = \"SidebarTrigger\"\n\nconst SidebarRail = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\">\n>(({ className, ...props }, ref) => {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <button\n      ref={ref}\n      data-sidebar=\"rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex\",\n        \"[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarRail.displayName = \"SidebarRail\"\n\nconst SidebarInset = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"main\">\n>(({ className, ...props }, ref) => {\n  return (\n    <main\n      ref={ref}\n      className={cn(\n        \"relative flex w-full flex-1 flex-col bg-background\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInset.displayName = \"SidebarInset\"\n\nconst SidebarInput = React.forwardRef<\n  React.ElementRef<typeof Input>,\n  React.ComponentProps<typeof Input>\n>(({ className, ...props }, ref) => {\n  return (\n    <Input\n      ref={ref}\n      data-sidebar=\"input\"\n      className={cn(\n        \"h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarInput.displayName = \"SidebarInput\"\n\nconst SidebarHeader = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarHeader.displayName = \"SidebarHeader\"\n\nconst SidebarFooter = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarFooter.displayName = \"SidebarFooter\"\n\nconst SidebarSeparator = React.forwardRef<\n  React.ElementRef<typeof Separator>,\n  React.ComponentProps<typeof Separator>\n>(({ className, ...props }, ref) => {\n  return (\n    <Separator\n      ref={ref}\n      data-sidebar=\"separator\"\n      className={cn(\"mx-2 w-auto bg-sidebar-border\", className)}\n      {...props}\n    />\n  )\n})\nSidebarSeparator.displayName = \"SidebarSeparator\"\n\nconst SidebarContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarContent.displayName = \"SidebarContent\"\n\nconst SidebarGroup = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n})\nSidebarGroup.displayName = \"SidebarGroup\"\n\nconst SidebarGroupLabel = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupLabel.displayName = \"SidebarGroupLabel\"\n\nconst SidebarGroupAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & { asChild?: boolean }\n>(({ className, asChild = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarGroupAction.displayName = \"SidebarGroupAction\"\n\nconst SidebarGroupContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"group-content\"\n    className={cn(\"w-full text-sm\", className)}\n    {...props}\n  />\n))\nSidebarGroupContent.displayName = \"SidebarGroupContent\"\n\nconst SidebarMenu = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu\"\n    className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n    {...props}\n  />\n))\nSidebarMenu.displayName = \"SidebarMenu\"\n\nconst SidebarMenuItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    data-sidebar=\"menu-item\"\n    className={cn(\"group/menu-item relative\", className)}\n    {...props}\n  />\n))\nSidebarMenuItem.displayName = \"SidebarMenuItem\"\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:!p-0\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst SidebarMenuButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    isActive?: boolean\n    tooltip?: string | React.ComponentProps<typeof TooltipContent>\n  } & VariantProps<typeof sidebarMenuButtonVariants>\n>(\n  (\n    {\n      asChild = false,\n      isActive = false,\n      variant = \"default\",\n      size = \"default\",\n      tooltip,\n      className,\n      ...props\n    },\n    ref\n  ) => {\n    const Comp = asChild ? Slot : \"button\"\n    const { isMobile, state } = useSidebar()\n\n    const button = (\n      <Comp\n        ref={ref}\n        data-sidebar=\"menu-button\"\n        data-size={size}\n        data-active={isActive}\n        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n        {...props}\n      />\n    )\n\n    if (!tooltip) {\n      return button\n    }\n\n    if (typeof tooltip === \"string\") {\n      tooltip = {\n        children: tooltip,\n      }\n    }\n\n    return (\n      <Tooltip>\n        <TooltipTrigger asChild>{button}</TooltipTrigger>\n        <TooltipContent\n          side=\"right\"\n          align=\"center\"\n          hidden={state !== \"collapsed\" || isMobile}\n          {...tooltip}\n        />\n      </Tooltip>\n    )\n  }\n)\nSidebarMenuButton.displayName = \"SidebarMenuButton\"\n\nconst SidebarMenuAction = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<\"button\"> & {\n    asChild?: boolean\n    showOnHover?: boolean\n  }\n>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 after:md:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuAction.displayName = \"SidebarMenuAction\"\n\nconst SidebarMenuBadge = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    data-sidebar=\"menu-badge\"\n    className={cn(\n      \"pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground\",\n      \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n      \"peer-data-[size=sm]/menu-button:top-1\",\n      \"peer-data-[size=default]/menu-button:top-1.5\",\n      \"peer-data-[size=lg]/menu-button:top-2.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuBadge.displayName = \"SidebarMenuBadge\"\n\nconst SidebarMenuSkeleton = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    showIcon?: boolean\n  }\n>(({ className, showIcon = false, ...props }, ref) => {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      ref={ref}\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[--skeleton-width] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n})\nSidebarMenuSkeleton.displayName = \"SidebarMenuSkeleton\"\n\nconst SidebarMenuSub = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    data-sidebar=\"menu-sub\"\n    className={cn(\n      \"mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5\",\n      \"group-data-[collapsible=icon]:hidden\",\n      className\n    )}\n    {...props}\n  />\n))\nSidebarMenuSub.displayName = \"SidebarMenuSub\"\n\nconst SidebarMenuSubItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ ...props }, ref) => <li ref={ref} {...props} />)\nSidebarMenuSubItem.displayName = \"SidebarMenuSubItem\"\n\nconst SidebarMenuSubButton = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentProps<\"a\"> & {\n    asChild?: boolean\n    size?: \"sm\" | \"md\"\n    isActive?: boolean\n  }\n>(({ asChild = false, size = \"md\", isActive, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nSidebarMenuSubButton.displayName = \"SidebarMenuSubButton\"\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","size_bytes":23567},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","size_bytes":261},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","size_bytes":1077},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","size_bytes":1139},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","size_bytes":2765},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","size_bytes":1883},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","size_bytes":689},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","size_bytes":4845},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","size_bytes":772},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","size_bytes":1753},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3 min-w-10\",\n        sm: \"h-9 px-2.5 min-w-9\",\n        lg: \"h-11 px-5 min-w-11\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","size_bytes":1527},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","size_bytes":1209},"client/src/components/__tests__/3DObjectSystem.test.tsx":{"content":"import { describe, it, expect, vi, beforeEach } from 'vitest'\nimport * as THREE from 'three'\n\n// Mock Three.js for object system tests\nvi.mock('three', () => ({\n  Scene: vi.fn(() => ({\n    add: vi.fn(),\n    remove: vi.fn(),\n    traverse: vi.fn((callback) => {\n      // Mock traverse to call callback on test objects\n      const mockObjects = [\n        { userData: { isTenantSphere: true, tenantName: 'test-tenant' } },\n        { userData: { nodeId: 'test-node', isEndpoint: true } },\n        { userData: { isArrow: true, edgeData: { traceId: 'test-trace' } } }\n      ]\n      mockObjects.forEach(callback)\n    })\n  })),\n  Mesh: vi.fn(() => ({\n    position: { set: vi.fn(), x: 0, y: 0, z: 0 },\n    userData: {},\n    material: {\n      color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n      transparent: false,\n      opacity: 1,\n      needsUpdate: false\n    }\n  })),\n  CylinderGeometry: vi.fn(),\n  SphereGeometry: vi.fn(),\n  MeshBasicMaterial: vi.fn(() => ({\n    color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n    transparent: false,\n    opacity: 1,\n    needsUpdate: false\n  })),\n  Line: vi.fn(() => ({\n    material: {\n      color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n      transparent: false,\n      opacity: 1,\n      needsUpdate: false\n    },\n    userData: {}\n  })),\n  Vector3: vi.fn(() => ({ x: 0, y: 0, z: 0 }))\n}))\n\ndescribe('3D Object Highlighting System', () => {\n  let mockScene: any\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockScene = new THREE.Scene()\n  })\n\n  it('should highlight tenant spheres correctly', () => {\n    const tenantSphere = new THREE.Mesh()\n    tenantSphere.userData = {\n      isTenantSphere: true,\n      tenantName: 'api-gateway',\n      lodLevel: 'low'\n    }\n\n    // Test highlighting logic\n    const isRelatedToTrace = true\n    const expectedOpacity = isRelatedToTrace ? 0.8 : 0.1\n\n    // Simulate highlighting\n    tenantSphere.material.transparent = true\n    tenantSphere.material.opacity = expectedOpacity\n\n    expect(tenantSphere.material.opacity).toBe(expectedOpacity)\n    expect(tenantSphere.material.transparent).toBe(true)\n  })\n\n  it('should highlight service cylinders correctly', () => {\n    const cylinder = new THREE.Mesh()\n    cylinder.userData = {\n      nodeId: 'test-service',\n      isEndpoint: true,\n      tenant: 'api-gateway'\n    }\n\n    // Test cylinder highlighting\n    const originalColor = 0x00ff00\n    cylinder.userData.originalColor = originalColor\n\n    // Simulate highlighting\n    cylinder.material.color.setHex(originalColor)\n    cylinder.material.transparent = false\n    cylinder.material.opacity = 1.0\n\n    expect(cylinder.material.color.setHex).toHaveBeenCalledWith(originalColor)\n    expect(cylinder.material.opacity).toBe(1.0)\n  })\n\n  it('should highlight arrows correctly', () => {\n    const arrow = new THREE.Line()\n    arrow.userData = {\n      isArrow: true,\n      edgeData: { traceId: 'test-trace-123' }\n    }\n\n    const originalColor = 0x0000ff\n    arrow.userData.originalColor = originalColor\n\n    // Test arrow highlighting\n    arrow.material.color.setHex(originalColor)\n    arrow.material.transparent = false\n    arrow.material.opacity = 1.0\n\n    expect(arrow.material.color.setHex).toHaveBeenCalledWith(originalColor)\n    expect(arrow.material.opacity).toBe(1.0)\n  })\n})\n\ndescribe('LOD System', () => {\n  it('should calculate correct LOD levels', () => {\n    const serviceCount = 57\n    const relativeDistance = 0.79\n\n    // Current LOD thresholds\n    const LOD_THRESHOLDS = {\n      HIGH_THRESHOLD: 0.20,\n      MEDIUM_THRESHOLD: 0.40\n    }\n\n    let lodLevel: 'high' | 'medium' | 'low'\n    \n    if (serviceCount < 20 && relativeDistance < LOD_THRESHOLDS.HIGH_THRESHOLD) {\n      lodLevel = 'high'\n    } else if (serviceCount < 50 && relativeDistance < LOD_THRESHOLDS.MEDIUM_THRESHOLD) {\n      lodLevel = 'medium'\n    } else {\n      lodLevel = 'low'\n    }\n\n    expect(lodLevel).toBe('low')\n  })\n\n  it('should handle LOD transitions correctly', () => {\n    const testCases = [\n      { services: 10, distance: 0.1, expected: 'high' },\n      { services: 30, distance: 0.3, expected: 'medium' },\n      { services: 60, distance: 0.8, expected: 'low' }\n    ]\n\n    testCases.forEach(({ services, distance, expected }) => {\n      let lodLevel: 'high' | 'medium' | 'low'\n      \n      if (services < 20 && distance < 0.20) {\n        lodLevel = 'high'\n      } else if (services < 50 && distance < 0.40) {\n        lodLevel = 'medium'\n      } else {\n        lodLevel = 'low'\n      }\n\n      expect(lodLevel).toBe(expected)\n    })\n  })\n})\n\ndescribe('Trace Filtering System', () => {\n  it('should filter traces correctly', () => {\n    const edges = [\n      { \n        source: 'node1', \n        target: 'node2', \n        traceId: 'trace-123,trace-456',\n        statusCodes: { '200': 5 }\n      },\n      { \n        source: 'node2', \n        target: 'node3', \n        traceId: 'trace-789',\n        statusCodes: { '500': 2 }\n      }\n    ]\n\n    const selectedTraceId = 'trace-123'\n    \n    const matchingEdges = edges.filter(edge => {\n      if (!edge.traceId) return false\n      const traceIds = edge.traceId.split(',').map(id => id.trim())\n      return traceIds.includes(selectedTraceId)\n    })\n\n    expect(matchingEdges).toHaveLength(1)\n    expect(matchingEdges[0].source).toBe('node1')\n  })\n\n  it('should handle magistral trace filtering', () => {\n    const magistralKey = 'api-gateway->user-management'\n    const [sourceTenant, targetTenant] = magistralKey.split('->')\n\n    expect(sourceTenant).toBe('api-gateway')\n    expect(targetTenant).toBe('user-management')\n\n    // Test magistral highlighting logic\n    const sourceNode = { tenant: 'api-gateway' }\n    const targetNode = { tenant: 'user-management' }\n    \n    const crossesDirectly = (sourceNode.tenant === sourceTenant && targetNode.tenant === targetTenant)\n    const crossesReverse = (sourceNode.tenant === targetTenant && targetNode.tenant === sourceTenant)\n    \n    expect(crossesDirectly).toBe(true)\n    expect(crossesReverse).toBe(false)\n  })\n})\n\ndescribe('Scene Object Management', () => {\n  it('should preserve essential objects during scene clearing', () => {\n    const scene = new THREE.Scene()\n    const preservedObjects = ['lights', 'axes', 'tenantSpheres']\n    \n    // Mock objects that should be preserved\n    const mockObjects = [\n      { userData: { isLight: true } },\n      { userData: { isAxis: true } },\n      { userData: { isTenantSphere: true } },\n      { userData: { isEndpoint: true } } // This should be removable\n    ]\n\n    // Test preservation logic\n    const shouldPreserve = (obj: any) => {\n      return obj.userData?.isLight || \n             obj.userData?.isAxis || \n             obj.userData?.isTenantSphere\n    }\n\n    const preserved = mockObjects.filter(shouldPreserve)\n    expect(preserved).toHaveLength(3)\n  })\n})\n\ndescribe('Position Calculation System', () => {\n  it('should calculate tenant positions correctly', () => {\n    const tenants = ['api-gateway', 'user-management', 'payment-system']\n    const clusterSpacing = 600\n    \n    // Test circular positioning\n    tenants.forEach((tenant, index) => {\n      const angle = (index / tenants.length) * 2 * Math.PI\n      const x = Math.cos(angle) * clusterSpacing\n      const z = Math.sin(angle) * clusterSpacing\n      \n      expect(typeof x).toBe('number')\n      expect(typeof z).toBe('number')\n      expect(isFinite(x)).toBe(true)\n      expect(isFinite(z)).toBe(true)\n    })\n  })\n\n  it('should calculate service positions within tenants', () => {\n    const services = ['service1', 'service2', 'service3']\n    const nodeSpacing = 120\n    const tenantCenter = { x: 300, z: 400 }\n    \n    services.forEach((service, index) => {\n      const angle = (index / services.length) * 2 * Math.PI\n      const x = tenantCenter.x + Math.cos(angle) * nodeSpacing\n      const z = tenantCenter.z + Math.sin(angle) * nodeSpacing\n      \n      expect(typeof x).toBe('number')\n      expect(typeof z).toBe('number')\n      expect(Math.abs(x - tenantCenter.x)).toBeLessThanOrEqual(nodeSpacing)\n      expect(Math.abs(z - tenantCenter.z)).toBeLessThanOrEqual(nodeSpacing)\n    })\n  })\n})","size_bytes":8092},"client/src/components/__tests__/Diagram3D.test.tsx":{"content":"import { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { render, screen } from '@testing-library/react'\nimport * as THREE from 'three'\nimport Diagram3D from '../Diagram3D'\nimport type { DiagramData, DiagramSettings } from '@shared/schema'\n\n// Mock Three.js modules\nvi.mock('three', () => ({\n  Scene: vi.fn(() => ({\n    add: vi.fn(),\n    remove: vi.fn(),\n    traverse: vi.fn(),\n    clear: vi.fn()\n  })),\n  WebGLRenderer: vi.fn(() => ({\n    setSize: vi.fn(),\n    render: vi.fn(),\n    domElement: document.createElement('canvas'),\n    setPixelRatio: vi.fn(),\n    shadowMap: { enabled: false, type: null },\n    toneMappingExposure: 1,\n    dispose: vi.fn()\n  })),\n  PerspectiveCamera: vi.fn(() => ({\n    position: { set: vi.fn(), x: 0, y: 0, z: 0 },\n    lookAt: vi.fn(),\n    updateProjectionMatrix: vi.fn(),\n    far: 1000\n  })),\n  CylinderGeometry: vi.fn(),\n  MeshBasicMaterial: vi.fn(() => ({\n    color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n    transparent: false,\n    opacity: 1,\n    needsUpdate: false\n  })),\n  Mesh: vi.fn(() => ({\n    position: { set: vi.fn(), x: 0, y: 0, z: 0 },\n    userData: {},\n    material: {}\n  })),\n  SphereGeometry: vi.fn(),\n  LineBasicMaterial: vi.fn(),\n  BufferGeometry: vi.fn(() => ({\n    setFromPoints: vi.fn()\n  })),\n  Vector3: vi.fn(() => ({\n    x: 0, y: 0, z: 0,\n    set: vi.fn(),\n    add: vi.fn(),\n    sub: vi.fn(),\n    normalize: vi.fn(),\n    multiplyScalar: vi.fn(),\n    cross: vi.fn(),\n    length: vi.fn(() => 1)\n  })),\n  Line: vi.fn(),\n  SpriteMaterial: vi.fn(),\n  Sprite: vi.fn(),\n  CanvasTexture: vi.fn(),\n  DirectionalLight: vi.fn(() => ({\n    position: { set: vi.fn() },\n    castShadow: false\n  })),\n  AmbientLight: vi.fn()\n}))\n\nconst mockData: DiagramData = {\n  nodes: [\n    { id: 'node1', label: 'service1', service: 'api-gateway', tenant: 'api-gateway' },\n    { id: 'node2', label: 'service2', service: 'user-service', tenant: 'user-management' }\n  ],\n  edges: [\n    { \n      source: 'node1', \n      target: 'node2', \n      count: 5,\n      traceId: 'trace-123',\n      statusCodes: { '200': 3, '500': 2 }\n    }\n  ]\n}\n\nconst mockSettings: DiagramSettings = {\n  nodeSpacing: 120,\n  clusterSpacing: 600,\n  brightness: 1.0,\n  showLabels: true,\n  showArrows: true\n}\n\ndescribe('Diagram3D Core Functionality', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('renders 3D canvas without crashing', () => {\n    render(\n      <Diagram3D \n        data={mockData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n    \n    const canvas = screen.getByRole('img', { hidden: true })\n    expect(canvas).toBeInTheDocument()\n  })\n\n  it('creates scene objects for nodes and edges', () => {\n    const { rerender } = render(\n      <Diagram3D \n        data={mockData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    // Verify Scene was created\n    expect(THREE.Scene).toHaveBeenCalled()\n    \n    // Verify camera setup\n    expect(THREE.PerspectiveCamera).toHaveBeenCalled()\n    \n    // Verify renderer setup\n    expect(THREE.WebGLRenderer).toHaveBeenCalled()\n  })\n\n  it('handles trace highlighting correctly', () => {\n    const onTraceSelect = vi.fn()\n    \n    const { rerender } = render(\n      <Diagram3D \n        data={mockData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={onTraceSelect}\n      />\n    )\n\n    // Re-render with selected trace\n    rerender(\n      <Diagram3D \n        data={mockData} \n        settings={mockSettings}\n        selectedTraceId=\"trace-123\"\n        onTraceSelect={onTraceSelect}\n      />\n    )\n\n    // Component should handle trace selection without errors\n    expect(onTraceSelect).not.toHaveBeenCalled()\n  })\n\n  it('updates when settings change', () => {\n    const { rerender } = render(\n      <Diagram3D \n        data={mockData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    const newSettings = { ...mockSettings, nodeSpacing: 200 }\n    \n    rerender(\n      <Diagram3D \n        data={mockData} \n        settings={newSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    // Should not crash on settings update\n    expect(THREE.Scene).toHaveBeenCalled()\n  })\n\n  it('handles empty data gracefully', () => {\n    const emptyData: DiagramData = { nodes: [], edges: [] }\n    \n    render(\n      <Diagram3D \n        data={emptyData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    // Should render without crashing\n    const canvas = screen.getByRole('img', { hidden: true })\n    expect(canvas).toBeInTheDocument()\n  })\n})\n\ndescribe('Diagram3D LOD System', () => {\n  it('calculates LOD based on service count', () => {\n    const largeData: DiagramData = {\n      nodes: Array.from({ length: 60 }, (_, i) => ({\n        id: `node${i}`,\n        label: `service${i}`,\n        service: `service${i}`,\n        tenant: 'tenant1'\n      })),\n      edges: []\n    }\n\n    render(\n      <Diagram3D \n        data={largeData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    // Should handle large datasets without crashing\n    expect(THREE.Scene).toHaveBeenCalled()\n  })\n})\n\ndescribe('Diagram3D Tenant System', () => {\n  it('groups nodes by tenant correctly', () => {\n    const multiTenantData: DiagramData = {\n      nodes: [\n        { id: 'node1', label: 'service1', service: 'api-service', tenant: 'tenant-a' },\n        { id: 'node2', label: 'service2', service: 'user-service', tenant: 'tenant-b' },\n        { id: 'node3', label: 'service3', service: 'data-service', tenant: 'tenant-a' }\n      ],\n      edges: [\n        { source: 'node1', target: 'node2', count: 3, statusCodes: { '200': 3 } },\n        { source: 'node2', target: 'node3', count: 2, statusCodes: { '200': 2 } }\n      ]\n    }\n\n    render(\n      <Diagram3D \n        data={multiTenantData} \n        settings={mockSettings}\n        selectedTraceId={null}\n        onTraceSelect={() => {}}\n      />\n    )\n\n    // Should handle multi-tenant data without crashing\n    expect(THREE.Scene).toHaveBeenCalled()\n  })\n})","size_bytes":6267},"client/src/components/__tests__/ObjectOrientedSystem.test.tsx":{"content":"import { describe, it, expect, vi, beforeEach } from 'vitest'\nimport * as THREE from 'three'\nimport { SceneObjectManager } from '../diagram3d/objects/SceneObjectManager'\nimport { TenantSphere } from '../diagram3d/objects/TenantSphere'\nimport type { DiagramData, DiagramSettings } from '@shared/schema'\n\n// Mock Three.js\nvi.mock('three', () => ({\n  Scene: vi.fn(() => ({\n    add: vi.fn(),\n    remove: vi.fn()\n  })),\n  SphereGeometry: vi.fn(),\n  MeshBasicMaterial: vi.fn(() => ({\n    color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n    transparent: false,\n    opacity: 1,\n    needsUpdate: false,\n    dispose: vi.fn()\n  })),\n  Mesh: vi.fn(() => ({\n    position: { copy: vi.fn(), x: 0, y: 0, z: 0 },\n    userData: {},\n    material: {\n      color: { setHex: vi.fn(), getHex: vi.fn(() => 0xffffff) },\n      transparent: false,\n      opacity: 1,\n      needsUpdate: false,\n      dispose: vi.fn()\n    },\n    geometry: { dispose: vi.fn() },\n    traverse: vi.fn()\n  })),\n  Vector3: vi.fn(() => ({\n    x: 0, y: 0, z: 0,\n    copy: vi.fn(),\n    clone: vi.fn(() => ({ x: 0, y: 0, z: 0 })),\n    distanceTo: vi.fn(() => 100)\n  })),\n  DoubleSide: 2\n}))\n\ndescribe('Object-Oriented 3D System', () => {\n  let scene: THREE.Scene\n  let manager: SceneObjectManager\n  let mockData: DiagramData\n  let mockSettings: DiagramSettings\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    scene = new THREE.Scene()\n    manager = new SceneObjectManager(scene)\n    \n    mockData = {\n      nodes: [\n        { id: 'node1', label: 'service1', service: 'api-service', tenant: 'api-gateway' },\n        { id: 'node2', label: 'service2', service: 'user-service', tenant: 'user-management' }\n      ],\n      edges: [\n        { \n          source: 'node1', \n          target: 'node2', \n          count: 5,\n          traceId: 'trace-123',\n          statusCodes: { '200': 3, '500': 2 }\n        }\n      ]\n    }\n\n    mockSettings = {\n      nodeSpacing: 120,\n      clusterSpacing: 600,\n      brightness: 1.0,\n      showLabels: true,\n      showArrows: true\n    }\n  })\n\n  describe('SceneObjectManager', () => {\n    it('should create and manage objects', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('test-tenant', position, 50, 0x00ff00)\n\n      expect(sphere).toBeInstanceOf(TenantSphere)\n      expect(sphere.tenantName).toBe('test-tenant')\n      expect(manager.getObject(sphere.id)).toBe(sphere)\n    })\n\n    it('should remove objects correctly', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('test-tenant', position, 50, 0x00ff00)\n      \n      const removed = manager.removeObject(sphere.id)\n      expect(removed).toBe(true)\n      expect(manager.getObject(sphere.id)).toBeUndefined()\n    })\n\n    it('should filter objects by type', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      manager.createTenantSphere('tenant1', position, 50, 0x00ff00)\n      manager.createTenantSphere('tenant2', position, 50, 0x0000ff)\n\n      const spheres = manager.getObjectsByType<TenantSphere>('TenantSphere')\n      expect(spheres).toHaveLength(2)\n      expect(spheres.every(s => s instanceof TenantSphere)).toBe(true)\n    })\n\n    it('should update all objects', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('test-tenant', position, 50, 0x00ff00)\n      \n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const,\n        selectedTraceId: null\n      }\n\n      // Should not throw\n      expect(() => manager.updateAll(context)).not.toThrow()\n    })\n\n    it('should highlight objects by trace', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('api-gateway', position, 50, 0x00ff00)\n      \n      // Should not throw\n      expect(() => manager.highlightByTrace('trace-123', mockData)).not.toThrow()\n    })\n\n    it('should update LOD for all objects', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('test-tenant', position, 50, 0x00ff00)\n      \n      // Should not throw\n      expect(() => manager.updateLOD('medium')).not.toThrow()\n    })\n\n    it('should clear all objects', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      manager.createTenantSphere('tenant1', position, 50, 0x00ff00)\n      manager.createTenantSphere('tenant2', position, 50, 0x0000ff)\n\n      expect(manager.getStats().total).toBe(2)\n      \n      manager.clear()\n      expect(manager.getStats().total).toBe(0)\n    })\n\n    it('should provide object statistics', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      manager.createTenantSphere('tenant1', position, 50, 0x00ff00)\n      manager.createTenantSphere('tenant2', position, 50, 0x0000ff)\n\n      const stats = manager.getStats()\n      expect(stats.total).toBe(2)\n      expect(stats.byType['TenantSphere']).toBe(2)\n    })\n  })\n\n  describe('TenantSphere', () => {\n    it('should create with correct configuration', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      expect(sphere.tenantName).toBe('test-tenant')\n      expect(sphere.radius).toBe(50)\n      expect(sphere.objectType).toBe('TenantSphere')\n    })\n\n    it('should create Three.js object', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const\n      }\n\n      const threeObject = sphere.create(context)\n      expect(threeObject).toBeDefined()\n      expect(THREE.Mesh).toHaveBeenCalled()\n    })\n\n    it('should handle highlighting correctly', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const\n      }\n\n      sphere.create(context)\n\n      // Should not throw\n      expect(() => sphere.highlight({ \n        selectedTraceId: 'trace-123', \n        relatedToTrace: true \n      })).not.toThrow()\n\n      expect(() => sphere.highlight({ \n        selectedTraceId: 'trace-123', \n        relatedToTrace: false \n      })).not.toThrow()\n\n      expect(() => sphere.highlight({ \n        selectedTraceId: null, \n        relatedToTrace: false \n      })).not.toThrow()\n    })\n\n    it('should handle LOD updates', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const\n      }\n\n      sphere.create(context)\n\n      // Should not throw\n      expect(() => sphere.updateLOD('high')).not.toThrow()\n      expect(() => sphere.updateLOD('medium')).not.toThrow()\n      expect(() => sphere.updateLOD('low')).not.toThrow()\n    })\n\n    it('should update configuration', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      const newPosition = new THREE.Vector3(200, 0, 300)\n      sphere.updateConfig({ position: newPosition, color: 0xff0000 })\n\n      // Should not throw and position should be updated\n      expect(sphere.position).toBeDefined()\n    })\n\n    it('should dispose resources correctly', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = new TenantSphere('test-id', {\n        tenantName: 'test-tenant',\n        position,\n        radius: 50,\n        color: 0x00ff00\n      })\n\n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const\n      }\n\n      sphere.create(context)\n      \n      expect(() => sphere.dispose()).not.toThrow()\n      expect(sphere.isDisposed).toBe(true)\n    })\n  })\n\n  describe('Integration with existing data', () => {\n    it('should determine trace relationships correctly', () => {\n      const position = new THREE.Vector3(100, 0, 200)\n      const sphere = manager.createTenantSphere('api-gateway', position, 50, 0x00ff00)\n      \n      // Create context and test highlighting\n      const context = {\n        data: mockData,\n        settings: mockSettings,\n        lodLevel: 'low' as const,\n        selectedTraceId: 'trace-123'\n      }\n\n      expect(() => manager.updateAll(context)).not.toThrow()\n      expect(() => manager.highlightByTrace('trace-123', mockData)).not.toThrow()\n    })\n\n    it('should handle tenant positioning', () => {\n      const tenantPositions = new Map([\n        ['api-gateway', new THREE.Vector3(0, 0, 0)],\n        ['user-management', new THREE.Vector3(600, 0, 0)]\n      ])\n      \n      const tenantRadii = new Map([\n        ['api-gateway', 100],\n        ['user-management', 120]\n      ])\n\n      // Create spheres\n      manager.createTenantSphere('api-gateway', tenantPositions.get('api-gateway')!, 100, 0x00ff00)\n      manager.createTenantSphere('user-management', tenantPositions.get('user-management')!, 120, 0x0000ff)\n\n      // Update positions\n      expect(() => manager.updateTenantSpheres(tenantPositions, tenantRadii)).not.toThrow()\n    })\n  })\n})","size_bytes":9792},"client/src/components/diagram3d/objects/Base3DObject.ts":{"content":"import * as THREE from 'three'\nimport type { DiagramData, DiagramSettings } from '@shared/schema'\n\nexport type LODLevel = 'high' | 'medium' | 'low'\n\nexport interface HighlightConfig {\n  selectedTraceId?: string | null\n  relatedToTrace: boolean\n}\n\nexport interface ObjectUpdateContext {\n  data: DiagramData\n  settings: DiagramSettings\n  lodLevel: LODLevel\n  selectedTraceId?: string | null\n}\n\n/**\n * Base abstract class for all 3D objects in the diagram\n * Provides common functionality for creation, highlighting, LOD management\n */\nexport abstract class Base3DObject {\n  protected _object: THREE.Object3D | null = null\n  protected _originalProperties: Map<string, any> = new Map()\n  protected _disposed = false\n\n  abstract readonly objectType: string\n\n  constructor(protected id: string) {}\n\n  /**\n   * Create the Three.js object - must be implemented by subclasses\n   */\n  abstract create(context: ObjectUpdateContext): THREE.Object3D\n\n  /**\n   * Update object based on new context (data changes, settings, etc.)\n   */\n  abstract update(context: ObjectUpdateContext): void\n\n  /**\n   * Apply highlighting based on trace selection\n   */\n  abstract highlight(config: HighlightConfig): void\n\n  /**\n   * Update object for specific LOD level\n   */\n  abstract updateLOD(level: LODLevel): void\n\n  /**\n   * Clean up resources\n   */\n  abstract dispose(): void\n\n  /**\n   * Get the Three.js object\n   */\n  get object(): THREE.Object3D | null {\n    return this._object\n  }\n\n  /**\n   * Check if object is disposed\n   */\n  get isDisposed(): boolean {\n    return this._disposed\n  }\n\n  /**\n   * Store original property value for restoration\n   */\n  protected storeOriginalProperty(key: string, value: any): void {\n    if (!this._originalProperties.has(key)) {\n      this._originalProperties.set(key, value)\n    }\n  }\n\n  /**\n   * Get stored original property value\n   */\n  protected getOriginalProperty(key: string): any {\n    return this._originalProperties.get(key)\n  }\n\n  /**\n   * Reset all properties to original values\n   */\n  protected resetToOriginalProperties(): void {\n    // To be overridden by subclasses for specific reset logic\n  }\n\n  /**\n   * Common highlighting logic for materials\n   */\n  protected highlightMaterial(\n    material: THREE.Material, \n    config: HighlightConfig,\n    highlightOpacity: number = 1.0,\n    dimOpacity: number = 0.3,\n    dimColor: number = 0x666666\n  ): void {\n    if (material instanceof THREE.MeshBasicMaterial || \n        material instanceof THREE.LineBasicMaterial ||\n        material instanceof THREE.SpriteMaterial) {\n      \n      // Store original color and opacity\n      this.storeOriginalProperty('color', material.color.getHex())\n      if ('opacity' in material) {\n        this.storeOriginalProperty('opacity', material.opacity)\n      }\n\n      if (config.selectedTraceId) {\n        if (config.relatedToTrace) {\n          // Highlight: restore original color, full opacity\n          const originalColor = this.getOriginalProperty('color')\n          if (originalColor !== undefined) {\n            material.color.setHex(originalColor)\n          }\n          if ('opacity' in material) {\n            material.opacity = highlightOpacity\n            material.transparent = material.opacity < 1.0\n          }\n        } else {\n          // Dim: gray color, reduced opacity\n          material.color.setHex(dimColor)\n          if ('opacity' in material) {\n            material.opacity = dimOpacity\n            material.transparent = true\n          }\n        }\n      } else {\n        // Reset: restore original properties\n        const originalColor = this.getOriginalProperty('color')\n        const originalOpacity = this.getOriginalProperty('opacity')\n        \n        if (originalColor !== undefined) {\n          material.color.setHex(originalColor)\n        }\n        if (originalOpacity !== undefined && 'opacity' in material) {\n          material.opacity = originalOpacity\n          material.transparent = material.opacity < 1.0\n        }\n      }\n\n      material.needsUpdate = true\n    }\n  }\n\n  /**\n   * Common LOD visibility logic\n   */\n  protected updateLODVisibility(level: LODLevel, showInLevels: LODLevel[]): void {\n    if (this._object) {\n      this._object.visible = showInLevels.includes(level)\n    }\n  }\n\n  /**\n   * Base dispose implementation\n   */\n  protected baseDispose(): void {\n    if (this._object) {\n      // Dispose geometries\n      this._object.traverse((child) => {\n        if (child instanceof THREE.Mesh && child.geometry) {\n          child.geometry.dispose()\n        }\n        if (child instanceof THREE.Line && child.geometry) {\n          child.geometry.dispose()\n        }\n        // Dispose materials\n        if ('material' in child && child.material) {\n          if (Array.isArray(child.material)) {\n            child.material.forEach(mat => mat.dispose())\n          } else {\n            child.material.dispose()\n          }\n        }\n      })\n    }\n\n    this._originalProperties.clear()\n    this._object = null\n    this._disposed = true\n  }\n}","size_bytes":5000},"client/src/components/diagram3d/objects/SceneObjectManager.ts":{"content":"import * as THREE from 'three'\nimport { Base3DObject, type LODLevel, type ObjectUpdateContext } from './Base3DObject'\nimport { TenantSphere } from './TenantSphere'\nimport type { DiagramData } from '@shared/schema'\n\nexport type ObjectFactory<T extends Base3DObject> = (id: string, ...args: any[]) => T\n\n/**\n * Manages all 3D objects in the scene\n * Provides centralized control for creation, updates, highlighting, and disposal\n */\nexport class SceneObjectManager {\n  private objects: Map<string, Base3DObject> = new Map()\n  private scene: THREE.Scene\n  private lastContext: ObjectUpdateContext | null = null\n\n  constructor(scene: THREE.Scene) {\n    this.scene = scene\n  }\n\n  /**\n   * Register a new object with the manager\n   */\n  addObject(object: Base3DObject): void {\n    if (this.objects.has(object.id)) {\n      console.warn(`Object with id ${object.id} already exists, replacing...`)\n      this.removeObject(object.id)\n    }\n\n    this.objects.set(object.id, object)\n    \n    // Create the object if we have context\n    if (this.lastContext && !object.object) {\n      const threeObject = object.create(this.lastContext)\n      this.scene.add(threeObject)\n    }\n  }\n\n  /**\n   * Remove and dispose an object\n   */\n  removeObject(id: string): boolean {\n    const object = this.objects.get(id)\n    if (!object) return false\n\n    // Remove from scene\n    if (object.object) {\n      this.scene.remove(object.object)\n    }\n\n    // Dispose resources\n    object.dispose()\n    \n    // Remove from manager\n    this.objects.delete(id)\n    return true\n  }\n\n  /**\n   * Get object by ID\n   */\n  getObject(id: string): Base3DObject | undefined {\n    return this.objects.get(id)\n  }\n\n  /**\n   * Get all objects of specific type\n   */\n  getObjectsByType<T extends Base3DObject>(type: string): T[] {\n    return Array.from(this.objects.values())\n      .filter(obj => obj.objectType === type) as T[]\n  }\n\n  /**\n   * Update all objects with new context\n   */\n  updateAll(context: ObjectUpdateContext): void {\n    this.lastContext = context\n\n    this.objects.forEach(object => {\n      try {\n        // Create object if it doesn't exist\n        if (!object.object) {\n          const threeObject = object.create(context)\n          this.scene.add(threeObject)\n        } else {\n          // Update existing object\n          object.update(context)\n        }\n      } catch (error) {\n        console.error(`Error updating object ${object.id}:`, error)\n      }\n    })\n  }\n\n  /**\n   * Highlight objects based on trace selection\n   */\n  highlightByTrace(selectedTraceId: string | null, data: DiagramData): void {\n    this.objects.forEach(object => {\n      try {\n        const relatedToTrace = this.isObjectRelatedToTrace(object, selectedTraceId, data)\n        object.highlight({ selectedTraceId, relatedToTrace })\n      } catch (error) {\n        console.error(`Error highlighting object ${object.id}:`, error)\n      }\n    })\n  }\n\n  /**\n   * Update LOD for all objects\n   */\n  updateLOD(level: LODLevel): void {\n    this.objects.forEach(object => {\n      try {\n        object.updateLOD(level)\n      } catch (error) {\n        console.error(`Error updating LOD for object ${object.id}:`, error)\n      }\n    })\n  }\n\n  /**\n   * Clear all objects\n   */\n  clear(): void {\n    this.objects.forEach(object => {\n      if (object.object) {\n        this.scene.remove(object.object)\n      }\n      object.dispose()\n    })\n    this.objects.clear()\n  }\n\n  /**\n   * Clear objects of specific types, preserving others\n   */\n  clearByTypes(typesToClear: string[]): void {\n    const objectsToRemove: string[] = []\n    \n    this.objects.forEach((object, id) => {\n      if (typesToClear.includes(object.objectType)) {\n        objectsToRemove.push(id)\n      }\n    })\n\n    objectsToRemove.forEach(id => this.removeObject(id))\n  }\n\n  /**\n   * Preserve essential objects during scene reconstruction\n   */\n  preserveEssentialObjects(): Base3DObject[] {\n    const essentialTypes = ['TenantSphere', 'Light', 'Axis']\n    return Array.from(this.objects.values())\n      .filter(obj => essentialTypes.includes(obj.objectType))\n  }\n\n  /**\n   * Get statistics about managed objects\n   */\n  getStats(): { total: number; byType: Record<string, number> } {\n    const byType: Record<string, number> = {}\n    \n    this.objects.forEach(object => {\n      byType[object.objectType] = (byType[object.objectType] || 0) + 1\n    })\n\n    return {\n      total: this.objects.size,\n      byType\n    }\n  }\n\n  /**\n   * Debug: List all objects\n   */\n  debug(): void {\n    console.log('ðŸ” SceneObjectManager Debug:', {\n      objectCount: this.objects.size,\n      objects: Array.from(this.objects.entries()).map(([id, obj]) => ({\n        id,\n        type: obj.objectType,\n        hasThreeObject: !!obj.object,\n        isDisposed: obj.isDisposed\n      }))\n    })\n  }\n\n  /**\n   * Determine if an object is related to the selected trace\n   */\n  private isObjectRelatedToTrace(\n    object: Base3DObject, \n    selectedTraceId: string | null, \n    data: DiagramData\n  ): boolean {\n    if (!selectedTraceId) return false\n\n    // For tenant spheres, check if any edge in the trace involves this tenant\n    if (object instanceof TenantSphere) {\n      return data.edges.some(edge => {\n        if (!edge.traceId) return false\n        const traceIds = edge.traceId.split(',').map(id => id.trim())\n        if (!traceIds.includes(selectedTraceId)) return false\n\n        // Check if either endpoint belongs to this tenant\n        const sourceNode = data.nodes.find(n => n.id === edge.source)\n        const targetNode = data.nodes.find(n => n.id === edge.target)\n        \n        return (sourceNode?.tenant === object.tenantName) || \n               (targetNode?.tenant === object.tenantName)\n      })\n    }\n\n    // Default: not related\n    return false\n  }\n\n  /**\n   * Factory method for creating tenant spheres\n   */\n  createTenantSphere(\n    tenantName: string,\n    position: THREE.Vector3,\n    radius: number,\n    color: number\n  ): TenantSphere {\n    const id = `tenant-sphere-${tenantName}`\n    const sphere = new TenantSphere(id, {\n      tenantName,\n      position,\n      radius,\n      color\n    })\n    \n    this.addObject(sphere)\n    return sphere\n  }\n\n  /**\n   * Get tenant sphere by tenant name\n   */\n  getTenantSphere(tenantName: string): TenantSphere | undefined {\n    const id = `tenant-sphere-${tenantName}`\n    return this.getObject(id) as TenantSphere\n  }\n\n  /**\n   * Update tenant sphere positions and sizes\n   */\n  updateTenantSpheres(\n    tenantPositions: Map<string, THREE.Vector3>,\n    tenantRadii: Map<string, number>\n  ): void {\n    this.getObjectsByType<TenantSphere>('TenantSphere').forEach(sphere => {\n      const position = tenantPositions.get(sphere.tenantName)\n      const radius = tenantRadii.get(sphere.tenantName)\n      \n      if (position || radius) {\n        sphere.updateConfig({\n          ...(position && { position }),\n          ...(radius && { radius })\n        })\n      }\n    })\n  }\n\n  /**\n   * Check if a point intersects with any tenant sphere\n   */\n  getTenantAtPoint(point: THREE.Vector3): string | null {\n    for (const sphere of this.getObjectsByType<TenantSphere>('TenantSphere')) {\n      if (sphere.containsPoint(point)) {\n        return sphere.tenantName\n      }\n    }\n    return null\n  }\n\n  /**\n   * Get nearest tenant sphere to a point\n   */\n  getNearestTenant(point: THREE.Vector3): { tenantName: string; distance: number } | null {\n    let nearest: { tenantName: string; distance: number } | null = null\n    \n    for (const sphere of this.getObjectsByType<TenantSphere>('TenantSphere')) {\n      const distance = sphere.distanceToPoint(point)\n      if (!nearest || distance < nearest.distance) {\n        nearest = { tenantName: sphere.tenantName, distance }\n      }\n    }\n    \n    return nearest\n  }\n}","size_bytes":7751},"client/src/components/diagram3d/objects/TenantSphere.ts":{"content":"import * as THREE from 'three'\nimport { Base3DObject, type LODLevel, type HighlightConfig, type ObjectUpdateContext } from './Base3DObject'\n\nexport interface TenantSphereConfig {\n  tenantName: string\n  position: THREE.Vector3\n  radius: number\n  color: number\n}\n\n/**\n * Represents a tenant boundary sphere in the 3D diagram\n * Used to visually group services belonging to the same tenant\n */\nexport class TenantSphere extends Base3DObject {\n  readonly objectType = 'TenantSphere'\n  \n  private config: TenantSphereConfig\n  private mesh: THREE.Mesh | null = null\n\n  constructor(id: string, config: TenantSphereConfig) {\n    super(id)\n    this.config = config\n  }\n\n  create(context: ObjectUpdateContext): THREE.Object3D {\n    if (this._object) {\n      return this._object\n    }\n\n    // Create sphere geometry\n    const geometry = new THREE.SphereGeometry(this.config.radius, 16, 12)\n    \n    // Create material with transparency\n    const material = new THREE.MeshBasicMaterial({\n      color: this.config.color,\n      transparent: true,\n      opacity: this.getOpacityForLOD(context.lodLevel),\n      side: THREE.DoubleSide\n    })\n\n    // Create mesh\n    this.mesh = new THREE.Mesh(geometry, material)\n    this.mesh.position.copy(this.config.position)\n    \n    // Set user data for identification\n    this.mesh.userData = {\n      isTenantSphere: true,\n      tenantName: this.config.tenantName,\n      lodLevel: context.lodLevel,\n      objectId: this.id\n    }\n\n    this._object = this.mesh\n    \n    // Store original properties\n    this.storeOriginalProperty('color', this.config.color)\n    this.storeOriginalProperty('opacity', material.opacity)\n\n    return this._object\n  }\n\n  update(context: ObjectUpdateContext): void {\n    if (!this.mesh) return\n\n    // Update LOD level in userData\n    this.mesh.userData.lodLevel = context.lodLevel\n    \n    // Update opacity based on LOD\n    const material = this.mesh.material as THREE.MeshBasicMaterial\n    material.opacity = this.getOpacityForLOD(context.lodLevel)\n    material.needsUpdate = true\n\n    // Update position if needed\n    this.mesh.position.copy(this.config.position)\n  }\n\n  highlight(config: HighlightConfig): void {\n    if (!this.mesh) return\n\n    const material = this.mesh.material as THREE.MeshBasicMaterial\n    const lodLevel = this.mesh.userData.lodLevel as LODLevel\n\n    if (config.selectedTraceId) {\n      if (config.relatedToTrace) {\n        // Highlighted sphere: use original color with high opacity\n        const originalColor = this.getOriginalProperty('color')\n        if (originalColor !== undefined) {\n          material.color.setHex(originalColor)\n        }\n        material.opacity = lodLevel === 'low' ? 0.8 : 0.01\n        material.transparent = true\n      } else {\n        // Dimmed sphere: dark color with low opacity\n        material.color.setHex(0x333333)\n        material.opacity = lodLevel === 'low' ? 0.1 : 0.005\n        material.transparent = true\n      }\n    } else {\n      // Reset to original state\n      const originalColor = this.getOriginalProperty('color')\n      if (originalColor !== undefined) {\n        material.color.setHex(originalColor)\n      }\n      material.opacity = this.getOpacityForLOD(lodLevel)\n      material.transparent = true\n    }\n\n    material.needsUpdate = true\n  }\n\n  updateLOD(level: LODLevel): void {\n    if (!this.mesh) return\n\n    // Update userData\n    this.mesh.userData.lodLevel = level\n    \n    // Update opacity\n    const material = this.mesh.material as THREE.MeshBasicMaterial\n    material.opacity = this.getOpacityForLOD(level)\n    material.needsUpdate = true\n\n    // Tenant spheres are primarily visible in low LOD mode\n    this.updateLODVisibility(level, ['low', 'medium'])\n  }\n\n  dispose(): void {\n    if (this.mesh) {\n      if (this.mesh.geometry) {\n        this.mesh.geometry.dispose()\n      }\n      if (this.mesh.material) {\n        this.mesh.material.dispose()\n      }\n      this.mesh = null\n    }\n    \n    this.baseDispose()\n  }\n\n  /**\n   * Update sphere configuration\n   */\n  updateConfig(newConfig: Partial<TenantSphereConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    if (this.mesh && newConfig.position) {\n      this.mesh.position.copy(newConfig.position)\n    }\n    \n    if (this.mesh && newConfig.color) {\n      const material = this.mesh.material as THREE.MeshBasicMaterial\n      material.color.setHex(newConfig.color)\n      this.storeOriginalProperty('color', newConfig.color)\n      material.needsUpdate = true\n    }\n  }\n\n  /**\n   * Get sphere radius\n   */\n  get radius(): number {\n    return this.config.radius\n  }\n\n  /**\n   * Get tenant name\n   */\n  get tenantName(): string {\n    return this.config.tenantName\n  }\n\n  /**\n   * Get sphere center position\n   */\n  get position(): THREE.Vector3 {\n    return this.config.position.clone()\n  }\n\n  /**\n   * Calculate appropriate opacity for LOD level\n   */\n  private getOpacityForLOD(level: LODLevel): number {\n    switch (level) {\n      case 'high':\n        return 0.01  // Nearly invisible at high detail\n      case 'medium':\n        return 0.05  // Subtle at medium detail\n      case 'low':\n        return 1.0   // Fully visible at low detail\n      default:\n        return 0.05\n    }\n  }\n\n  /**\n   * Check if a point is inside this sphere\n   */\n  containsPoint(point: THREE.Vector3): boolean {\n    return this.config.position.distanceTo(point) <= this.config.radius\n  }\n\n  /**\n   * Get distance from sphere surface to a point\n   */\n  distanceToPoint(point: THREE.Vector3): number {\n    return Math.max(0, this.config.position.distanceTo(point) - this.config.radius)\n  }\n}","size_bytes":5577},"client/src/components/diagram3d/magistral.ts":{"content":"import * as THREE from \"three\";\nimport type { MagistralConnection, ParsedFileData, Obstacle } from \"./types\";\nimport { calculateObstavoidingPath } from \"./pathfinding\";\n\nexport function aggregateInterTenantConnections(data: ParsedFileData): Map<string, MagistralConnection> {\n  const magistrals = new Map<string, MagistralConnection>();\n  \n  console.log(`ðŸŒ‰ DEBUG: Starting magistral aggregation with ${data.edges.length} edges`);\n  \n  let interTenantCount = 0;\n  let intraTenantCount = 0;\n  let invalidCount = 0;\n  \n  data.edges.forEach((edge, index) => {\n    const sourceId = typeof edge.source === 'string' ? edge.source : edge.source.id;\n    const targetId = typeof edge.target === 'string' ? edge.target : edge.target.id;\n    const sourceNode = data.nodes.find(n => n.id === sourceId);\n    const targetNode = data.nodes.find(n => n.id === targetId);\n    \n    if (!sourceNode || !targetNode || !sourceNode.tenant || !targetNode.tenant) {\n      invalidCount++;\n      if (index < 5) { // Log first 5 invalid edges for debugging\n        console.log(`ðŸŒ‰ DEBUG: Invalid edge ${index}: ${sourceId} â†’ ${targetId}, sourceNode: ${!!sourceNode}, targetNode: ${!!targetNode}, sourceTenant: ${sourceNode?.tenant}, targetTenant: ${targetNode?.tenant}`);\n      }\n      return;\n    }\n    \n    if (sourceNode.tenant === targetNode.tenant) {\n      intraTenantCount++;\n      return; // Skip intra-tenant\n    }\n    \n    interTenantCount++;\n    const magistralKey = `${sourceNode.tenant}->${targetNode.tenant}`;\n    \n    if (index < 5) { // Log first 5 inter-tenant connections for debugging\n      console.log(`ðŸŒ‰ DEBUG: Inter-tenant edge ${index}: ${sourceNode.tenant} â†’ ${targetNode.tenant} (${sourceId} â†’ ${targetId})`);\n    }\n    \n    if (!magistrals.has(magistralKey)) {\n      magistrals.set(magistralKey, {\n        sourceTenant: sourceNode.tenant,\n        targetTenant: targetNode.tenant,\n        edges: [],\n        connectionCount: 0,\n        statusCodes: {}\n      });\n      console.log(`ðŸŒ‰ DEBUG: Created new magistral: ${magistralKey}`);\n    }\n    \n    const magistral = magistrals.get(magistralKey)!;\n    magistral.edges.push(edge);\n    magistral.connectionCount += edge.connectionCount || 1;\n    \n    // Aggregate status codes\n    if (edge.statusCounts) {\n      Object.entries(edge.statusCounts).forEach(([status, count]) => {\n        magistral.statusCodes[status] = (magistral.statusCodes[status] || 0) + (count as number);\n      });\n    }\n  });\n  \n  console.log(`ðŸŒ‰ DEBUG: Magistral aggregation complete - Inter-tenant: ${interTenantCount}, Intra-tenant: ${intraTenantCount}, Invalid: ${invalidCount}, Magistrals created: ${magistrals.size}`);\n  \n  if (magistrals.size > 0) {\n    console.log(`ðŸŒ‰ DEBUG: Magistral summary:`);\n    magistrals.forEach((magistral, key) => {\n      console.log(`   ${key}: ${magistral.connectionCount} connections, ${magistral.edges.length} edges`);\n    });\n  }\n  \n  return magistrals;\n}\n\nexport function createMagistralPath(\n  sourceCenter: THREE.Vector3,\n  targetCenter: THREE.Vector3,\n  obstacles: Obstacle[],\n  offsetVector?: THREE.Vector3,\n  sourceTenant?: string,\n  targetTenant?: string\n): THREE.Vector3[] {\n  let adjustedSource = sourceCenter.clone();\n  let adjustedTarget = targetCenter.clone();\n  \n  if (offsetVector) {\n    adjustedSource.add(offsetVector);\n    adjustedTarget.add(offsetVector);\n  }\n  \n  // Filter out source and target tenants from obstacles to allow direct connections\n  const filteredObstacles = obstacles.filter(obstacle => {\n    const distToSource = obstacle.position.distanceTo(sourceCenter);\n    const distToTarget = obstacle.position.distanceTo(targetCenter);\n    // Remove obstacles that are too close to source or target (same tenant)\n    return distToSource > 50 && distToTarget > 50;\n  });\n  \n  console.log(`ðŸ›£ï¸ MAGISTRAL PATH DEBUG for ${sourceTenant} â†’ ${targetTenant}:`);\n  console.log(`   Source: (${adjustedSource.x.toFixed(1)}, ${adjustedSource.y.toFixed(1)}, ${adjustedSource.z.toFixed(1)})`);\n  console.log(`   Target: (${adjustedTarget.x.toFixed(1)}, ${adjustedTarget.y.toFixed(1)}, ${adjustedTarget.z.toFixed(1)})`);\n  console.log(`   Distance: ${adjustedSource.distanceTo(adjustedTarget).toFixed(1)}`);\n  console.log(`   Filtered obstacles: ${filteredObstacles.length} (total: ${obstacles.length})`);\n  \n  const resultPath = calculateObstavoidingPath(adjustedSource, adjustedTarget, filteredObstacles, 15);\n  \n  console.log(`   Result path length: ${resultPath.length} points`);\n  if (resultPath.length > 0) {\n    console.log(`   Path start: (${resultPath[0].x.toFixed(1)}, ${resultPath[0].y.toFixed(1)}, ${resultPath[0].z.toFixed(1)})`);\n    console.log(`   Path end: (${resultPath[resultPath.length-1].x.toFixed(1)}, ${resultPath[resultPath.length-1].y.toFixed(1)}, ${resultPath[resultPath.length-1].z.toFixed(1)})`);\n  }\n  \n  return resultPath;\n}\n\nexport function calculateMagistralOffset(\n  sourceCenter: THREE.Vector3,\n  targetCenter: THREE.Vector3,\n  existingMagistrals: Map<string, { source: THREE.Vector3; target: THREE.Vector3 }>\n): THREE.Vector3 | null {\n  const currentVector = new THREE.Vector3().subVectors(targetCenter, sourceCenter);\n  const currentLength = currentVector.length();\n  \n  for (const [key, existing] of existingMagistrals) {\n    const existingVector = new THREE.Vector3().subVectors(existing.target, existing.source);\n    const existingLength = existingVector.length();\n    \n    const centerDistance = sourceCenter.distanceTo(existing.source);\n    \n    if (centerDistance < 100 && Math.abs(currentLength - existingLength) < 50) {\n      const perpendicular = new THREE.Vector3(-currentVector.z, 0, currentVector.x).normalize();\n      return perpendicular.multiplyScalar(50);\n    }\n  }\n  \n  return null;\n}\n\nexport function getMagistralColor(magistral: MagistralConnection, isReverse: boolean = false): number {\n  return isReverse ? 0x8B5CF6 : 0x10B981; // Purple : Green\n}\n\nexport function calculateMagistralThickness(connectionCount: number, maxCount: number): number {\n  // Uniform thickness for all magistrals regardless of connection count\n  return 10; // Fixed thickness of 10 units for all magistrals\n}\n\n// Unified function to calculate magistral endpoints (touch points with tenant spheres)\nexport function calculateMagistralEndpoints(\n  sourceCenter: THREE.Vector3,\n  targetCenter: THREE.Vector3,\n  sourceSphereRadius: number,\n  targetSphereRadius: number\n): { sourceEndpoint: THREE.Vector3; targetEndpoint: THREE.Vector3; direction: THREE.Vector3 } {\n  const direction = new THREE.Vector3().subVectors(targetCenter, sourceCenter).normalize();\n  \n  const sourceEndpoint = sourceCenter.clone().add(direction.clone().multiplyScalar(sourceSphereRadius));\n  const targetEndpoint = targetCenter.clone().sub(direction.clone().multiplyScalar(targetSphereRadius));\n  \n  return {\n    sourceEndpoint,\n    targetEndpoint,\n    direction\n  };\n}\n\nexport function createDirectionalArrow(\n  scene: THREE.Scene,\n  position: THREE.Vector3,\n  direction: THREE.Vector3,\n  color: number,\n  scale: number = 1\n): THREE.Group {\n  const arrowGroup = new THREE.Group();\n  \n  // Validate parameters and provide safe defaults\n  const safeScale = isNaN(scale) || scale <= 0 ? 1 : scale;\n  const safeRadius = 16 * safeScale;\n  const safeHeight = 40 * safeScale;\n  \n  // Validate direction vector\n  if (direction.length() === 0) {\n    console.warn('createDirectionalArrow: Invalid direction vector', direction);\n    direction.set(1, 0, 0); // Default direction\n  }\n  \n  // Arrow cone with validated parameters\n  const arrowGeometry = new THREE.ConeGeometry(safeRadius, safeHeight, 6);\n  const arrowMaterial = new THREE.MeshBasicMaterial({ color });\n  const arrowMesh = new THREE.Mesh(arrowGeometry, arrowMaterial);\n  \n  arrowMesh.position.copy(position);\n  arrowMesh.lookAt(position.clone().add(direction.clone().normalize()));\n  arrowMesh.rotateX(Math.PI / 2);\n  \n  arrowGroup.add(arrowMesh);\n  scene.add(arrowGroup);\n  \n  return arrowGroup;\n}","size_bytes":7946}}}